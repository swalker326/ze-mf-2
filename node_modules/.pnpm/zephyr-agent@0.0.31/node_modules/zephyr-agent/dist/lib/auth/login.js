"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTokenStillValid = exports.checkAuth = void 0;
const tslib_1 = require("tslib");
const jose = tslib_1.__importStar(require("jose"));
const zephyr_edge_contract_1 = require("zephyr-edge-contract");
const ze_log_event_1 = require("../logging/ze-log-event");
const websocket_1 = require("./websocket");
const secret_token_1 = require("../node-persist/secret-token");
const token_1 = require("../node-persist/token");
const logging_1 = require("../logging");
const picocolor_1 = require("../logging/picocolor");
const ze_http_request_1 = require("../http/ze-http-request");
const errors_1 = require("../errors");
/**
 * Check if the user is already authenticated. If not, open a browser window to
 * authenticate. Display a message to the console.
 *
 * @returns The token as a string.
 */
async function checkAuth() {
    const secret_token = (0, secret_token_1.getSecretToken)();
    if (secret_token) {
        return secret_token;
    }
    const token = await (0, token_1.getToken)();
    if (token) {
        // Check if the token has a valid expiration date.
        if (isTokenStillValid(token, 60)) {
            (0, logging_1.ze_log)('You are already logged in');
            return token;
        }
        await (0, token_1.removeToken)();
    }
    // No valid token found; initiate authentication.
    const newToken = await authenticateUser();
    (0, logging_1.ze_log)('You are logged in');
    return newToken;
}
exports.checkAuth = checkAuth;
/**
 * Decides whether the token is still valid based on its expiration time.
 *
 * @param token The token to check.
 * @param gap In seconds
 * @returns Boolean indicating if the token is still valid.
 */
function isTokenStillValid(token, gap = 0) {
    // Attempts to decode the token
    try {
        const decodedToken = jose.decodeJwt(token);
        if (decodedToken.exp) {
            return new Date(decodedToken.exp * 1000) > new Date(Date.now() + gap * 1000);
        }
        // No expiration date found, invalid token.
        return false;
    }
    catch (_a) {
        // If the token is invalid, return false.
        return false;
    }
}
exports.isTokenStillValid = isTokenStillValid;
/** Opens the given URL in the default browser. */
async function openUrl(url) {
    // Lazy loads `open` module
    const openModule = (await eval(`import('open')`));
    await openModule.default(url);
}
/** Generates a URL-safe random string to use as a session key. */
function generateSessionKey() {
    return encodeURIComponent(Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15));
}
/** Tries to log in the user and get back the websocket reply containing the access token. */
async function getPersonalAccessTokenFromWebsocket() {
    const sessionKey = generateSessionKey();
    // Attempts to open the browser to authenticate the user.
    const authUrl = await getAuthenticationURL(sessionKey);
    try {
        await openUrl(authUrl);
        (0, ze_log_event_1.logFn)('debug', 'Opening browser for authentication...');
    }
    catch (error) {
        (0, logging_1.ze_log)(error);
        (0, ze_log_event_1.logFn)('debug', `Could not open browser to authenticate with ZephyrCloud. Please open the link below to authenticate:\n\n${(0, picocolor_1.white)(authUrl)}\n`);
    }
    return await waitForAccessToken(sessionKey);
}
/** Generates the URL to authenticate the user. */
async function getAuthenticationURL(state) {
    const [ok, cause, data] = await ze_http_request_1.ZeHttpRequest.from({
        path: zephyr_edge_contract_1.ze_api_gateway.auth_link,
        base: (0, zephyr_edge_contract_1.ZE_API_ENDPOINT)(),
        query: { state },
    });
    if (!ok) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
            cause,
            message: 'Could not get authentication URL',
        });
    }
    return data;
}
/**
 * Initiates user authentication and handles token storage.
 *
 * @returns The new token as a string.
 */
async function authenticateUser() {
    const token = await getPersonalAccessTokenFromWebsocket();
    await (0, token_1.saveToken)(token);
    return token;
}
/** Waits for the access token to be received from the websocket. */
async function waitForAccessToken(sessionKey) {
    const { promise, resolve, reject } = (0, zephyr_edge_contract_1.PromiseWithResolvers)();
    const socket = (0, websocket_1.createSocket)((0, zephyr_edge_contract_1.ZEPHYR_API_ENDPOINT)());
    try {
        socket.once('access-token', resolve);
        // Creating errors outside of the listener closure makes the stack trace point
        // to waitForAccessToken fn instead of socket.io internals event emitter code.
        socket.once('access-token-error', (cause) => reject(new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
            cause,
            message: 'Error getting access token',
        })));
        socket.once('connect_error', (cause) => reject(new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
            message: 'Could not connect to socket.',
            cause,
        })));
        socket.emit('joinAccessTokenRoom', { state: sessionKey });
        // The user has 60 seconds to log in through the browser.
        setTimeout(reject, 60000, new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
            message: "Couldn't receive access token in 1 minute.",
        }));
        return await promise;
    }
    finally {
        socket.close();
    }
}
//# sourceMappingURL=login.js.map
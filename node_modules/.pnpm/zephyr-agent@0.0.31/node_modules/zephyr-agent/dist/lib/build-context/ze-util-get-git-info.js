"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGitInfo = void 0;
const tslib_1 = require("tslib");
const git_url_parse_1 = tslib_1.__importDefault(require("git-url-parse"));
const is_ci_1 = tslib_1.__importDefault(require("is-ci"));
const node_child_process_1 = tslib_1.__importDefault(require("node:child_process"));
const node_crypto_1 = require("node:crypto");
const node_util_1 = require("node:util");
const errors_1 = require("../errors");
const logging_1 = require("../logging");
const secret_token_1 = require("../node-persist/secret-token");
const exec = (0, node_util_1.promisify)(node_child_process_1.default.exec);
/** Loads the git information from the current repository. */
async function getGitInfo() {
    const hasToken = (0, secret_token_1.hasSecretToken)();
    const { name, email, remoteOrigin, branch, commit, stdout } = await loadGitInfo(hasToken);
    if (!hasToken && (!name || !email)) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_USERNAME_EMAIL, {
            data: { stdout },
        });
    }
    const app = parseGitUrl(remoteOrigin, stdout);
    const gitInfo = {
        git: { name, email, branch, commit },
        app,
    };
    (0, logging_1.ze_log)('Loaded: git info', gitInfo);
    return gitInfo;
}
exports.getGitInfo = getGitInfo;
/** Loads all data in a single command to avoid multiple executions. */
async function loadGitInfo(hasSecretToken) {
    const automated = is_ci_1.default || hasSecretToken;
    // ensures multi line output on errors doesn't break the parsing
    const delimiter = (0, node_crypto_1.randomUUID)().repeat(2);
    const command = [
        // Inside CI environments, the last committer should be the actor
        // and not the actual logged git user which sometimes might just be a bot
        automated ? "git log -1 --pretty=format:'%an'" : 'git config user.name',
        automated ? "git log -1 --pretty=format:'%ae'" : 'git config user.email',
        // TODO: support remote names that are not 'origin'
        'git config --get remote.origin.url',
        'git rev-parse --abbrev-ref HEAD',
        'git rev-parse HEAD',
    ].join(` && echo ${delimiter} && `);
    try {
        const { stdout } = await exec(command);
        const [name, email, remoteOrigin, branch, commit] = stdout
            .trim()
            .split(delimiter)
            .map((x) => x.trim());
        return {
            name,
            email,
            remoteOrigin,
            branch,
            commit,
            stdout,
        };
    }
    catch (cause) {
        const error = cause;
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
            cause,
            data: { command, delimiter },
            message: (error === null || error === void 0 ? void 0 : error.stderr) || error.message,
        });
    }
}
/**
 * Parses the git url using the `git-url-parse` package.
 *
 * This package differentiate CI providers and handle a lot of small utilities for getting
 * git info from `azure`, `aws` etc
 */
function parseGitUrl(remoteOrigin, stdout) {
    if (!remoteOrigin) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_GIT_REMOTE_ORIGIN, {
            data: { stdout },
        });
    }
    let parsed;
    try {
        parsed = (0, git_url_parse_1.default)(remoteOrigin);
    }
    catch (cause) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
            message: stdout,
            cause,
            data: { stdout },
        });
    }
    if (!parsed.owner || !parsed.name) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_GIT_REMOTE_ORIGIN, {
            data: { stdout },
        });
    }
    return {
        org: parsed.owner.toLocaleLowerCase(),
        project: parsed.name.toLocaleLowerCase(),
    };
}
//# sourceMappingURL=ze-util-get-git-info.js.map
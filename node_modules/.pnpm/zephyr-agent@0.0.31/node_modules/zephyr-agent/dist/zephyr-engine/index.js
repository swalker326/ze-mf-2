"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZephyrEngine = exports.is_zephyr_resolved_dependency = exports.is_zephyr_dependency_pair = void 0;
const tslib_1 = require("tslib");
const zephyr_edge_contract_1 = require("zephyr-edge-contract");
const resolve_remote_dependency_1 = require("./resolve_remote_dependency");
const isCI = tslib_1.__importStar(require("is-ci"));
const ze_util_get_git_info_1 = require("../lib/build-context/ze-util-get-git-info");
const ze_log_event_1 = require("../lib/logging/ze-log-event");
const ze_util_read_package_json_1 = require("../lib/build-context/ze-util-read-package-json");
const login_1 = require("../lib/auth/login");
const get_application_configuration_1 = require("../lib/edge-requests/get-application-configuration");
const get_build_id_1 = require("../lib/edge-requests/get-build-id");
const distributed_hash_control_1 = require("../lib/edge-hash-list/distributed-hash-control");
const get_upload_strategy_1 = require("../lib/deployment/get-upload-strategy");
const get_missing_assets_1 = require("../lib/edge-hash-list/get-missing-assets");
const ze_build_snapshot_1 = require("../lib/transformers/ze-build-snapshot");
const app_deploy_result_cache_1 = require("../lib/node-persist/app-deploy-result-cache");
const logging_1 = require("../lib/logging");
const picocolor_1 = require("../lib/logging/picocolor");
function is_zephyr_dependency_pair(dep) {
    return dep !== null;
}
exports.is_zephyr_dependency_pair = is_zephyr_dependency_pair;
function is_zephyr_resolved_dependency(dep) {
    return dep !== null;
}
exports.is_zephyr_resolved_dependency = is_zephyr_resolved_dependency;
/**
 * IMPORTANT: do NOT add methods to this class, keep it lean! IMPORTANT: use `await
 * ZephyrEngine.create(context)` to create an instance ZephyrEngine instance represents
 * current state of a build if there are methods - they should call pure functions from
 * ./internal
 */
class ZephyrEngine {
    /** This is intentionally PRIVATE use `await ZephyrEngine.create(context)` */
    constructor(context) {
        this.context = context;
        // build context properties
        this.env = { isCI, buildEnv: isCI ? 'ci' : 'local' };
        this.buildProperties = { output: './dist' };
        // resolved dependencies
        this.federated_dependencies = null;
        // build hook properties
        this.build_start_time = null;
        this.build_id = null;
        this.snapshotId = null;
        this.hash_list = null;
        this.version_url = null;
    }
    static defer_create() {
        let zephyr_defer_create;
        const zephyr_engine_defer = new Promise((r) => {
            zephyr_defer_create = (context) => r(ZephyrEngine.create(context));
        });
        return { zephyr_engine_defer, zephyr_defer_create };
    }
    // todo: extract to a separate fn
    static async create(context) {
        context = context || process.cwd();
        (0, logging_1.ze_log)(`Initializing: Zephyr Engine for ${context}`);
        const ze = new ZephyrEngine(context);
        (0, logging_1.ze_log)('Initializing: npm package info');
        ze.npmProperties = await (0, ze_util_read_package_json_1.getPackageJson)(context);
        (0, logging_1.ze_log)('Initializing: git info');
        ze.gitProperties = await (0, ze_util_get_git_info_1.getGitInfo)();
        // mut: set application_uid and applicationProperties
        mut_zephyr_app_uid(ze);
        const application_uid = ze.application_uid;
        // starting async load of application configuration, build_id and hash_list
        (0, logging_1.ze_log)('Initializing: checking authentication');
        await (0, login_1.checkAuth)();
        (0, logging_1.ze_log)('Initialized: loading of application configuration');
        ze.application_configuration = (0, get_application_configuration_1.getApplicationConfiguration)({ application_uid });
        ze.application_configuration
            .then((appConfig) => {
            const { username, email, EDGE_URL } = appConfig;
            (0, logging_1.ze_log)('Loaded: application configuration', { username, email, EDGE_URL });
        })
            .catch((err) => (0, logging_1.ze_log)(`Failed to get application configuration: ${err}`));
        await ze.start_new_build();
        ze.logger.then(async (logger) => {
            const { username } = await ze.application_configuration;
            const buildId = await ze.build_id;
            logger({
                level: 'info',
                action: 'build:info:user',
                ignore: true,
                message: `Hi ${(0, picocolor_1.cyanBright)(username)}!\n${(0, picocolor_1.white)(application_uid)}${(0, picocolor_1.yellow)(`#${buildId}`)}\n`,
            });
        });
        return ze;
    }
    async resolve_remote_dependencies(deps) {
        if (!deps) {
            return null;
        }
        const tasks = deps.map(async (dep) => {
            const [app_name, project_name, org_name] = dep.name.split('.', 3);
            // Key might be only the app name
            const dep_application_uid = (0, zephyr_edge_contract_1.createApplicationUid)({
                org: org_name !== null && org_name !== void 0 ? org_name : this.gitProperties.app.org,
                project: project_name !== null && project_name !== void 0 ? project_name : this.gitProperties.app.project,
                name: app_name,
            });
            // if default url is url - set as default, if not use app remote_host as default
            // if default url is not url - send it as a semver to deps resolution
            const tuple = await zephyr_edge_contract_1.ZeUtils.PromiseTuple((0, resolve_remote_dependency_1.resolve_remote_dependency)({
                application_uid: dep_application_uid,
                version: dep.version,
            }));
            // If you couldn't resolve remote dependency, skip replacing it
            if (!zephyr_edge_contract_1.ZeUtils.isSuccessTuple(tuple)) {
                return null;
            }
            return tuple[1];
        });
        const resolution_results = await Promise.all(tasks);
        this.federated_dependencies = resolution_results.filter(is_zephyr_resolved_dependency);
        return this.federated_dependencies;
    }
    async start_new_build() {
        (0, logging_1.ze_log)('Starting new build');
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const ze = this;
        ze.build_start_time = Date.now();
        if ((await ze.build_id) && (await ze.snapshotId)) {
            (0, logging_1.ze_log)('Skip: creating new build because no assets was uploaded');
            return;
        }
        const application_uid = ze.application_uid;
        (0, logging_1.ze_log)('Initializing: loading of hash list');
        ze.hash_list = (0, distributed_hash_control_1.get_hash_list)(application_uid);
        ze.hash_list
            .then((hash_set) => (0, logging_1.ze_log)(`Loaded: hash list with ${hash_set.hash_set.size} entries`))
            .catch((err) => (0, logging_1.ze_log)(`Failed to get hash list: ${err}`));
        (0, logging_1.ze_log)('Initializing: loading of build id');
        ze.build_id = (0, get_build_id_1.getBuildId)(application_uid);
        ze.build_id
            .then((buildId) => (0, logging_1.ze_log)(`Loaded build id "${buildId}"`))
            .catch((err) => (0, logging_1.ze_log)(`Failed to get build id: ${err}`));
        if (!ze.logger) {
            (0, logging_1.ze_log)('Initializing: logger');
            let resolve;
            ze.logger = new Promise((r) => (resolve = r));
            // internally logger will try to load app_config
            Promise.all([ze.application_configuration, ze.build_id]).then((record) => {
                const buildId = record[1];
                (0, logging_1.ze_log)('Initialized: application configuration, build id and hash list');
                resolve((0, ze_log_event_1.logger)({ application_uid, buildId, git: ze.gitProperties.git }));
            });
        }
        // snapshotId is a flat version of application_uid and build_id
        ze.snapshotId = Promise.all([ze.application_configuration, ze.build_id]).then(async (record) => (0, zephyr_edge_contract_1.flatCreateSnapshotId)(Object.assign(Object.assign({}, ze.applicationProperties), { buildId: record[1], username: record[0].username })));
    }
    async build_finished() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const zephyr_engine = this;
        const logger = await zephyr_engine.logger;
        const zeStart = zephyr_engine.build_start_time;
        const versionUrl = zephyr_engine.version_url;
        if (zeStart && versionUrl) {
            logger({
                level: 'trace',
                action: 'deploy:url',
                message: `Deployed to ${(0, picocolor_1.cyanBright)('Zephyr')}'s edge in ${(0, picocolor_1.yellow)(`${Date.now() - zeStart}`)}ms.\n\n${(0, picocolor_1.cyanBright)(versionUrl)}`,
            });
        }
        this.build_id = null;
        this.snapshotId = null;
        this.version_url = null;
        this.build_start_time = null;
    }
    async upload_assets(props) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const zephyr_engine = this;
        (0, logging_1.ze_log)('Initializing: upload assets');
        const { assetsMap, buildStats, mfConfig } = props;
        if (!zephyr_engine.application_uid || !zephyr_engine.build_id) {
            (0, logging_1.ze_log)('Failed to upload assets: missing application_uid or build_id');
            return;
        }
        await zephyr_engine.build_id;
        const hash_set = await zephyr_engine.hash_list;
        const missingAssets = (0, get_missing_assets_1.get_missing_assets)({
            assetsMap,
            hash_set: hash_set !== null && hash_set !== void 0 ? hash_set : { hash_set: new Set() },
        });
        // upload data
        const snapshot = await (0, ze_build_snapshot_1.createSnapshot)(zephyr_engine, {
            assets: assetsMap,
            mfConfig,
        });
        const upload_options = {
            snapshot,
            getDashData: () => buildStats,
            assets: {
                assetsMap,
                missingAssets,
            },
        };
        // upload
        const platform = (await zephyr_engine.application_configuration).PLATFORM;
        const strategy = (0, get_upload_strategy_1.getUploadStrategy)(platform);
        zephyr_engine.version_url = await strategy(zephyr_engine, upload_options);
        if (isCI) {
            const application_uid = zephyr_engine.application_uid;
            await (0, app_deploy_result_cache_1.setAppDeployResult)(application_uid, { urls: [zephyr_engine.version_url] });
        }
        await this.build_finished();
    }
}
exports.ZephyrEngine = ZephyrEngine;
function mut_zephyr_app_uid(ze) {
    ze.applicationProperties = {
        org: ze.gitProperties.app.org,
        project: ze.gitProperties.app.project,
        name: ze.npmProperties.name,
        version: ze.npmProperties.version,
    };
    ze.application_uid = (0, zephyr_edge_contract_1.createApplicationUid)(ze.applicationProperties);
}
//# sourceMappingURL=index.js.map
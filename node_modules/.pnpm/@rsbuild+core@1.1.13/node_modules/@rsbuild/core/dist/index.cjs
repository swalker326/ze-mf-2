let __rslib_import_meta_url__ = 'undefined' == typeof document ? new (require('url'.replace('', ''))).URL('file:' + __filename).href : document.currentScript && document.currentScript.src || new URL('main.js', document.baseURI).href;
var __webpack_modules__ = {
    "../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js": function(module) {
        "use strict";
        var isMergeableObject = function(value) {
            return function(value) {
                return !!value && 'object' == typeof value;
            }(value) && !function(value) {
                var stringValue = Object.prototype.toString.call(value);
                return '[object RegExp]' === stringValue || '[object Date]' === stringValue || function(value) {
                    return value.$$typeof === REACT_ELEMENT_TYPE;
                }(value);
            }(value);
        }, REACT_ELEMENT_TYPE = 'function' == typeof Symbol && Symbol.for ? Symbol.for('react.element') : 0xeac7;
        function cloneUnlessOtherwiseSpecified(value, options) {
            return !1 !== options.clone && options.isMergeableObject(value) ? deepmerge(Array.isArray(value) ? [] : {}, value, options) : value;
        }
        function defaultArrayMerge(target, source, options) {
            return target.concat(source).map(function(element) {
                return cloneUnlessOtherwiseSpecified(element, options);
            });
        }
        function getKeys(target) {
            var target1;
            return Object.keys(target).concat((target1 = target, Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target1).filter(function(symbol) {
                return Object.propertyIsEnumerable.call(target1, symbol);
            }) : []));
        }
        function propertyIsOnObject(object, property) {
            try {
                return property in object;
            } catch (_) {
                return !1;
            }
        }
        function deepmerge(target, source, options) {
            (options = options || {}).arrayMerge = options.arrayMerge || defaultArrayMerge, options.isMergeableObject = options.isMergeableObject || isMergeableObject, options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
            var target1, source1, options1, destination, sourceIsArray = Array.isArray(source), targetIsArray = Array.isArray(target);
            if (sourceIsArray !== targetIsArray) return cloneUnlessOtherwiseSpecified(source, options);
            if (sourceIsArray) return options.arrayMerge(target, source, options);
            return target1 = target, source1 = source, destination = {}, (options1 = options).isMergeableObject(target1) && getKeys(target1).forEach(function(key) {
                destination[key] = cloneUnlessOtherwiseSpecified(target1[key], options1);
            }), getKeys(source1).forEach(function(key) {
                var target, key1;
                if (!propertyIsOnObject(target = target1, key1 = key) || !!(Object.hasOwnProperty.call(target, key1) && Object.propertyIsEnumerable.call(target, key1))) propertyIsOnObject(target1, key) && options1.isMergeableObject(source1[key]) ? destination[key] = (function(key, options) {
                    if (!options.customMerge) return deepmerge;
                    var customMerge = options.customMerge(key);
                    return 'function' == typeof customMerge ? customMerge : deepmerge;
                })(key, options1)(target1[key], source1[key], options1) : destination[key] = cloneUnlessOtherwiseSpecified(source1[key], options1);
            }), destination;
        }
        deepmerge.all = function(array, options) {
            if (!Array.isArray(array)) throw Error('first argument should be an array');
            return array.reduce(function(prev, next) {
                return deepmerge(prev, next, options);
            }, {});
        };
        module.exports = deepmerge;
    },
    "../../node_modules/.pnpm/dotenv-expand@11.0.7/node_modules/dotenv-expand/lib/main.js": function(module) {
        "use strict";
        let DOTENV_SUBSTITUTION_REGEX = /(\\)?(\$)(?!\()(\{?)([\w.]+)(?::?-((?:\$\{(?:\$\{(?:\$\{[^}]*\}|[^}])*}|[^}])*}|[^}])+))?(\}?)/gi;
        function interpolate(value, processEnv, parsed) {
            return value.replace(DOTENV_SUBSTITUTION_REGEX, (match, escaped, dollarSign, openBrace, key, defaultValue, closeBrace)=>{
                if ('\\' === escaped) return match.slice(1);
                if (processEnv[key]) return processEnv[key] === parsed[key] ? processEnv[key] : interpolate(processEnv[key], processEnv, parsed);
                if (parsed[key] && parsed[key] !== value) return interpolate(parsed[key], processEnv, parsed);
                if (defaultValue) return defaultValue.startsWith('$') ? interpolate(defaultValue, processEnv, parsed) : defaultValue;
                return '';
            });
        }
        module.exports.expand = function(options) {
            let processEnv = process.env;
            for(let key in options && null != options.processEnv && (processEnv = options.processEnv), options.parsed){
                let value = options.parsed[key];
                value = Object.prototype.hasOwnProperty.call(processEnv, key) ? processEnv[key] === options.parsed[key] ? interpolate(value, processEnv, options.parsed) : processEnv[key] : interpolate(value, processEnv, options.parsed), options.parsed[key] = value.replace(/\\\$/g, '$');
            }
            for(let processKey in options.parsed)processEnv[processKey] = options.parsed[processKey];
            return options;
        };
    },
    "../../node_modules/.pnpm/dotenv@16.4.7/node_modules/dotenv/lib/main.js": function(module, __unused_webpack_exports, __webpack_require__) {
        let fs = __webpack_require__("fs"), path = __webpack_require__("path"), os = __webpack_require__("os"), crypto = __webpack_require__("crypto"), version = __webpack_require__("../../node_modules/.pnpm/dotenv@16.4.7/node_modules/dotenv/package.json").version, LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
        function _debug(message) {
            console.log(`[dotenv@${version}][DEBUG] ${message}`);
        }
        function _dotenvKey(options) {
            return options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0 ? options.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : '';
        }
        function _vaultPath(options) {
            let possibleVaultPath = null;
            if (options && options.path && options.path.length > 0) {
                if (Array.isArray(options.path)) for (let filepath of options.path)fs.existsSync(filepath) && (possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`);
                else possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`;
            } else possibleVaultPath = path.resolve(process.cwd(), '.env.vault');
            return fs.existsSync(possibleVaultPath) ? possibleVaultPath : null;
        }
        function _resolveHome(envPath) {
            return '~' === envPath[0] ? path.join(os.homedir(), envPath.slice(1)) : envPath;
        }
        let DotenvModule = {
            configDotenv: function(options) {
                let lastError;
                let dotenvPath = path.resolve(process.cwd(), '.env'), encoding = 'utf8', debug = !!(options && options.debug);
                options && options.encoding ? encoding = options.encoding : debug && _debug('No encoding is specified. UTF-8 is used by default');
                let optionPaths = [
                    dotenvPath
                ];
                if (options && options.path) {
                    if (Array.isArray(options.path)) for (let filepath of (optionPaths = [], options.path))optionPaths.push(_resolveHome(filepath));
                    else optionPaths = [
                        _resolveHome(options.path)
                    ];
                }
                let parsedAll = {};
                for (let path of optionPaths)try {
                    let parsed = DotenvModule.parse(fs.readFileSync(path, {
                        encoding
                    }));
                    DotenvModule.populate(parsedAll, parsed, options);
                } catch (e) {
                    debug && _debug(`Failed to load ${path} ${e.message}`), lastError = e;
                }
                let processEnv = process.env;
                return (options && null != options.processEnv && (processEnv = options.processEnv), DotenvModule.populate(processEnv, parsedAll, options), lastError) ? {
                    parsed: parsedAll,
                    error: lastError
                } : {
                    parsed: parsedAll
                };
            },
            _configVault: function(options) {
                console.log(`[dotenv@${version}][INFO] Loading env from encrypted .env.vault`);
                let parsed = DotenvModule._parseVault(options), processEnv = process.env;
                return options && null != options.processEnv && (processEnv = options.processEnv), DotenvModule.populate(processEnv, parsed, options), {
                    parsed
                };
            },
            _parseVault: function(options) {
                let decrypted;
                let vaultPath = _vaultPath(options), result = DotenvModule.configDotenv({
                    path: vaultPath
                });
                if (!result.parsed) {
                    let err = Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
                    throw err.code = 'MISSING_DATA', err;
                }
                let keys = _dotenvKey(options).split(','), length = keys.length;
                for(let i = 0; i < length; i++)try {
                    let key = keys[i].trim(), attrs = function(result, dotenvKey) {
                        let uri;
                        try {
                            uri = new URL(dotenvKey);
                        } catch (error) {
                            if ('ERR_INVALID_URL' === error.code) {
                                let err = Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');
                                throw err.code = 'INVALID_DOTENV_KEY', err;
                            }
                            throw error;
                        }
                        let key = uri.password;
                        if (!key) {
                            let err = Error('INVALID_DOTENV_KEY: Missing key part');
                            throw err.code = 'INVALID_DOTENV_KEY', err;
                        }
                        let environment = uri.searchParams.get('environment');
                        if (!environment) {
                            let err = Error('INVALID_DOTENV_KEY: Missing environment part');
                            throw err.code = 'INVALID_DOTENV_KEY', err;
                        }
                        let environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`, ciphertext = result.parsed[environmentKey];
                        if (!ciphertext) {
                            let err = Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
                            throw err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT', err;
                        }
                        return {
                            ciphertext,
                            key
                        };
                    }(result, key);
                    decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
                    break;
                } catch (error) {
                    if (i + 1 >= length) throw error;
                }
                return DotenvModule.parse(decrypted);
            },
            config: function(options) {
                if (0 === _dotenvKey(options).length) return DotenvModule.configDotenv(options);
                let vaultPath = _vaultPath(options);
                if (!vaultPath) {
                    var message;
                    return message = `You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`, console.log(`[dotenv@${version}][WARN] ${message}`), DotenvModule.configDotenv(options);
                }
                return DotenvModule._configVault(options);
            },
            decrypt: function(encrypted, keyStr) {
                let key = Buffer.from(keyStr.slice(-64), 'hex'), ciphertext = Buffer.from(encrypted, 'base64'), nonce = ciphertext.subarray(0, 12), authTag = ciphertext.subarray(-16);
                ciphertext = ciphertext.subarray(12, -16);
                try {
                    let aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);
                    return aesgcm.setAuthTag(authTag), `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
                } catch (error) {
                    let isRange = error instanceof RangeError, invalidKeyLength = 'Invalid key length' === error.message, decryptionFailed = 'Unsupported state or unable to authenticate data' === error.message;
                    if (isRange || invalidKeyLength) {
                        let err = Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');
                        throw err.code = 'INVALID_DOTENV_KEY', err;
                    }
                    if (decryptionFailed) {
                        let err = Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');
                        throw err.code = 'DECRYPTION_FAILED', err;
                    } else throw error;
                }
            },
            parse: function(src) {
                let match;
                let obj = {}, lines = src.toString();
                for(lines = lines.replace(/\r\n?/mg, '\n'); null != (match = LINE.exec(lines));){
                    let key = match[1], value = match[2] || '', maybeQuote = (value = value.trim())[0];
                    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2'), '"' === maybeQuote && (value = (value = value.replace(/\\n/g, '\n')).replace(/\\r/g, '\r')), obj[key] = value;
                }
                return obj;
            },
            populate: function(processEnv, parsed, options = {}) {
                let debug = !!(options && options.debug), override = !!(options && options.override);
                if ('object' != typeof parsed) {
                    let err = Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');
                    throw err.code = 'OBJECT_REQUIRED', err;
                }
                for (let key of Object.keys(parsed))Object.prototype.hasOwnProperty.call(processEnv, key) ? (!0 === override && (processEnv[key] = parsed[key]), debug && (!0 === override ? _debug(`"${key}" is already defined and WAS overwritten`) : _debug(`"${key}" is already defined and was NOT overwritten`))) : processEnv[key] = parsed[key];
            }
        };
        module.exports.configDotenv = DotenvModule.configDotenv, module.exports._configVault = DotenvModule._configVault, module.exports._parseVault = DotenvModule._parseVault, module.exports.config = DotenvModule.config, module.exports.decrypt = DotenvModule.decrypt, module.exports.parse = DotenvModule.parse, module.exports.populate = DotenvModule.populate, module.exports = DotenvModule;
    },
    crypto: function(module) {
        "use strict";
        module.exports = require("crypto");
    },
    fs: function(module) {
        "use strict";
        module.exports = require("fs");
    },
    "node:child_process": function(module) {
        "use strict";
        module.exports = require("node:child_process");
    },
    "node:events": function(module) {
        "use strict";
        module.exports = require("node:events");
    },
    "node:fs": function(module) {
        "use strict";
        module.exports = require("node:fs");
    },
    "node:path": function(module) {
        "use strict";
        module.exports = require("node:path");
    },
    "node:process": function(module) {
        "use strict";
        module.exports = require("node:process");
    },
    os: function(module) {
        "use strict";
        module.exports = require("os");
    },
    path: function(module) {
        "use strict";
        module.exports = require("path");
    },
    "../../compiled/chokidar/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/chokidar/index.js");
    },
    "../../compiled/connect-history-api-fallback/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/connect-history-api-fallback/index.js");
    },
    "../../compiled/connect/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/connect/index.js");
    },
    "../../compiled/cors/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/cors/index.js");
    },
    "../../compiled/http-proxy-middleware/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/http-proxy-middleware/index.js");
    },
    "../compiled/jiti/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/jiti/index.js");
    },
    "../../compiled/launch-editor-middleware/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/launch-editor-middleware/index.js");
    },
    "../../compiled/on-finished/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/on-finished/index.js");
    },
    "../../compiled/open/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/open/index.js");
    },
    "../../compiled/postcss-load-config/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/postcss-load-config/index.js");
    },
    "../../compiled/rsbuild-dev-middleware/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/rsbuild-dev-middleware/index.js");
    },
    "../../compiled/rspack-manifest-plugin/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/rspack-manifest-plugin/index.js");
    },
    "../../compiled/sirv/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/sirv/index.js");
    },
    "../../compiled/tinyglobby/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/tinyglobby/index.js");
    },
    "../../compiled/webpack-bundle-analyzer/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/webpack-bundle-analyzer/index.js");
    },
    "../../compiled/webpack-merge/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/webpack-merge/index.js");
    },
    "../../compiled/ws/index.js": function(module) {
        "use strict";
        module.exports = import("../compiled/ws/index.js");
    },
    "node:http": function(module) {
        "use strict";
        module.exports = import("node:http");
    },
    "node:http2": function(module) {
        "use strict";
        module.exports = import("node:http2");
    },
    "node:https": function(module) {
        "use strict";
        module.exports = import("node:https");
    },
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        let { Argument } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/argument.js"), { Command } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/command.js"), { CommanderError, InvalidArgumentError } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/error.js"), { Help } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/help.js"), { Option } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/option.js");
        exports1.program = new Command(), exports1.createCommand = (name)=>new Command(name), exports1.createOption = (flags, description)=>new Option(flags, description), exports1.createArgument = (name, description)=>new Argument(name, description), exports1.Command = Command, exports1.Option = Option, exports1.Argument = Argument, exports1.Help = Help, exports1.CommanderError = CommanderError, exports1.InvalidArgumentError = InvalidArgumentError, exports1.InvalidOptionArgumentError = InvalidArgumentError;
    },
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/argument.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        let { InvalidArgumentError } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/error.js");
        exports1.Argument = class Argument {
            constructor(name, description){
                switch(this.description = description || '', this.variadic = !1, this.parseArg = void 0, this.defaultValue = void 0, this.defaultValueDescription = void 0, this.argChoices = void 0, name[0]){
                    case '<':
                        this.required = !0, this._name = name.slice(1, -1);
                        break;
                    case '[':
                        this.required = !1, this._name = name.slice(1, -1);
                        break;
                    default:
                        this.required = !0, this._name = name;
                }
                this._name.length > 3 && '...' === this._name.slice(-3) && (this.variadic = !0, this._name = this._name.slice(0, -3));
            }
            name() {
                return this._name;
            }
            _concatValue(value, previous) {
                return previous !== this.defaultValue && Array.isArray(previous) ? previous.concat(value) : [
                    value
                ];
            }
            default(value, description) {
                return this.defaultValue = value, this.defaultValueDescription = description, this;
            }
            argParser(fn) {
                return this.parseArg = fn, this;
            }
            choices(values) {
                return this.argChoices = values.slice(), this.parseArg = (arg, previous)=>{
                    if (!this.argChoices.includes(arg)) throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);
                    return this.variadic ? this._concatValue(arg, previous) : arg;
                }, this;
            }
            argRequired() {
                return this.required = !0, this;
            }
            argOptional() {
                return this.required = !1, this;
            }
        }, exports1.humanReadableArgName = function(arg) {
            let nameOutput = arg.name() + (!0 === arg.variadic ? '...' : '');
            return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
        };
    },
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/command.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        let EventEmitter = __webpack_require__("node:events").EventEmitter, childProcess = __webpack_require__("node:child_process"), path = __webpack_require__("node:path"), fs = __webpack_require__("node:fs"), process1 = __webpack_require__("node:process"), { Argument, humanReadableArgName } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/argument.js"), { CommanderError } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/error.js"), { Help } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/help.js"), { Option, DualOptions } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/option.js"), { suggestSimilar } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/suggestSimilar.js");
        class Command extends EventEmitter {
            constructor(name){
                super(), this.commands = [], this.options = [], this.parent = null, this._allowUnknownOption = !1, this._allowExcessArguments = !0, this.registeredArguments = [], this._args = this.registeredArguments, this.args = [], this.rawArgs = [], this.processedArgs = [], this._scriptPath = null, this._name = name || '', this._optionValues = {}, this._optionValueSources = {}, this._storeOptionsAsProperties = !1, this._actionHandler = null, this._executableHandler = !1, this._executableFile = null, this._executableDir = null, this._defaultCommandName = null, this._exitCallback = null, this._aliases = [], this._combineFlagAndOptionalValue = !0, this._description = '', this._summary = '', this._argsDescription = void 0, this._enablePositionalOptions = !1, this._passThroughOptions = !1, this._lifeCycleHooks = {}, this._showHelpAfterError = !1, this._showSuggestionAfterError = !0, this._outputConfiguration = {
                    writeOut: (str)=>process1.stdout.write(str),
                    writeErr: (str)=>process1.stderr.write(str),
                    getOutHelpWidth: ()=>process1.stdout.isTTY ? process1.stdout.columns : void 0,
                    getErrHelpWidth: ()=>process1.stderr.isTTY ? process1.stderr.columns : void 0,
                    outputError: (str, write)=>write(str)
                }, this._hidden = !1, this._helpOption = void 0, this._addImplicitHelpCommand = void 0, this._helpCommand = void 0, this._helpConfiguration = {};
            }
            copyInheritedSettings(sourceCommand) {
                return this._outputConfiguration = sourceCommand._outputConfiguration, this._helpOption = sourceCommand._helpOption, this._helpCommand = sourceCommand._helpCommand, this._helpConfiguration = sourceCommand._helpConfiguration, this._exitCallback = sourceCommand._exitCallback, this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties, this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue, this._allowExcessArguments = sourceCommand._allowExcessArguments, this._enablePositionalOptions = sourceCommand._enablePositionalOptions, this._showHelpAfterError = sourceCommand._showHelpAfterError, this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError, this;
            }
            _getCommandAndAncestors() {
                let result = [];
                for(let command = this; command; command = command.parent)result.push(command);
                return result;
            }
            command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
                let desc = actionOptsOrExecDesc, opts = execOpts;
                'object' == typeof desc && null !== desc && (opts = desc, desc = null), opts = opts || {};
                let [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/), cmd = this.createCommand(name);
                return (desc && (cmd.description(desc), cmd._executableHandler = !0), opts.isDefault && (this._defaultCommandName = cmd._name), cmd._hidden = !!(opts.noHelp || opts.hidden), cmd._executableFile = opts.executableFile || null, args && cmd.arguments(args), this._registerCommand(cmd), cmd.parent = this, cmd.copyInheritedSettings(this), desc) ? this : cmd;
            }
            createCommand(name) {
                return new Command(name);
            }
            createHelp() {
                return Object.assign(new Help(), this.configureHelp());
            }
            configureHelp(configuration) {
                return void 0 === configuration ? this._helpConfiguration : (this._helpConfiguration = configuration, this);
            }
            configureOutput(configuration) {
                return void 0 === configuration ? this._outputConfiguration : (Object.assign(this._outputConfiguration, configuration), this);
            }
            showHelpAfterError(displayHelp = !0) {
                return 'string' != typeof displayHelp && (displayHelp = !!displayHelp), this._showHelpAfterError = displayHelp, this;
            }
            showSuggestionAfterError(displaySuggestion = !0) {
                return this._showSuggestionAfterError = !!displaySuggestion, this;
            }
            addCommand(cmd, opts) {
                if (!cmd._name) throw Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
                return (opts = opts || {}).isDefault && (this._defaultCommandName = cmd._name), (opts.noHelp || opts.hidden) && (cmd._hidden = !0), this._registerCommand(cmd), cmd.parent = this, cmd._checkForBrokenPassThrough(), this;
            }
            createArgument(name, description) {
                return new Argument(name, description);
            }
            argument(name, description, fn, defaultValue) {
                let argument = this.createArgument(name, description);
                return 'function' == typeof fn ? argument.default(defaultValue).argParser(fn) : argument.default(fn), this.addArgument(argument), this;
            }
            arguments(names) {
                return names.trim().split(/ +/).forEach((detail)=>{
                    this.argument(detail);
                }), this;
            }
            addArgument(argument) {
                let previousArgument = this.registeredArguments.slice(-1)[0];
                if (previousArgument && previousArgument.variadic) throw Error(`only the last argument can be variadic '${previousArgument.name()}'`);
                if (argument.required && void 0 !== argument.defaultValue && void 0 === argument.parseArg) throw Error(`a default value for a required argument is never used: '${argument.name()}'`);
                return this.registeredArguments.push(argument), this;
            }
            helpCommand(enableOrNameAndArgs, description) {
                if ('boolean' == typeof enableOrNameAndArgs) return this._addImplicitHelpCommand = enableOrNameAndArgs, this;
                let [, helpName, helpArgs] = (enableOrNameAndArgs = enableOrNameAndArgs ?? 'help [command]').match(/([^ ]+) *(.*)/), helpDescription = description ?? 'display help for command', helpCommand = this.createCommand(helpName);
                return helpCommand.helpOption(!1), helpArgs && helpCommand.arguments(helpArgs), helpDescription && helpCommand.description(helpDescription), this._addImplicitHelpCommand = !0, this._helpCommand = helpCommand, this;
            }
            addHelpCommand(helpCommand, deprecatedDescription) {
                return 'object' != typeof helpCommand ? (this.helpCommand(helpCommand, deprecatedDescription), this) : (this._addImplicitHelpCommand = !0, this._helpCommand = helpCommand, this);
            }
            _getHelpCommand() {
                return this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand('help')) ? (void 0 === this._helpCommand && this.helpCommand(void 0, void 0), this._helpCommand) : null;
            }
            hook(event, listener) {
                let allowedValues = [
                    'preSubcommand',
                    'preAction',
                    'postAction'
                ];
                if (!allowedValues.includes(event)) throw Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
                return this._lifeCycleHooks[event] ? this._lifeCycleHooks[event].push(listener) : this._lifeCycleHooks[event] = [
                    listener
                ], this;
            }
            exitOverride(fn) {
                return fn ? this._exitCallback = fn : this._exitCallback = (err)=>{
                    if ('commander.executeSubCommandAsync' !== err.code) throw err;
                }, this;
            }
            _exit(exitCode, code, message) {
                this._exitCallback && this._exitCallback(new CommanderError(exitCode, code, message)), process1.exit(exitCode);
            }
            action(fn) {
                return this._actionHandler = (args)=>{
                    let expectedArgsCount = this.registeredArguments.length, actionArgs = args.slice(0, expectedArgsCount);
                    return this._storeOptionsAsProperties ? actionArgs[expectedArgsCount] = this : actionArgs[expectedArgsCount] = this.opts(), actionArgs.push(this), fn.apply(this, actionArgs);
                }, this;
            }
            createOption(flags, description) {
                return new Option(flags, description);
            }
            _callParseArg(target, value, previous, invalidArgumentMessage) {
                try {
                    return target.parseArg(value, previous);
                } catch (err) {
                    if ('commander.invalidArgument' === err.code) {
                        let message = `${invalidArgumentMessage} ${err.message}`;
                        this.error(message, {
                            exitCode: err.exitCode,
                            code: err.code
                        });
                    }
                    throw err;
                }
            }
            _registerOption(option) {
                let matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
                if (matchingOption) {
                    let matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
                    throw Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
                }
                this.options.push(option);
            }
            _registerCommand(command) {
                let knownBy = (cmd)=>[
                        cmd.name()
                    ].concat(cmd.aliases()), alreadyUsed = knownBy(command).find((name)=>this._findCommand(name));
                if (alreadyUsed) {
                    let existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|'), newCmd = knownBy(command).join('|');
                    throw Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
                }
                this.commands.push(command);
            }
            addOption(option) {
                this._registerOption(option);
                let oname = option.name(), name = option.attributeName();
                if (option.negate) {
                    let positiveLongFlag = option.long.replace(/^--no-/, '--');
                    !this._findOption(positiveLongFlag) && this.setOptionValueWithSource(name, void 0 === option.defaultValue || option.defaultValue, 'default');
                } else void 0 !== option.defaultValue && this.setOptionValueWithSource(name, option.defaultValue, 'default');
                let handleOptionValue = (val, invalidValueMessage, valueSource)=>{
                    null == val && void 0 !== option.presetArg && (val = option.presetArg);
                    let oldValue = this.getOptionValue(name);
                    null !== val && option.parseArg ? val = this._callParseArg(option, val, oldValue, invalidValueMessage) : null !== val && option.variadic && (val = option._concatValue(val, oldValue)), null == val && (val = !option.negate && (!!option.isBoolean() || !!option.optional || '')), this.setOptionValueWithSource(name, val, valueSource);
                };
                return this.on('option:' + oname, (val)=>{
                    let invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
                    handleOptionValue(val, invalidValueMessage, 'cli');
                }), option.envVar && this.on('optionEnv:' + oname, (val)=>{
                    let invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
                    handleOptionValue(val, invalidValueMessage, 'env');
                }), this;
            }
            _optionEx(config, flags, description, fn, defaultValue) {
                if ('object' == typeof flags && flags instanceof Option) throw Error('To add an Option object use addOption() instead of option() or requiredOption()');
                let option = this.createOption(flags, description);
                if (option.makeOptionMandatory(!!config.mandatory), 'function' == typeof fn) option.default(defaultValue).argParser(fn);
                else if (fn instanceof RegExp) {
                    let regex = fn;
                    fn = (val, def)=>{
                        let m = regex.exec(val);
                        return m ? m[0] : def;
                    }, option.default(defaultValue).argParser(fn);
                } else option.default(fn);
                return this.addOption(option);
            }
            option(flags, description, parseArg, defaultValue) {
                return this._optionEx({}, flags, description, parseArg, defaultValue);
            }
            requiredOption(flags, description, parseArg, defaultValue) {
                return this._optionEx({
                    mandatory: !0
                }, flags, description, parseArg, defaultValue);
            }
            combineFlagAndOptionalValue(combine = !0) {
                return this._combineFlagAndOptionalValue = !!combine, this;
            }
            allowUnknownOption(allowUnknown = !0) {
                return this._allowUnknownOption = !!allowUnknown, this;
            }
            allowExcessArguments(allowExcess = !0) {
                return this._allowExcessArguments = !!allowExcess, this;
            }
            enablePositionalOptions(positional = !0) {
                return this._enablePositionalOptions = !!positional, this;
            }
            passThroughOptions(passThrough = !0) {
                return this._passThroughOptions = !!passThrough, this._checkForBrokenPassThrough(), this;
            }
            _checkForBrokenPassThrough() {
                if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) throw Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);
            }
            storeOptionsAsProperties(storeAsProperties = !0) {
                if (this.options.length) throw Error('call .storeOptionsAsProperties() before adding options');
                if (Object.keys(this._optionValues).length) throw Error('call .storeOptionsAsProperties() before setting option values');
                return this._storeOptionsAsProperties = !!storeAsProperties, this;
            }
            getOptionValue(key) {
                return this._storeOptionsAsProperties ? this[key] : this._optionValues[key];
            }
            setOptionValue(key, value) {
                return this.setOptionValueWithSource(key, value, void 0);
            }
            setOptionValueWithSource(key, value, source) {
                return this._storeOptionsAsProperties ? this[key] = value : this._optionValues[key] = value, this._optionValueSources[key] = source, this;
            }
            getOptionValueSource(key) {
                return this._optionValueSources[key];
            }
            getOptionValueSourceWithGlobals(key) {
                let source;
                return this._getCommandAndAncestors().forEach((cmd)=>{
                    void 0 !== cmd.getOptionValueSource(key) && (source = cmd.getOptionValueSource(key));
                }), source;
            }
            _prepareUserArgs(argv, parseOptions) {
                let userArgs;
                if (void 0 !== argv && !Array.isArray(argv)) throw Error('first parameter to parse must be array or undefined');
                if (parseOptions = parseOptions || {}, void 0 === argv && void 0 === parseOptions.from) {
                    process1.versions?.electron && (parseOptions.from = 'electron');
                    let execArgv = process1.execArgv ?? [];
                    (execArgv.includes('-e') || execArgv.includes('--eval') || execArgv.includes('-p') || execArgv.includes('--print')) && (parseOptions.from = 'eval');
                }
                switch(void 0 === argv && (argv = process1.argv), this.rawArgs = argv.slice(), parseOptions.from){
                    case void 0:
                    case 'node':
                        this._scriptPath = argv[1], userArgs = argv.slice(2);
                        break;
                    case 'electron':
                        process1.defaultApp ? (this._scriptPath = argv[1], userArgs = argv.slice(2)) : userArgs = argv.slice(1);
                        break;
                    case 'user':
                        userArgs = argv.slice(0);
                        break;
                    case 'eval':
                        userArgs = argv.slice(1);
                        break;
                    default:
                        throw Error(`unexpected parse option { from: '${parseOptions.from}' }`);
                }
                return !this._name && this._scriptPath && this.nameFromFilename(this._scriptPath), this._name = this._name || 'program', userArgs;
            }
            parse(argv, parseOptions) {
                let userArgs = this._prepareUserArgs(argv, parseOptions);
                return this._parseCommand([], userArgs), this;
            }
            async parseAsync(argv, parseOptions) {
                let userArgs = this._prepareUserArgs(argv, parseOptions);
                return await this._parseCommand([], userArgs), this;
            }
            _executeSubCommand(subcommand, args) {
                let proc;
                args = args.slice();
                let launchWithNode = !1, sourceExt = [
                    '.js',
                    '.ts',
                    '.tsx',
                    '.mjs',
                    '.cjs'
                ];
                function findFile(baseDir, baseName) {
                    let localBin = path.resolve(baseDir, baseName);
                    if (fs.existsSync(localBin)) return localBin;
                    if (sourceExt.includes(path.extname(baseName))) return;
                    let foundExt = sourceExt.find((ext)=>fs.existsSync(`${localBin}${ext}`));
                    if (foundExt) return `${localBin}${foundExt}`;
                }
                this._checkForMissingMandatoryOptions(), this._checkForConflictingOptions();
                let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`, executableDir = this._executableDir || '';
                if (this._scriptPath) {
                    let resolvedScriptPath;
                    try {
                        resolvedScriptPath = fs.realpathSync(this._scriptPath);
                    } catch (err) {
                        resolvedScriptPath = this._scriptPath;
                    }
                    executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
                }
                if (executableDir) {
                    let localFile = findFile(executableDir, executableFile);
                    if (!localFile && !subcommand._executableFile && this._scriptPath) {
                        let legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
                        legacyName !== this._name && (localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`));
                    }
                    executableFile = localFile || executableFile;
                }
                launchWithNode = sourceExt.includes(path.extname(executableFile)), 'win32' !== process1.platform ? launchWithNode ? (args.unshift(executableFile), args = incrementNodeInspectorPort(process1.execArgv).concat(args), proc = childProcess.spawn(process1.argv[0], args, {
                    stdio: 'inherit'
                })) : proc = childProcess.spawn(executableFile, args, {
                    stdio: 'inherit'
                }) : (args.unshift(executableFile), args = incrementNodeInspectorPort(process1.execArgv).concat(args), proc = childProcess.spawn(process1.execPath, args, {
                    stdio: 'inherit'
                })), !proc.killed && [
                    'SIGUSR1',
                    'SIGUSR2',
                    'SIGTERM',
                    'SIGINT',
                    'SIGHUP'
                ].forEach((signal)=>{
                    process1.on(signal, ()=>{
                        !1 === proc.killed && null === proc.exitCode && proc.kill(signal);
                    });
                });
                let exitCallback = this._exitCallback;
                proc.on('close', (code)=>{
                    code = code ?? 1, exitCallback ? exitCallback(new CommanderError(code, 'commander.executeSubCommandAsync', '(close)')) : process1.exit(code);
                }), proc.on('error', (err)=>{
                    if ('ENOENT' === err.code) {
                        let executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
                        throw Error(`'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`);
                    }
                    if ('EACCES' === err.code) throw Error(`'${executableFile}' not executable`);
                    if (exitCallback) {
                        let wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
                        wrappedError.nestedError = err, exitCallback(wrappedError);
                    } else process1.exit(1);
                }), this.runningCommand = proc;
            }
            _dispatchSubcommand(commandName, operands, unknown) {
                let promiseChain;
                let subCommand = this._findCommand(commandName);
                return !subCommand && this.help({
                    error: !0
                }), promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, 'preSubcommand'), promiseChain = this._chainOrCall(promiseChain, ()=>{
                    if (!subCommand._executableHandler) return subCommand._parseCommand(operands, unknown);
                    this._executeSubCommand(subCommand, operands.concat(unknown));
                });
            }
            _dispatchHelpCommand(subcommandName) {
                !subcommandName && this.help();
                let subCommand = this._findCommand(subcommandName);
                return subCommand && !subCommand._executableHandler && subCommand.help(), this._dispatchSubcommand(subcommandName, [], [
                    this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'
                ]);
            }
            _checkNumberOfArguments() {
                if (this.registeredArguments.forEach((arg, i)=>{
                    arg.required && null == this.args[i] && this.missingArgument(arg.name());
                }), !(this.registeredArguments.length > 0) || !this.registeredArguments[this.registeredArguments.length - 1].variadic) this.args.length > this.registeredArguments.length && this._excessArguments(this.args);
            }
            _processArguments() {
                let myParseArg = (argument, value, previous)=>{
                    let parsedValue = value;
                    if (null !== value && argument.parseArg) {
                        let invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
                        parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
                    }
                    return parsedValue;
                };
                this._checkNumberOfArguments();
                let processedArgs = [];
                this.registeredArguments.forEach((declaredArg, index)=>{
                    let value = declaredArg.defaultValue;
                    declaredArg.variadic ? index < this.args.length ? (value = this.args.slice(index), declaredArg.parseArg && (value = value.reduce((processed, v)=>myParseArg(declaredArg, v, processed), declaredArg.defaultValue))) : void 0 === value && (value = []) : index < this.args.length && (value = this.args[index], declaredArg.parseArg && (value = myParseArg(declaredArg, value, declaredArg.defaultValue))), processedArgs[index] = value;
                }), this.processedArgs = processedArgs;
            }
            _chainOrCall(promise, fn) {
                return promise && promise.then && 'function' == typeof promise.then ? promise.then(()=>fn()) : fn();
            }
            _chainOrCallHooks(promise, event) {
                let result = promise, hooks = [];
                return this._getCommandAndAncestors().reverse().filter((cmd)=>void 0 !== cmd._lifeCycleHooks[event]).forEach((hookedCommand)=>{
                    hookedCommand._lifeCycleHooks[event].forEach((callback)=>{
                        hooks.push({
                            hookedCommand,
                            callback
                        });
                    });
                }), 'postAction' === event && hooks.reverse(), hooks.forEach((hookDetail)=>{
                    result = this._chainOrCall(result, ()=>hookDetail.callback(hookDetail.hookedCommand, this));
                }), result;
            }
            _chainOrCallSubCommandHook(promise, subCommand, event) {
                let result = promise;
                return void 0 !== this._lifeCycleHooks[event] && this._lifeCycleHooks[event].forEach((hook)=>{
                    result = this._chainOrCall(result, ()=>hook(this, subCommand));
                }), result;
            }
            _parseCommand(operands, unknown) {
                let parsed = this.parseOptions(unknown);
                if (this._parseOptionsEnv(), this._parseOptionsImplied(), operands = operands.concat(parsed.operands), unknown = parsed.unknown, this.args = operands.concat(unknown), operands && this._findCommand(operands[0])) return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
                if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) return this._dispatchHelpCommand(operands[1]);
                if (this._defaultCommandName) return this._outputHelpIfRequested(unknown), this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
                this.commands.length && 0 === this.args.length && !this._actionHandler && !this._defaultCommandName && this.help({
                    error: !0
                }), this._outputHelpIfRequested(parsed.unknown), this._checkForMissingMandatoryOptions(), this._checkForConflictingOptions();
                let checkForUnknownOptions = ()=>{
                    parsed.unknown.length > 0 && this.unknownOption(parsed.unknown[0]);
                }, commandEvent = `command:${this.name()}`;
                if (this._actionHandler) {
                    let promiseChain;
                    return checkForUnknownOptions(), this._processArguments(), promiseChain = this._chainOrCallHooks(promiseChain, 'preAction'), promiseChain = this._chainOrCall(promiseChain, ()=>this._actionHandler(this.processedArgs)), this.parent && (promiseChain = this._chainOrCall(promiseChain, ()=>{
                        this.parent.emit(commandEvent, operands, unknown);
                    })), promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
                }
                if (this.parent && this.parent.listenerCount(commandEvent)) checkForUnknownOptions(), this._processArguments(), this.parent.emit(commandEvent, operands, unknown);
                else if (operands.length) {
                    if (this._findCommand('*')) return this._dispatchSubcommand('*', operands, unknown);
                    this.listenerCount('command:*') ? this.emit('command:*', operands, unknown) : this.commands.length ? this.unknownCommand() : (checkForUnknownOptions(), this._processArguments());
                } else this.commands.length ? (checkForUnknownOptions(), this.help({
                    error: !0
                })) : (checkForUnknownOptions(), this._processArguments());
            }
            _findCommand(name) {
                if (name) return this.commands.find((cmd)=>cmd._name === name || cmd._aliases.includes(name));
            }
            _findOption(arg) {
                return this.options.find((option)=>option.is(arg));
            }
            _checkForMissingMandatoryOptions() {
                this._getCommandAndAncestors().forEach((cmd)=>{
                    cmd.options.forEach((anOption)=>{
                        anOption.mandatory && void 0 === cmd.getOptionValue(anOption.attributeName()) && cmd.missingMandatoryOptionValue(anOption);
                    });
                });
            }
            _checkForConflictingLocalOptions() {
                let definedNonDefaultOptions = this.options.filter((option)=>{
                    let optionKey = option.attributeName();
                    return void 0 !== this.getOptionValue(optionKey) && 'default' !== this.getOptionValueSource(optionKey);
                });
                definedNonDefaultOptions.filter((option)=>option.conflictsWith.length > 0).forEach((option)=>{
                    let conflictingAndDefined = definedNonDefaultOptions.find((defined)=>option.conflictsWith.includes(defined.attributeName()));
                    conflictingAndDefined && this._conflictingOption(option, conflictingAndDefined);
                });
            }
            _checkForConflictingOptions() {
                this._getCommandAndAncestors().forEach((cmd)=>{
                    cmd._checkForConflictingLocalOptions();
                });
            }
            parseOptions(argv) {
                let operands = [], unknown = [], dest = operands, args = argv.slice();
                function maybeOption(arg) {
                    return arg.length > 1 && '-' === arg[0];
                }
                let activeVariadicOption = null;
                for(; args.length;){
                    let arg = args.shift();
                    if ('--' === arg) {
                        dest === unknown && dest.push(arg), dest.push(...args);
                        break;
                    }
                    if (activeVariadicOption && !maybeOption(arg)) {
                        this.emit(`option:${activeVariadicOption.name()}`, arg);
                        continue;
                    }
                    if (activeVariadicOption = null, maybeOption(arg)) {
                        let option = this._findOption(arg);
                        if (option) {
                            if (option.required) {
                                let value = args.shift();
                                void 0 === value && this.optionMissingArgument(option), this.emit(`option:${option.name()}`, value);
                            } else if (option.optional) {
                                let value = null;
                                args.length > 0 && !maybeOption(args[0]) && (value = args.shift()), this.emit(`option:${option.name()}`, value);
                            } else this.emit(`option:${option.name()}`);
                            activeVariadicOption = option.variadic ? option : null;
                            continue;
                        }
                    }
                    if (arg.length > 2 && '-' === arg[0] && '-' !== arg[1]) {
                        let option = this._findOption(`-${arg[1]}`);
                        if (option) {
                            option.required || option.optional && this._combineFlagAndOptionalValue ? this.emit(`option:${option.name()}`, arg.slice(2)) : (this.emit(`option:${option.name()}`), args.unshift(`-${arg.slice(2)}`));
                            continue;
                        }
                    }
                    if (/^--[^=]+=/.test(arg)) {
                        let index = arg.indexOf('='), option = this._findOption(arg.slice(0, index));
                        if (option && (option.required || option.optional)) {
                            this.emit(`option:${option.name()}`, arg.slice(index + 1));
                            continue;
                        }
                    }
                    if (maybeOption(arg) && (dest = unknown), (this._enablePositionalOptions || this._passThroughOptions) && 0 === operands.length && 0 === unknown.length) {
                        if (this._findCommand(arg)) {
                            operands.push(arg), args.length > 0 && unknown.push(...args);
                            break;
                        }
                        if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
                            operands.push(arg), args.length > 0 && operands.push(...args);
                            break;
                        } else if (this._defaultCommandName) {
                            unknown.push(arg), args.length > 0 && unknown.push(...args);
                            break;
                        }
                    }
                    if (this._passThroughOptions) {
                        dest.push(arg), args.length > 0 && dest.push(...args);
                        break;
                    }
                    dest.push(arg);
                }
                return {
                    operands,
                    unknown
                };
            }
            opts() {
                if (this._storeOptionsAsProperties) {
                    let result = {}, len = this.options.length;
                    for(let i = 0; i < len; i++){
                        let key = this.options[i].attributeName();
                        result[key] = key === this._versionOptionName ? this._version : this[key];
                    }
                    return result;
                }
                return this._optionValues;
            }
            optsWithGlobals() {
                return this._getCommandAndAncestors().reduce((combinedOptions, cmd)=>Object.assign(combinedOptions, cmd.opts()), {});
            }
            error(message, errorOptions) {
                this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr), 'string' == typeof this._showHelpAfterError ? this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`) : this._showHelpAfterError && (this._outputConfiguration.writeErr('\n'), this.outputHelp({
                    error: !0
                }));
                let config = errorOptions || {}, exitCode = config.exitCode || 1, code = config.code || 'commander.error';
                this._exit(exitCode, code, message);
            }
            _parseOptionsEnv() {
                this.options.forEach((option)=>{
                    if (option.envVar && option.envVar in process1.env) {
                        let optionKey = option.attributeName();
                        (void 0 === this.getOptionValue(optionKey) || [
                            'default',
                            'config',
                            'env'
                        ].includes(this.getOptionValueSource(optionKey))) && (option.required || option.optional ? this.emit(`optionEnv:${option.name()}`, process1.env[option.envVar]) : this.emit(`optionEnv:${option.name()}`));
                    }
                });
            }
            _parseOptionsImplied() {
                let dualHelper = new DualOptions(this.options), hasCustomOptionValue = (optionKey)=>void 0 !== this.getOptionValue(optionKey) && ![
                        'default',
                        'implied'
                    ].includes(this.getOptionValueSource(optionKey));
                this.options.filter((option)=>void 0 !== option.implied && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option)=>{
                    Object.keys(option.implied).filter((impliedKey)=>!hasCustomOptionValue(impliedKey)).forEach((impliedKey)=>{
                        this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');
                    });
                });
            }
            missingArgument(name) {
                let message = `error: missing required argument '${name}'`;
                this.error(message, {
                    code: 'commander.missingArgument'
                });
            }
            optionMissingArgument(option) {
                let message = `error: option '${option.flags}' argument missing`;
                this.error(message, {
                    code: 'commander.optionMissingArgument'
                });
            }
            missingMandatoryOptionValue(option) {
                let message = `error: required option '${option.flags}' not specified`;
                this.error(message, {
                    code: 'commander.missingMandatoryOptionValue'
                });
            }
            _conflictingOption(option, conflictingOption) {
                let findBestOptionFromValue = (option)=>{
                    let optionKey = option.attributeName(), optionValue = this.getOptionValue(optionKey), negativeOption = this.options.find((target)=>target.negate && optionKey === target.attributeName()), positiveOption = this.options.find((target)=>!target.negate && optionKey === target.attributeName());
                    return negativeOption && (void 0 === negativeOption.presetArg && !1 === optionValue || void 0 !== negativeOption.presetArg && optionValue === negativeOption.presetArg) ? negativeOption : positiveOption || option;
                }, getErrorMessage = (option)=>{
                    let bestOption = findBestOptionFromValue(option), optionKey = bestOption.attributeName();
                    return 'env' === this.getOptionValueSource(optionKey) ? `environment variable '${bestOption.envVar}'` : `option '${bestOption.flags}'`;
                }, message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
                this.error(message, {
                    code: 'commander.conflictingOption'
                });
            }
            unknownOption(flag) {
                if (this._allowUnknownOption) return;
                let suggestion = '';
                if (flag.startsWith('--') && this._showSuggestionAfterError) {
                    let candidateFlags = [], command = this;
                    do {
                        let moreFlags = command.createHelp().visibleOptions(command).filter((option)=>option.long).map((option)=>option.long);
                        candidateFlags = candidateFlags.concat(moreFlags), command = command.parent;
                    }while (command && !command._enablePositionalOptions);
                    suggestion = suggestSimilar(flag, candidateFlags);
                }
                let message = `error: unknown option '${flag}'${suggestion}`;
                this.error(message, {
                    code: 'commander.unknownOption'
                });
            }
            _excessArguments(receivedArgs) {
                if (this._allowExcessArguments) return;
                let expected = this.registeredArguments.length, forSubcommand = this.parent ? ` for '${this.name()}'` : '', message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${1 === expected ? '' : 's'} but got ${receivedArgs.length}.`;
                this.error(message, {
                    code: 'commander.excessArguments'
                });
            }
            unknownCommand() {
                let unknownName = this.args[0], suggestion = '';
                if (this._showSuggestionAfterError) {
                    let candidateNames = [];
                    this.createHelp().visibleCommands(this).forEach((command)=>{
                        candidateNames.push(command.name()), command.alias() && candidateNames.push(command.alias());
                    }), suggestion = suggestSimilar(unknownName, candidateNames);
                }
                let message = `error: unknown command '${unknownName}'${suggestion}`;
                this.error(message, {
                    code: 'commander.unknownCommand'
                });
            }
            version(str, flags, description) {
                if (void 0 === str) return this._version;
                this._version = str, flags = flags || '-V, --version', description = description || 'output the version number';
                let versionOption = this.createOption(flags, description);
                return this._versionOptionName = versionOption.attributeName(), this._registerOption(versionOption), this.on('option:' + versionOption.name(), ()=>{
                    this._outputConfiguration.writeOut(`${str}\n`), this._exit(0, 'commander.version', str);
                }), this;
            }
            description(str, argsDescription) {
                return void 0 === str && void 0 === argsDescription ? this._description : (this._description = str, argsDescription && (this._argsDescription = argsDescription), this);
            }
            summary(str) {
                return void 0 === str ? this._summary : (this._summary = str, this);
            }
            alias(alias) {
                if (void 0 === alias) return this._aliases[0];
                let command = this;
                if (0 !== this.commands.length && this.commands[this.commands.length - 1]._executableHandler && (command = this.commands[this.commands.length - 1]), alias === command._name) throw Error("Command alias can't be the same as its name");
                let matchingCommand = this.parent?._findCommand(alias);
                if (matchingCommand) {
                    let existingCmd = [
                        matchingCommand.name()
                    ].concat(matchingCommand.aliases()).join('|');
                    throw Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);
                }
                return command._aliases.push(alias), this;
            }
            aliases(aliases) {
                return void 0 === aliases ? this._aliases : (aliases.forEach((alias)=>this.alias(alias)), this);
            }
            usage(str) {
                if (void 0 === str) {
                    if (this._usage) return this._usage;
                    let args = this.registeredArguments.map((arg)=>humanReadableArgName(arg));
                    return [].concat(this.options.length || null !== this._helpOption ? '[options]' : [], this.commands.length ? '[command]' : [], this.registeredArguments.length ? args : []).join(' ');
                }
                return this._usage = str, this;
            }
            name(str) {
                return void 0 === str ? this._name : (this._name = str, this);
            }
            nameFromFilename(filename) {
                return this._name = path.basename(filename, path.extname(filename)), this;
            }
            executableDir(path) {
                return void 0 === path ? this._executableDir : (this._executableDir = path, this);
            }
            helpInformation(contextOptions) {
                let helper = this.createHelp();
                return void 0 === helper.helpWidth && (helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth()), helper.formatHelp(this, helper);
            }
            _getHelpContext(contextOptions) {
                let write;
                let context = {
                    error: !!(contextOptions = contextOptions || {}).error
                };
                return write = context.error ? (arg)=>this._outputConfiguration.writeErr(arg) : (arg)=>this._outputConfiguration.writeOut(arg), context.write = contextOptions.write || write, context.command = this, context;
            }
            outputHelp(contextOptions) {
                let deprecatedCallback;
                'function' == typeof contextOptions && (deprecatedCallback = contextOptions, contextOptions = void 0);
                let context = this._getHelpContext(contextOptions);
                this._getCommandAndAncestors().reverse().forEach((command)=>command.emit('beforeAllHelp', context)), this.emit('beforeHelp', context);
                let helpInformation = this.helpInformation(context);
                if (deprecatedCallback && 'string' != typeof (helpInformation = deprecatedCallback(helpInformation)) && !Buffer.isBuffer(helpInformation)) throw Error('outputHelp callback must return a string or a Buffer');
                context.write(helpInformation), this._getHelpOption()?.long && this.emit(this._getHelpOption().long), this.emit('afterHelp', context), this._getCommandAndAncestors().forEach((command)=>command.emit('afterAllHelp', context));
            }
            helpOption(flags, description) {
                return 'boolean' == typeof flags ? (flags ? this._helpOption = this._helpOption ?? void 0 : this._helpOption = null, this) : (flags = flags ?? '-h, --help', description = description ?? 'display help for command', this._helpOption = this.createOption(flags, description), this);
            }
            _getHelpOption() {
                return void 0 === this._helpOption && this.helpOption(void 0, void 0), this._helpOption;
            }
            addHelpOption(option) {
                return this._helpOption = option, this;
            }
            help(contextOptions) {
                this.outputHelp(contextOptions);
                let exitCode = process1.exitCode || 0;
                0 === exitCode && contextOptions && 'function' != typeof contextOptions && contextOptions.error && (exitCode = 1), this._exit(exitCode, 'commander.help', '(outputHelp)');
            }
            addHelpText(position, text) {
                let allowedValues = [
                    'beforeAll',
                    'before',
                    'after',
                    'afterAll'
                ];
                if (!allowedValues.includes(position)) throw Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
                let helpEvent = `${position}Help`;
                return this.on(helpEvent, (context)=>{
                    let helpStr;
                    (helpStr = 'function' == typeof text ? text({
                        error: context.error,
                        command: context.command
                    }) : text) && context.write(`${helpStr}\n`);
                }), this;
            }
            _outputHelpIfRequested(args) {
                let helpOption = this._getHelpOption();
                helpOption && args.find((arg)=>helpOption.is(arg)) && (this.outputHelp(), this._exit(0, 'commander.helpDisplayed', '(outputHelp)'));
            }
        }
        function incrementNodeInspectorPort(args) {
            return args.map((arg)=>{
                let debugOption, match;
                if (!arg.startsWith('--inspect')) return arg;
                let debugHost = '127.0.0.1', debugPort = '9229';
                return (null !== (match = arg.match(/^(--inspect(-brk)?)$/)) ? debugOption = match[1] : null !== (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) ? (debugOption = match[1], /^\d+$/.test(match[3]) ? debugPort = match[3] : debugHost = match[3]) : null !== (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) && (debugOption = match[1], debugHost = match[3], debugPort = match[4]), debugOption && '0' !== debugPort) ? `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}` : arg;
            });
        }
        exports1.Command = Command;
    },
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/error.js": function(__unused_webpack_module, exports1) {
        class CommanderError extends Error {
            constructor(exitCode, code, message){
                super(message), Error.captureStackTrace(this, this.constructor), this.name = this.constructor.name, this.code = code, this.exitCode = exitCode, this.nestedError = void 0;
            }
        }
        exports1.CommanderError = CommanderError, exports1.InvalidArgumentError = class InvalidArgumentError extends CommanderError {
            constructor(message){
                super(1, 'commander.invalidArgument', message), Error.captureStackTrace(this, this.constructor), this.name = this.constructor.name;
            }
        };
    },
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/help.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        let { humanReadableArgName } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/argument.js");
        exports1.Help = class Help {
            constructor(){
                this.helpWidth = void 0, this.sortSubcommands = !1, this.sortOptions = !1, this.showGlobalOptions = !1;
            }
            visibleCommands(cmd) {
                let visibleCommands = cmd.commands.filter((cmd)=>!cmd._hidden), helpCommand = cmd._getHelpCommand();
                return helpCommand && !helpCommand._hidden && visibleCommands.push(helpCommand), this.sortSubcommands && visibleCommands.sort((a, b)=>a.name().localeCompare(b.name())), visibleCommands;
            }
            compareOptions(a, b) {
                let getSortKey = (option)=>option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');
                return getSortKey(a).localeCompare(getSortKey(b));
            }
            visibleOptions(cmd) {
                let visibleOptions = cmd.options.filter((option)=>!option.hidden), helpOption = cmd._getHelpOption();
                if (helpOption && !helpOption.hidden) {
                    let removeShort = helpOption.short && cmd._findOption(helpOption.short), removeLong = helpOption.long && cmd._findOption(helpOption.long);
                    removeShort || removeLong ? helpOption.long && !removeLong ? visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description)) : helpOption.short && !removeShort && visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description)) : visibleOptions.push(helpOption);
                }
                return this.sortOptions && visibleOptions.sort(this.compareOptions), visibleOptions;
            }
            visibleGlobalOptions(cmd) {
                if (!this.showGlobalOptions) return [];
                let globalOptions = [];
                for(let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent){
                    let visibleOptions = ancestorCmd.options.filter((option)=>!option.hidden);
                    globalOptions.push(...visibleOptions);
                }
                return this.sortOptions && globalOptions.sort(this.compareOptions), globalOptions;
            }
            visibleArguments(cmd) {
                return (cmd._argsDescription && cmd.registeredArguments.forEach((argument)=>{
                    argument.description = argument.description || cmd._argsDescription[argument.name()] || '';
                }), cmd.registeredArguments.find((argument)=>argument.description)) ? cmd.registeredArguments : [];
            }
            subcommandTerm(cmd) {
                let args = cmd.registeredArguments.map((arg)=>humanReadableArgName(arg)).join(' ');
                return cmd._name + (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') + (cmd.options.length ? ' [options]' : '') + (args ? ' ' + args : '');
            }
            optionTerm(option) {
                return option.flags;
            }
            argumentTerm(argument) {
                return argument.name();
            }
            longestSubcommandTermLength(cmd, helper) {
                return helper.visibleCommands(cmd).reduce((max, command)=>Math.max(max, helper.subcommandTerm(command).length), 0);
            }
            longestOptionTermLength(cmd, helper) {
                return helper.visibleOptions(cmd).reduce((max, option)=>Math.max(max, helper.optionTerm(option).length), 0);
            }
            longestGlobalOptionTermLength(cmd, helper) {
                return helper.visibleGlobalOptions(cmd).reduce((max, option)=>Math.max(max, helper.optionTerm(option).length), 0);
            }
            longestArgumentTermLength(cmd, helper) {
                return helper.visibleArguments(cmd).reduce((max, argument)=>Math.max(max, helper.argumentTerm(argument).length), 0);
            }
            commandUsage(cmd) {
                let cmdName = cmd._name;
                cmd._aliases[0] && (cmdName = cmdName + '|' + cmd._aliases[0]);
                let ancestorCmdNames = '';
                for(let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent)ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;
                return ancestorCmdNames + cmdName + ' ' + cmd.usage();
            }
            commandDescription(cmd) {
                return cmd.description();
            }
            subcommandDescription(cmd) {
                return cmd.summary() || cmd.description();
            }
            optionDescription(option) {
                let extraInfo = [];
                return (option.argChoices && extraInfo.push(`choices: ${option.argChoices.map((choice)=>JSON.stringify(choice)).join(', ')}`), void 0 !== option.defaultValue && (option.required || option.optional || option.isBoolean() && 'boolean' == typeof option.defaultValue) && extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`), void 0 !== option.presetArg && option.optional && extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`), void 0 !== option.envVar && extraInfo.push(`env: ${option.envVar}`), extraInfo.length > 0) ? `${option.description} (${extraInfo.join(', ')})` : option.description;
            }
            argumentDescription(argument) {
                let extraInfo = [];
                if (argument.argChoices && extraInfo.push(`choices: ${argument.argChoices.map((choice)=>JSON.stringify(choice)).join(', ')}`), void 0 !== argument.defaultValue && extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`), extraInfo.length > 0) {
                    let extraDescripton = `(${extraInfo.join(', ')})`;
                    return argument.description ? `${argument.description} ${extraDescripton}` : extraDescripton;
                }
                return argument.description;
            }
            formatHelp(cmd, helper) {
                let termWidth = helper.padWidth(cmd, helper), helpWidth = helper.helpWidth || 80;
                function formatItem(term, description) {
                    if (description) {
                        let fullText = `${term.padEnd(termWidth + 2)}${description}`;
                        return helper.wrap(fullText, helpWidth - 2, termWidth + 2);
                    }
                    return term;
                }
                function formatList(textArray) {
                    return textArray.join('\n').replace(/^/gm, ' '.repeat(2));
                }
                let output = [
                    `Usage: ${helper.commandUsage(cmd)}`,
                    ''
                ], commandDescription = helper.commandDescription(cmd);
                commandDescription.length > 0 && (output = output.concat([
                    helper.wrap(commandDescription, helpWidth, 0),
                    ''
                ]));
                let argumentList = helper.visibleArguments(cmd).map((argument)=>formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument)));
                argumentList.length > 0 && (output = output.concat([
                    'Arguments:',
                    formatList(argumentList),
                    ''
                ]));
                let optionList = helper.visibleOptions(cmd).map((option)=>formatItem(helper.optionTerm(option), helper.optionDescription(option)));
                if (optionList.length > 0 && (output = output.concat([
                    'Options:',
                    formatList(optionList),
                    ''
                ])), this.showGlobalOptions) {
                    let globalOptionList = helper.visibleGlobalOptions(cmd).map((option)=>formatItem(helper.optionTerm(option), helper.optionDescription(option)));
                    globalOptionList.length > 0 && (output = output.concat([
                        'Global Options:',
                        formatList(globalOptionList),
                        ''
                    ]));
                }
                let commandList = helper.visibleCommands(cmd).map((cmd)=>formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd)));
                return commandList.length > 0 && (output = output.concat([
                    'Commands:',
                    formatList(commandList),
                    ''
                ])), output.join('\n');
            }
            padWidth(cmd, helper) {
                return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
            }
            wrap(str, width, indent, minColumnWidth = 40) {
                let manualIndent = RegExp(`[\\n][ \\f\\t\\v\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]+`);
                if (str.match(manualIndent)) return str;
                let columnWidth = width - indent;
                if (columnWidth < minColumnWidth) return str;
                let leadingStr = str.slice(0, indent), columnText = str.slice(indent).replace('\r\n', '\n'), indentString = ' '.repeat(indent), breaks = `\\s\u200B`, regex = RegExp(`\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, 'g');
                return leadingStr + (columnText.match(regex) || []).map((line, i)=>'\n' === line ? '' : (i > 0 ? indentString : '') + line.trimEnd()).join('\n');
            }
        };
    },
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/option.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        let { InvalidArgumentError } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/error.js");
        exports1.Option = class Option {
            constructor(flags, description){
                this.flags = flags, this.description = description || '', this.required = flags.includes('<'), this.optional = flags.includes('['), this.variadic = /\w\.\.\.[>\]]$/.test(flags), this.mandatory = !1;
                let optionFlags = function(flags) {
                    let shortFlag, longFlag;
                    let flagParts = flags.split(/[ |,]+/);
                    return flagParts.length > 1 && !/^[[<]/.test(flagParts[1]) && (shortFlag = flagParts.shift()), longFlag = flagParts.shift(), !shortFlag && /^-[^-]$/.test(longFlag) && (shortFlag = longFlag, longFlag = void 0), {
                        shortFlag,
                        longFlag
                    };
                }(flags);
                this.short = optionFlags.shortFlag, this.long = optionFlags.longFlag, this.negate = !1, this.long && (this.negate = this.long.startsWith('--no-')), this.defaultValue = void 0, this.defaultValueDescription = void 0, this.presetArg = void 0, this.envVar = void 0, this.parseArg = void 0, this.hidden = !1, this.argChoices = void 0, this.conflictsWith = [], this.implied = void 0;
            }
            default(value, description) {
                return this.defaultValue = value, this.defaultValueDescription = description, this;
            }
            preset(arg) {
                return this.presetArg = arg, this;
            }
            conflicts(names) {
                return this.conflictsWith = this.conflictsWith.concat(names), this;
            }
            implies(impliedOptionValues) {
                let newImplied = impliedOptionValues;
                return 'string' == typeof impliedOptionValues && (newImplied = {
                    [impliedOptionValues]: !0
                }), this.implied = Object.assign(this.implied || {}, newImplied), this;
            }
            env(name) {
                return this.envVar = name, this;
            }
            argParser(fn) {
                return this.parseArg = fn, this;
            }
            makeOptionMandatory(mandatory = !0) {
                return this.mandatory = !!mandatory, this;
            }
            hideHelp(hide = !0) {
                return this.hidden = !!hide, this;
            }
            _concatValue(value, previous) {
                return previous !== this.defaultValue && Array.isArray(previous) ? previous.concat(value) : [
                    value
                ];
            }
            choices(values) {
                return this.argChoices = values.slice(), this.parseArg = (arg, previous)=>{
                    if (!this.argChoices.includes(arg)) throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);
                    return this.variadic ? this._concatValue(arg, previous) : arg;
                }, this;
            }
            name() {
                return this.long ? this.long.replace(/^--/, '') : this.short.replace(/^-/, '');
            }
            attributeName() {
                return function(str) {
                    return str.split('-').reduce((str, word)=>str + word[0].toUpperCase() + word.slice(1));
                }(this.name().replace(/^no-/, ''));
            }
            is(arg) {
                return this.short === arg || this.long === arg;
            }
            isBoolean() {
                return !this.required && !this.optional && !this.negate;
            }
        }, exports1.DualOptions = class DualOptions {
            constructor(options){
                this.positiveOptions = new Map(), this.negativeOptions = new Map(), this.dualOptions = new Set(), options.forEach((option)=>{
                    option.negate ? this.negativeOptions.set(option.attributeName(), option) : this.positiveOptions.set(option.attributeName(), option);
                }), this.negativeOptions.forEach((value, key)=>{
                    this.positiveOptions.has(key) && this.dualOptions.add(key);
                });
            }
            valueFromOption(value, option) {
                let optionKey = option.attributeName();
                if (!this.dualOptions.has(optionKey)) return !0;
                let preset = this.negativeOptions.get(optionKey).presetArg;
                return option.negate === ((void 0 !== preset && preset) === value);
            }
        };
    },
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/suggestSimilar.js": function(__unused_webpack_module, exports1) {
        exports1.suggestSimilar = function(word, candidates) {
            if (!candidates || 0 === candidates.length) return '';
            candidates = Array.from(new Set(candidates));
            let searchingOptions = word.startsWith('--');
            searchingOptions && (word = word.slice(2), candidates = candidates.map((candidate)=>candidate.slice(2)));
            let similar = [], bestDistance = 3;
            return (candidates.forEach((candidate)=>{
                if (candidate.length <= 1) return;
                let distance = function(a, b) {
                    if (Math.abs(a.length - b.length) > 3) return Math.max(a.length, b.length);
                    let d = [];
                    for(let i = 0; i <= a.length; i++)d[i] = [
                        i
                    ];
                    for(let j = 0; j <= b.length; j++)d[0][j] = j;
                    for(let j = 1; j <= b.length; j++)for(let i = 1; i <= a.length; i++){
                        let cost = 1;
                        cost = a[i - 1] === b[j - 1] ? 0 : 1, d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost), i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1] && (d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1));
                    }
                    return d[a.length][b.length];
                }(word, candidate), length = Math.max(word.length, candidate.length);
                (length - distance) / length > 0.4 && (distance < bestDistance ? (bestDistance = distance, similar = [
                    candidate
                ]) : distance === bestDistance && similar.push(candidate));
            }), similar.sort((a, b)=>a.localeCompare(b)), searchingOptions && (similar = similar.map((candidate)=>`--${candidate}`)), similar.length > 1) ? `\n(Did you mean one of ${similar.join(', ')}?)` : 1 === similar.length ? `\n(Did you mean ${similar[0]}?)` : '';
        };
    },
    "../../node_modules/.pnpm/dotenv@16.4.7/node_modules/dotenv/package.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"name":"dotenv","version":"16.4.7","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');
    }
}, __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    return __webpack_modules__[moduleId](module, module.exports, __webpack_require__), module.exports;
}
__webpack_require__.n = function(module) {
    var getter = module && module.__esModule ? function() {
        return module.default;
    } : function() {
        return module;
    };
    return __webpack_require__.d(getter, {
        a: getter
    }), getter;
}, __webpack_require__.d = function(exports1, definition) {
    for(var key in definition)__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key) && Object.defineProperty(exports1, key, {
        enumerable: !0,
        get: definition[key]
    });
}, __webpack_require__.o = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}, __webpack_require__.r = function(exports1) {
    'undefined' != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports1, Symbol.toStringTag, {
        value: 'Module'
    }), Object.defineProperty(exports1, '__esModule', {
        value: !0
    });
};
var __webpack_exports__ = {};
(()=>{
    "use strict";
    let pluginHelper_htmlPlugin, cssExtractPlugin, swcHelpersPath;
    __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
        defineConfig: ()=>defineConfig,
        PLUGIN_CSS_NAME: ()=>PLUGIN_CSS_NAME,
        mergeRsbuildConfig: ()=>mergeRsbuildConfig,
        logger: ()=>rslog_index_js_namespaceObject.logger,
        createRsbuild: ()=>createRsbuild,
        __internalHelper: ()=>internal_namespaceObject,
        loadEnv: ()=>loadEnv,
        rspack: ()=>core_namespaceObject.rspack,
        runCLI: ()=>runCLI,
        version: ()=>src_rslib_entry_version,
        PLUGIN_SWC_NAME: ()=>PLUGIN_SWC_NAME,
        loadConfig: ()=>config_loadConfig,
        ensureAssetPrefix: ()=>ensureAssetPrefix
    });
    var internal_namespaceObject = {};
    __webpack_require__.r(internal_namespaceObject), __webpack_require__.d(internal_namespaceObject, {
        setHTMLPlugin: ()=>setHTMLPlugin
    });
    var provider_helpers_namespaceObject = {};
    __webpack_require__.r(provider_helpers_namespaceObject), __webpack_require__.d(provider_helpers_namespaceObject, {
        chainToConfig: ()=>chainToConfig,
        createDevServer: ()=>devServer_createDevServer,
        formatStats: ()=>formatStats,
        getChainUtils: ()=>getChainUtils,
        getConfigUtils: ()=>getConfigUtils,
        getHTMLPlugin: ()=>getHTMLPlugin,
        getRsbuildInspectConfig: ()=>getRsbuildInspectConfig,
        getStatsOptions: ()=>getStatsOptions,
        initRsbuildConfig: ()=>initRsbuildConfig,
        modifyBundlerChain: ()=>modifyBundlerChain,
        outputInspectConfigFiles: ()=>outputInspectConfigFiles,
        prettyTime: ()=>prettyTime,
        registerBuildHook: ()=>registerBuildHook,
        registerDevHook: ()=>registerDevHook,
        setCssExtractPlugin: ()=>setCssExtractPlugin,
        setHTMLPlugin: ()=>setHTMLPlugin,
        stringifyConfig: ()=>stringifyConfig
    });
    let core_namespaceObject = require("@rspack/core");
    var core_default = __webpack_require__.n(core_namespaceObject);
    let external_node_module_namespaceObject = require("node:module"), pluginHelper_require = (0, external_node_module_namespaceObject.createRequire)(__rslib_import_meta_url__), setHTMLPlugin = (plugin)=>{
        plugin && (pluginHelper_htmlPlugin = plugin);
    }, getHTMLPlugin = ()=>(!pluginHelper_htmlPlugin && (pluginHelper_htmlPlugin = pluginHelper_require('../compiled/html-rspack-plugin/index.js')), pluginHelper_htmlPlugin), setCssExtractPlugin = (plugin)=>{
        cssExtractPlugin = plugin;
    }, getCssExtractPlugin = ()=>cssExtractPlugin ? cssExtractPlugin : core_default().CssExtractRspackPlugin;
    var external_node_fs_ = __webpack_require__("node:fs"), external_node_fs_default = __webpack_require__.n(external_node_fs_), external_node_path_ = __webpack_require__("node:path"), external_node_path_default = __webpack_require__.n(external_node_path_), main = __webpack_require__("../../node_modules/.pnpm/dotenv@16.4.7/node_modules/dotenv/lib/main.js"), lib_main = __webpack_require__("../../node_modules/.pnpm/dotenv-expand@11.0.7/node_modules/dotenv-expand/lib/main.js");
    let external_node_url_namespaceObject = require("node:url");
    var cjs = __webpack_require__("../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js"), cjs_default = __webpack_require__.n(cjs);
    let index_js_namespaceObject = require("../compiled/picocolors/index.js");
    var index_js_default = __webpack_require__.n(index_js_namespaceObject);
    let constants_filename = (0, external_node_url_namespaceObject.fileURLToPath)(__rslib_import_meta_url__), constants_dirname = (0, external_node_path_.dirname)(constants_filename), ROOT_DIST_DIR = 'dist', LOADER_PATH = (0, external_node_path_.join)(constants_dirname), STATIC_PATH = (0, external_node_path_.join)(constants_dirname, '../static'), COMPILED_PATH = (0, external_node_path_.join)(constants_dirname, '../compiled'), RSBUILD_OUTPUTS_PATH = '.rsbuild', DEFAULT_DEV_HOST = '0.0.0.0', DEFAULT_ASSET_PREFIX = '/', DEFAULT_WEB_BROWSERSLIST = [
        'chrome >= 87',
        'edge >= 88',
        'firefox >= 78',
        'safari >= 14'
    ], DEFAULT_BROWSERSLIST = {
        web: DEFAULT_WEB_BROWSERSLIST,
        'web-worker': DEFAULT_WEB_BROWSERSLIST,
        node: [
            'node >= 16'
        ]
    }, HTML_REGEX = /\.html$/, JS_REGEX = /\.(?:js|mjs|cjs|jsx)$/, SCRIPT_REGEX = /\.(?:js|jsx|mjs|cjs|ts|tsx|mts|cts)$/, CSS_REGEX = /\.css$/, NODE_MODULES_REGEX = /[\\/]node_modules[\\/]/, PLUGIN_SWC_NAME = 'rsbuild:swc', PLUGIN_CSS_NAME = 'rsbuild:css', FONT_EXTENSIONS = [
        'woff',
        'woff2',
        'eot',
        'ttf',
        'otf',
        'ttc'
    ], IMAGE_EXTENSIONS = [
        'png',
        'jpg',
        'jpeg',
        'pjpeg',
        'pjp',
        'gif',
        'bmp',
        'webp',
        'ico',
        'apng',
        'avif',
        'tif',
        'tiff',
        'jfif'
    ], VIDEO_EXTENSIONS = [
        'mp4',
        'webm',
        'ogg',
        'mov'
    ], AUDIO_EXTENSIONS = [
        'mp3',
        'wav',
        'flac',
        'aac',
        'm4a',
        'opus'
    ], rslog_index_js_namespaceObject = require("../compiled/rslog/index.js"), isDebug = ()=>{
        if (!process.env.DEBUG) return !1;
        let values = process.env.DEBUG.toLocaleLowerCase().split(',');
        return [
            'rsbuild',
            'builder',
            '*'
        ].some((key)=>values.includes(key));
    };
    isDebug() && (rslog_index_js_namespaceObject.logger.level = 'verbose');
    rslog_index_js_namespaceObject.logger.override({
        debug: (message, ...args)=>{
            if ('verbose' !== rslog_index_js_namespaceObject.logger.level) return;
            let time = index_js_default().gray(`${function() {
                let now = new Date(), hours = String(now.getHours()).padStart(2, '0'), minutes = String(now.getMinutes()).padStart(2, '0'), seconds = String(now.getSeconds()).padStart(2, '0');
                return `${hours}:${minutes}:${seconds}`;
            }()}`);
            console.log(`  ${index_js_default().magenta('rsbuild')} ${time} ${message}`, ...args);
        }
    });
    let isFileSync = (filePath)=>{
        try {
            var _fs_statSync;
            return null === (_fs_statSync = external_node_fs_default().statSync(filePath, {
                throwIfNoEntry: !1
            })) || void 0 === _fs_statSync ? void 0 : _fs_statSync.isFile();
        } catch (_) {
            return !1;
        }
    }, findExists = (files)=>{
        for (let file of files)if (isFileSync(file)) return file;
        return !1;
    };
    async function pathExists(path) {
        return external_node_fs_default().promises.access(path).then(()=>!0).catch(()=>!1);
    }
    async function isFileExists(file) {
        return external_node_fs_default().promises.access(file, external_node_fs_default().constants.F_OK).then(()=>!0).catch(()=>!1);
    }
    async function fileExistsByCompilation({ inputFileSystem }, filePath) {
        return new Promise((resolve)=>{
            if (!inputFileSystem) {
                resolve(!1);
                return;
            }
            inputFileSystem.stat(filePath, (err, stats)=>{
                err ? resolve(!1) : resolve(!!(null == stats ? void 0 : stats.isFile()));
            });
        });
    }
    async function emptyDir(dir) {
        if (!!await pathExists(dir)) try {
            for (let file of (await external_node_fs_default().promises.readdir(dir)))await external_node_fs_default().promises.rm(external_node_path_default().resolve(dir, file), {
                recursive: !0,
                force: !0
            });
        } catch (err) {
            rslog_index_js_namespaceObject.logger.debug(`Failed to empty dir: ${dir}`), rslog_index_js_namespaceObject.logger.debug(err);
        }
    }
    function getAbsolutePath(base, filepath) {
        return (0, external_node_path_.isAbsolute)(filepath) ? filepath : (0, external_node_path_.join)(base, filepath);
    }
    let getCompiledPath = (packageName)=>(0, external_node_path_.join)(COMPILED_PATH, packageName, 'index.js'), ensureAbsolutePath = (base, filePath)=>(0, external_node_path_.isAbsolute)(filePath) ? filePath : (0, external_node_path_.resolve)(base, filePath), pathnameParse = (publicPath)=>{
        try {
            return publicPath ? new URL(publicPath).pathname : publicPath;
        } catch (err) {
            return publicPath;
        }
    }, hintNodePolyfill = (message)=>{
        let getTips = (moduleName)=>{
            let tips = [
                `Tip: "${moduleName}" is a built-in Node.js module. It cannot be imported in client-side code.`,
                `Check if you need to import Node.js module. If needed, you can use "${index_js_default().cyan('@rsbuild/plugin-node-polyfill')}" to polyfill it.`
            ];
            return `${message}\n\n${index_js_default().yellow(tips.join('\n'))}`;
        };
        if (message.includes('need an additional plugin to handle "node:" URIs')) return getTips('node:*');
        if (!message.includes("Can't resolve")) return message;
        let matchArray = message.match(/Can't resolve '(\w+)'/);
        if (!matchArray) return message;
        let moduleName = matchArray[1];
        return moduleName && [
            'assert',
            'buffer',
            'child_process',
            'cluster',
            'console',
            'constants',
            'crypto',
            'dgram',
            'dns',
            'domain',
            'events',
            'fs',
            'http',
            'https',
            'module',
            'net',
            'os',
            'path',
            'punycode',
            'process',
            'querystring',
            'readline',
            'repl',
            'stream',
            '_stream_duplex',
            '_stream_passthrough',
            '_stream_readable',
            '_stream_transform',
            '_stream_writable',
            'string_decoder',
            'sys',
            'timers',
            'tls',
            'tty',
            'url',
            'util',
            'vm',
            'zlib'
        ].includes(moduleName) ? getTips(moduleName) : message;
    };
    function formatMessage(stats, verbose) {
        let message, lines = [];
        if ('object' == typeof stats) {
            let fileName = function(stats) {
                if (stats.moduleIdentifier) {
                    let matched = stats.moduleIdentifier.match(/(?:\!|^)([^!]+)$/);
                    if (matched) {
                        let fileName = matched.pop();
                        if (fileName) return `File: ${fileName}:1:1\n`;
                    }
                }
                let file = stats.file || stats.moduleName;
                return file ? `File: ${file}\n` : '';
            }(stats), mainMessage = stats.message, details = verbose && stats.details ? `\nDetails: ${stats.details}\n` : '', stack = verbose && stats.stack ? `\n${stats.stack}` : '', moduleTrace = function(stats) {
                let traceStr = '';
                if (stats.moduleTrace) for (let trace of stats.moduleTrace)trace.originName && (traceStr += `\n @ ${trace.originName}`);
                return traceStr;
            }(stats);
            message = `${fileName}${mainMessage}${details}${stack}${moduleTrace}`;
        } else message = stats;
        let innerError = '-- inner error --';
        return !verbose && message.includes(innerError) && (message = message.split(innerError)[0]), (message = (lines = (lines = (message = hintNodePolyfill(message = function(message) {
            let hint = 'You may need an appropriate loader to handle this file type.';
            return -1 === message.indexOf(hint) ? message : /File: .+\.s(c|a)ss/.test(message) ? message.replace(hint, `To enable support for Sass, use "${index_js_default().yellow('@rsbuild/plugin-sass')}".`) : /File: .+\.less/.test(message) ? message.replace(hint, `To enable support for Less, use "${index_js_default().yellow('@rsbuild/plugin-less')}".`) : /File: .+\.styl(us)?/.test(message) ? message.replace(hint, `To enable support for Stylus, use "${index_js_default().yellow('@rsbuild/plugin-stylus')}".`) : message;
        }(message))).split('\n')).filter((line, index, arr)=>0 === index || '' !== line.trim() || line.trim() !== arr[index - 1].trim())).join('\n')).trim();
    }
    function formatStatsMessages(stats, verbose) {
        var _stats_errors, _stats_warnings;
        let formattedErrors = (null === (_stats_errors = stats.errors) || void 0 === _stats_errors ? void 0 : _stats_errors.map((error)=>formatMessage(error, verbose))) || [];
        return {
            errors: formattedErrors,
            warnings: (null === (_stats_warnings = stats.warnings) || void 0 === _stats_warnings ? void 0 : _stats_warnings.map((warning)=>formatMessage(warning, verbose))) || []
        };
    }
    let getAllStatsErrors = (statsData)=>{
        var _statsData_errors, _statsData_children;
        return statsData.errorsCount && (null === (_statsData_errors = statsData.errors) || void 0 === _statsData_errors ? void 0 : _statsData_errors.length) === 0 ? null === (_statsData_children = statsData.children) || void 0 === _statsData_children ? void 0 : _statsData_children.reduce((errors, curr)=>errors.concat(curr.errors || []), []) : statsData.errors;
    }, getAllStatsWarnings = (statsData)=>{
        var _statsData_warnings, _statsData_children;
        return statsData.warningsCount && (null === (_statsData_warnings = statsData.warnings) || void 0 === _statsData_warnings ? void 0 : _statsData_warnings.length) === 0 ? null === (_statsData_children = statsData.children) || void 0 === _statsData_children ? void 0 : _statsData_children.reduce((warnings, curr)=>warnings.concat(curr.warnings || []), []) : statsData.warnings;
    };
    function getStatsOptions(compiler) {
        if (isMultiCompiler(compiler)) return {
            children: compiler.compilers.map((compiler)=>compiler.options ? compiler.options.stats : void 0)
        };
        let { stats } = compiler.options;
        return 'string' == typeof stats ? {
            preset: stats
        } : 'object' == typeof stats ? stats : {};
    }
    function formatStats(statsData, hasErrors) {
        let verbose = 'verbose' === rslog_index_js_namespaceObject.logger.level;
        if (hasErrors) {
            let { errors } = formatStatsMessages({
                errors: getAllStatsErrors(statsData),
                warnings: []
            }, verbose);
            return {
                message: function(errors) {
                    let title = index_js_default().bold(index_js_default().red('Compile error: '));
                    if (!errors.length) return `${title}\n${index_js_default().yellow("For more details, please setting 'stats.errors: true' ")}`;
                    let tip = index_js_default().yellow('Failed to compile, check the errors for troubleshooting.'), text = `${errors.join('\n\n')}\n`;
                    return `${title}\n${tip}\n${text}`;
                }(errors),
                level: 'error'
            };
        }
        let { warnings } = formatStatsMessages({
            errors: [],
            warnings: getAllStatsWarnings(statsData)
        }, verbose);
        if (warnings.length) {
            let title = index_js_default().bold(index_js_default().yellow('Compile Warning: \n'));
            return {
                message: `${title}${warnings.join('\n\n')}\n`,
                level: 'warning'
            };
        }
        return {};
    }
    let rspackMinVersion = '1.0.0', getNodeEnv = ()=>process.env.NODE_ENV, setNodeEnv = (env)=>{
        process.env.NODE_ENV = env;
    }, isFunction = (func)=>'function' == typeof func, isObject = (obj)=>'[object Object]' === Object.prototype.toString.call(obj), isPlainObject = (obj)=>null !== obj && 'object' == typeof obj && Object.getPrototypeOf(obj) === Object.prototype, castArray = (arr)=>void 0 === arr ? [] : Array.isArray(arr) ? arr : [
            arr
        ], cloneDeep = (value)=>null == value ? value : cjs_default()({}, value, {
            isMergeableObject: isPlainObject
        }), compareSemver = (version1, version2)=>{
        let parts1 = version1.split('.').map(Number), parts2 = version2.split('.').map(Number), len = Math.max(parts1.length, parts2.length);
        for(let i = 0; i < len; i++){
            let item1 = parts1[i] ?? 0, item2 = parts2[i] ?? 0;
            if (item1 > item2) return 1;
            if (item1 < item2) return -1;
        }
        return 0;
    }, isSatisfyRspackVersion = async (originalVersion)=>{
        let version = originalVersion;
        return version.includes('-canary') && (version = version.split('-canary')[0]), !(version && /^[\d\.]+$/.test(version)) || compareSemver(version, rspackMinVersion) >= 0;
    }, removeLeadingSlash = (s)=>s.replace(/^\/+/, ''), removeTailingSlash = (s)=>s.replace(/\/+$/, ''), addTrailingSlash = (s)=>s.endsWith('/') ? s : `${s}/`, formatPublicPath = (publicPath, withSlash = !0)=>'auto' === publicPath ? publicPath : withSlash ? addTrailingSlash(publicPath) : removeTailingSlash(publicPath), getPublicPathFromChain = (chain, withSlash = !0)=>{
        let publicPath = chain.output.get('publicPath');
        return 'string' == typeof publicPath ? formatPublicPath(publicPath, withSlash) : formatPublicPath(DEFAULT_ASSET_PREFIX, withSlash);
    }, getPublicPathFromCompiler = (compiler)=>{
        let { publicPath } = compiler.options.output;
        if ('string' == typeof publicPath) return 'auto' === publicPath ? '' : publicPath.endsWith('/') ? publicPath : `${publicPath}/`;
        return DEFAULT_ASSET_PREFIX;
    }, urlJoin = (base, path)=>{
        let [urlProtocol, baseUrl] = base.split('://');
        return `${urlProtocol}://${external_node_path_.posix.join(baseUrl, path)}`;
    }, canParse = (url)=>{
        try {
            return new external_node_url_namespaceObject.URL(url), !0;
        } catch  {
            return !1;
        }
    }, parseUrl = (url)=>{
        try {
            return new external_node_url_namespaceObject.URL(url);
        } catch  {
            return null;
        }
    }, ensureAssetPrefix = (url, assetPrefix = DEFAULT_ASSET_PREFIX)=>url.startsWith('//') || canParse(url) || 'auto' === assetPrefix || 'function' == typeof assetPrefix ? url : assetPrefix.startsWith('http') ? urlJoin(assetPrefix, url) : assetPrefix.startsWith('//') ? urlJoin(`https:${assetPrefix}`, url).replace('https:', '') : external_node_path_.posix.join(assetPrefix, url);
    function getFilename(config, type, isProd, isServer) {
        let { filename, filenameHash } = config.output, hash = 'string' == typeof filenameHash ? filenameHash ? `.[${filenameHash}]` : '' : filenameHash ? '.[contenthash:8]' : '';
        switch(type){
            case 'js':
                return filename.js ?? `[name]${isProd && !isServer ? hash : ''}.js`;
            case 'css':
                return filename.css ?? `[name]${isProd ? hash : ''}.css`;
            case 'svg':
                return filename.svg ?? `[name]${hash}.svg`;
            case 'font':
                return filename.font ?? `[name]${hash}[ext]`;
            case 'image':
                return filename.image ?? `[name]${hash}[ext]`;
            case 'media':
                return filename.media ?? `[name]${hash}[ext]`;
            case 'assets':
                return filename.assets ?? `[name]${hash}[ext]`;
            default:
                throw Error(`[rsbuild:config] unknown key ${type} in "output.filename"`);
        }
    }
    let applyToCompiler = (compiler, apply)=>{
        isMultiCompiler(compiler) ? compiler.compilers.forEach(apply) : apply(compiler, 0);
    }, upperFirst = (str)=>str ? str.charAt(0).toUpperCase() + str.slice(1) : '', isURL = (str)=>str.startsWith('http') || str.startsWith('//:'), createVirtualModule = (content)=>`data:text/javascript,${content}`, isMultiCompiler = (compiler)=>'MultiCompiler' === compiler.constructor.name;
    function pick(obj, keys) {
        return keys.reduce((ret, key)=>(void 0 !== obj[key] && (ret[key] = obj[key]), ret), {});
    }
    let camelCase = (input)=>input.replace(/[-_](\w)/g, (_, c)=>c.toUpperCase()), prettyTime = (seconds)=>{
        let format = (time)=>index_js_default().bold(time);
        if (seconds < 10) {
            let digits = seconds >= 0.01 ? 2 : 3;
            return `${format(seconds.toFixed(digits))} s`;
        }
        if (seconds < 60) return `${format(seconds.toFixed(1))} s`;
        let minutes = seconds / 60;
        return `${format(minutes.toFixed(2))} m`;
    }, isTTY = (type = 'stdout')=>('stdin' === type ? process.stdin.isTTY : process.stdout.isTTY) && !process.env.CI;
    function loadEnv({ cwd = process.cwd(), mode = getNodeEnv(), prefixes = [
        'PUBLIC_'
    ] } = {}) {
        if ('local' === mode) throw Error("[rsbuild:loadEnv] 'local' cannot be used as a value for env mode, because \".env.local\" represents a temporary local file. Please use another value.");
        let filePaths = [
            '.env',
            '.env.local',
            `.env.${mode}`,
            `.env.${mode}.local`
        ].map((filename)=>(0, external_node_path_.join)(cwd, filename)).filter(isFileSync), parsed = {};
        for (let envPath of filePaths)Object.assign(parsed, (0, main.parse)(external_node_fs_default().readFileSync(envPath)));
        parsed.NODE_ENV && (process.env.NODE_ENV = parsed.NODE_ENV), (0, lib_main.expand)({
            parsed
        });
        let publicVars = {}, rawPublicVars = {};
        for (let key of Object.keys(process.env))if (prefixes.some((prefix)=>key.startsWith(prefix))) {
            let val = process.env[key];
            publicVars[`import.meta.env.${key}`] = JSON.stringify(val), publicVars[`process.env.${key}`] = JSON.stringify(val), rawPublicVars[key] = val;
        }
        let cleaned = !1;
        return {
            parsed,
            cleanup: ()=>{
                if (!cleaned) {
                    for (let key of Object.keys(parsed)){
                        if ('NODE_ENV' !== key) process.env[key] === parsed[key] && delete process.env[key];
                    }
                    cleaned = !0;
                }
            },
            filePaths,
            publicVars,
            rawPublicVars
        };
    }
    let types_namespaceObject = require("node:util/types");
    class BrowserslistError extends Error {
        constructor(message){
            super(message), function(obj, key, value) {
                key in obj ? Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : obj[key] = value;
            }(this, "browserslist", void 0), this.name = 'BrowserslistError', this.browserslist = !0, Error.captureStackTrace && Error.captureStackTrace(this, BrowserslistError);
        }
    }
    let isFileCache = {};
    function isFile(file) {
        if (file in isFileCache) return isFileCache[file];
        let result = external_node_fs_.existsSync(file) && external_node_fs_.statSync(file).isFile();
        return isFileCache[file] = result, result;
    }
    function parsePackage(file) {
        let config = JSON.parse(external_node_fs_.readFileSync(file).toString().replace(/^\uFEFF/m, ''));
        if (config.browserlist && !config.browserslist) throw new BrowserslistError(`\`browserlist\` key instead of \`browserslist\` in ${file}`);
        let list = config.browserslist;
        for(let i in Array.isArray(list) && (list = {
            defaults: list
        }), 'string' == typeof list && (list = parseConfig(list)), list)!function(section) {
            let FORMAT = 'Browserslist config should be a string or an array of strings with browser queries';
            if (Array.isArray(section)) {
                for(let i = 0; i < section.length; i++)if ('string' != typeof section[i]) throw new BrowserslistError(FORMAT);
            } else if ('string' != typeof section) throw new BrowserslistError(FORMAT);
        }(list[i]);
        return list;
    }
    let IS_SECTION = /^\s*\[(.+)]\s*$/;
    function parseConfig(string) {
        let result = {
            defaults: []
        }, sections = [
            'defaults'
        ];
        return string.toString().replace(/#[^\n]*/g, '').split(/\n|,/).map((line)=>line.trim()).filter((line)=>'' !== line).forEach((line)=>{
            let matched = line.match(IS_SECTION);
            matched ? (sections = matched[1].trim().split(' ')).forEach((section)=>{
                if (result[section]) throw new BrowserslistError(`Duplicate section ${section} in Browserslist config`);
                result[section] = [];
            }) : sections.forEach((section)=>{
                result[section].push(line);
            });
        }), result;
    }
    function parsePackageOrReadConfig(file) {
        return 'package.json' === external_node_path_.basename(file) ? parsePackage(file) : function(file) {
            if (!isFile(file)) throw new BrowserslistError(`Can't read ${file} config`);
            return parseConfig(external_node_fs_.readFileSync(file, 'utf-8'));
        }(file);
    }
    function pickEnv(config, opts) {
        let name;
        return 'object' != typeof config ? config : ('string' == typeof opts.env ? name = opts.env : process.env.BROWSERSLIST_ENV ? name = process.env.BROWSERSLIST_ENV : process.env.NODE_ENV ? name = process.env.NODE_ENV : name = 'production', config[name] || config.defaults);
    }
    function eachParent(file, callback) {
        let dir = isFile(file) ? external_node_path_.dirname(file) : file, loc = external_node_path_.resolve(dir);
        do {
            let result = callback(loc);
            if (void 0 !== result) return result;
        }while (loc !== (loc = external_node_path_.dirname(loc)));
    }
    let configCache = {}, rspack_chain_index_js_namespaceObject = require("../compiled/rspack-chain/index.js");
    var rspack_chain_index_js_default = __webpack_require__.n(rspack_chain_index_js_namespaceObject);
    let OVERRIDE_PATHS = [
        'performance.removeConsole',
        'output.inlineScripts',
        'output.inlineStyles',
        'output.cssModules.auto',
        'output.overrideBrowserslist',
        'server.open',
        'server.printUrls',
        'resolve.extensions',
        'provider'
    ], isOverridePath = (key)=>{
        if (key.startsWith('environments.')) {
            let realKey = key.split('.').slice(2).join('.');
            return OVERRIDE_PATHS.includes(realKey);
        }
        return OVERRIDE_PATHS.includes(key);
    }, mergeConfig_merge = (x, y, path = '')=>{
        if (isOverridePath(path)) return y ?? x;
        if (void 0 === x) return isPlainObject(y) ? cloneDeep(y) : y;
        if (void 0 === y) return isPlainObject(x) ? cloneDeep(x) : x;
        if ('boolean' == typeof x || 'boolean' == typeof y) return y;
        let pair = [
            x,
            y
        ];
        if (pair.some(Array.isArray)) return [
            ...castArray(x),
            ...castArray(y)
        ];
        if (pair.some(isFunction)) return pair;
        if (!isPlainObject(x) || !isPlainObject(y)) return y;
        let merged = {};
        for (let key of new Set([
            ...Object.keys(x),
            ...Object.keys(y)
        ])){
            let childPath = path ? `${path}.${key}` : key;
            merged[key] = mergeConfig_merge(x[key], y[key], childPath);
        }
        return merged;
    }, mergeRsbuildConfig = (...configs)=>2 === configs.length ? mergeConfig_merge(configs[0], configs[1]) : configs.length < 2 ? configs[0] : configs.reduce((result, config)=>mergeConfig_merge(result, config), {}), commonOpts = {}, getEnvDir = (cwd, envDir)=>envDir ? external_node_path_default().isAbsolute(envDir) ? envDir : external_node_path_default().resolve(cwd, envDir) : cwd;
    async function init({ cliOptions, isRestart, isBuildWatch = !1 }) {
        cliOptions && (commonOpts = cliOptions);
        try {
            var _config_server, _config_dev, _config_dev1;
            let cwd = process.cwd(), root = commonOpts.root ? getAbsolutePath(cwd, commonOpts.root) : cwd, envs = loadEnv({
                cwd: getEnvDir(root, commonOpts.envDir),
                mode: commonOpts.envMode
            }), { content: config, filePath: configFilePath } = await config_loadConfig({
                cwd: root,
                path: commonOpts.config,
                envMode: commonOpts.envMode
            }), command = process.argv[2];
            if ('dev' === command || isBuildWatch) {
                let files = [
                    ...envs.filePaths
                ];
                if (configFilePath && files.push(configFilePath), null === (_config_dev1 = config.dev) || void 0 === _config_dev1 ? void 0 : _config_dev1.watchFiles) for (let watchFilesConfig of castArray(config.dev.watchFiles)){
                    if ('reload-server' !== watchFilesConfig.type) continue;
                    let paths = castArray(watchFilesConfig.paths);
                    watchFilesConfig.options ? watchFilesForRestart(paths, root, isBuildWatch, watchFilesConfig.options) : files.push(...paths);
                }
                watchFilesForRestart(files, root, isBuildWatch);
            }
            config.source ||= {}, config.source.define = {
                ...envs.publicVars,
                ...config.source.define
            }, commonOpts.root && (config.root = root), commonOpts.mode && (config.mode = commonOpts.mode), commonOpts.open && !(null === (_config_server = config.server) || void 0 === _config_server ? void 0 : _config_server.open) && (config.server ||= {}, config.server.open = commonOpts.open), commonOpts.host && (config.server ||= {}, config.server.host = commonOpts.host), commonOpts.port && (config.server ||= {}, config.server.port = commonOpts.port), (null === (_config_dev = config.dev) || void 0 === _config_dev ? void 0 : _config_dev.cliShortcuts) === void 0 && (config.dev ||= {}, config.dev.cliShortcuts = !0);
            let rsbuild = await createRsbuild({
                cwd: root,
                rsbuildConfig: config,
                environment: commonOpts.environment
            });
            return rsbuild.onCloseBuild(envs.cleanup), rsbuild.onCloseDevServer(envs.cleanup), rsbuild;
        } catch (err) {
            if (isRestart) rslog_index_js_namespaceObject.logger.error(err);
            else throw err;
        }
    }
    let cleaners = [], onBeforeRestartServer = (cleaner)=>{
        cleaners.push(cleaner);
    }, clearConsole = ()=>{
        isTTY() && !process.env.DEBUG && process.stdout.write('\x1B[H\x1B[2J');
    }, beforeRestart = async ({ filePath, clear = !0, id })=>{
        if (clear && clearConsole(), filePath) {
            let filename = external_node_path_default().basename(filePath);
            rslog_index_js_namespaceObject.logger.info(`Restart ${id} because ${index_js_default().yellow(filename)} is changed.\n`);
        } else rslog_index_js_namespaceObject.logger.info(`Restarting ${id}...\n`);
        for (let cleaner of cleaners)await cleaner();
        cleaners = [];
    }, restartDevServer = async ({ filePath, clear = !0 } = {})=>{
        await beforeRestart({
            filePath,
            clear,
            id: 'server'
        });
        let rsbuild = await init({
            isRestart: !0
        });
        if (!!rsbuild) await rsbuild.startDevServer();
    }, restartBuild = async ({ filePath, clear = !0 } = {})=>{
        await beforeRestart({
            filePath,
            clear,
            id: 'build'
        });
        let rsbuild = await init({
            isRestart: !0,
            isBuildWatch: !0
        });
        if (!!rsbuild) onBeforeRestartServer((await rsbuild.build({
            watch: !0
        })).close);
    };
    async function setupWatchFiles(options) {
        let { dev, server, root, compileMiddlewareAPI } = options, { hmr, liveReload } = dev;
        if (!hmr && !liveReload || !compileMiddlewareAPI) return;
        let closeDevFilesWatcher = await watchDevFiles(dev, compileMiddlewareAPI, root), serverFilesWatcher = await function(serverConfig, compileMiddlewareAPI, root) {
            let publicDirs = normalizePublicDirs(serverConfig.publicDir);
            if (!publicDirs.length) return;
            let watchPaths = publicDirs.filter((item)=>item.watch).map((item)=>item.name);
            if (!!watchPaths.length) return startWatchFiles(prepareWatchOptions(watchPaths), compileMiddlewareAPI, root);
        }(server, compileMiddlewareAPI, root);
        return {
            async close () {
                await Promise.all([
                    null == closeDevFilesWatcher ? void 0 : closeDevFilesWatcher(),
                    null == serverFilesWatcher ? void 0 : serverFilesWatcher.close()
                ]);
            }
        };
    }
    async function watchDevFiles(devConfig, compileMiddlewareAPI, root) {
        let { watchFiles } = devConfig;
        if (!watchFiles) return;
        let watchers = [];
        for (let { paths, options, type } of castArray(watchFiles)){
            let watchOptions = prepareWatchOptions(paths, options, type), watcher = await startWatchFiles(watchOptions, compileMiddlewareAPI, root);
            watcher && watchers.push(watcher);
        }
        return async ()=>{
            for (let watcher of watchers)await watcher.close();
        };
    }
    function prepareWatchOptions(paths, options = {}, type) {
        return {
            paths: 'string' == typeof paths ? [
                paths
            ] : paths,
            options,
            type
        };
    }
    let GLOB_REGEX = /[*?{}[\]()!@+|]/, isGlob = (str)=>GLOB_REGEX.test(str);
    async function createChokidar(pathOrGlobs, root, options) {
        let chokidar = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/chokidar/index.js")), watchFiles = new Set(), globPatterns = pathOrGlobs.filter((pathOrGlob)=>!!isGlob(pathOrGlob) || (watchFiles.add(pathOrGlob), !1));
        if (globPatterns.length) {
            let tinyglobby = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/tinyglobby/index.js")), { glob } = tinyglobby.default || tinyglobby;
            for (let file of (await glob(globPatterns, {
                cwd: root,
                absolute: !0
            })))watchFiles.add(file);
        }
        return chokidar.watch(Array.from(watchFiles), options);
    }
    async function startWatchFiles({ paths, options, type = 'reload-page' }, compileMiddlewareAPI, root) {
        if ('reload-page' !== type) return;
        let watcher = await createChokidar(paths, root, options);
        return watcher.on('change', ()=>{
            compileMiddlewareAPI.sockWrite('static-changed');
        }), watcher;
    }
    let config_require = (0, external_node_module_namespaceObject.createRequire)(__rslib_import_meta_url__), getDefaultDevConfig = ()=>({
            hmr: !0,
            liveReload: !0,
            assetPrefix: DEFAULT_ASSET_PREFIX,
            writeToDisk: !1,
            cliShortcuts: !1,
            client: {
                path: '/rsbuild-hmr',
                port: '',
                host: '',
                overlay: !0,
                reconnect: 100
            }
        }), getDefaultServerConfig = ()=>({
            port: 3000,
            host: DEFAULT_DEV_HOST,
            open: !1,
            base: '/',
            htmlFallback: 'index',
            compress: !0,
            printUrls: !0,
            strictPort: !1,
            cors: !0
        }), getDefaultSourceConfig = ()=>({
            alias: {},
            define: {},
            preEntry: [],
            decorators: {
                version: '2022-03'
            }
        }), getDefaultHtmlConfig = ()=>({
            meta: {
                charset: {
                    charset: 'UTF-8'
                },
                viewport: 'width=device-width, initial-scale=1.0'
            },
            title: 'Rsbuild App',
            inject: 'head',
            mountId: 'root',
            crossorigin: !1,
            outputStructure: 'flat',
            scriptLoading: 'defer'
        }), getDefaultSecurityConfig = ()=>({
            nonce: '',
            sri: {
                enable: !1
            }
        }), getDefaultToolsConfig = ()=>({
            cssExtract: {
                loaderOptions: {},
                pluginOptions: {
                    ignoreOrder: !0
                }
            }
        }), getDefaultPerformanceConfig = ()=>({
            profile: !1,
            buildCache: !0,
            printFileSize: !0,
            removeConsole: !1,
            removeMomentLocale: !1,
            chunkSplit: {
                strategy: 'split-by-experience'
            }
        }), getDefaultOutputConfig = ()=>({
            target: 'web',
            cleanDistPath: 'auto',
            distPath: {
                root: ROOT_DIST_DIR,
                css: 'static/css',
                svg: 'static/svg',
                font: 'static/font',
                html: './',
                wasm: 'static/wasm',
                image: 'static/image',
                media: 'static/media',
                assets: 'static/assets'
            },
            assetPrefix: DEFAULT_ASSET_PREFIX,
            filename: {},
            charset: 'utf8',
            polyfill: 'off',
            dataUriLimit: {
                svg: 4096,
                font: 4096,
                image: 4096,
                media: 4096,
                assets: 4096
            },
            legalComments: 'linked',
            injectStyles: !1,
            minify: !0,
            manifest: !1,
            sourceMap: {
                js: void 0,
                css: !1
            },
            filenameHash: !0,
            inlineScripts: !1,
            inlineStyles: !1,
            cssModules: {
                auto: !0,
                namedExport: !1,
                exportGlobals: !1,
                exportLocalsConvention: 'camelCase'
            },
            emitAssets: !0
        }), getDefaultResolveConfig = ()=>(!swcHelpersPath && (swcHelpersPath = (0, external_node_path_.dirname)(config_require.resolve('@swc/helpers/package.json'))), {
            alias: {
                '@swc/helpers': swcHelpersPath
            },
            aliasStrategy: 'prefer-tsconfig',
            extensions: [
                '.ts',
                '.tsx',
                '.mjs',
                '.js',
                '.jsx',
                '.json'
            ]
        }), createDefaultConfig = ()=>({
            dev: getDefaultDevConfig(),
            server: getDefaultServerConfig(),
            html: getDefaultHtmlConfig(),
            resolve: getDefaultResolveConfig(),
            source: getDefaultSourceConfig(),
            output: getDefaultOutputConfig(),
            tools: getDefaultToolsConfig(),
            security: getDefaultSecurityConfig(),
            performance: getDefaultPerformanceConfig(),
            environments: {}
        }), withDefaultConfig = async (rootPath, config)=>{
        var _merged_server, _config_dev, _config_output;
        let merged = mergeRsbuildConfig(createDefaultConfig(), config);
        if (merged.root ||= rootPath, merged.source ||= {}, (null === (_merged_server = merged.server) || void 0 === _merged_server ? void 0 : _merged_server.base) && ((null === (_config_dev = config.dev) || void 0 === _config_dev ? void 0 : _config_dev.assetPrefix) === void 0 && (merged.dev ||= {}, merged.dev.assetPrefix = merged.server.base), (null === (_config_output = config.output) || void 0 === _config_output ? void 0 : _config_output.assetPrefix) === void 0 && (merged.output ||= {}, merged.output.assetPrefix = merged.server.base)), !merged.source.tsconfigPath) {
            let tsconfigPath = (0, external_node_path_.join)(rootPath, 'tsconfig.json');
            await isFileExists(tsconfigPath) && (merged.source.tsconfigPath = tsconfigPath);
        }
        return merged;
    }, normalizeConfig = (config)=>mergeRsbuildConfig({
            ...createDefaultConfig(),
            mode: (()=>{
                if (config.mode) return config.mode;
                let nodeEnv = getNodeEnv();
                return 'production' === nodeEnv || 'development' === nodeEnv ? nodeEnv : 'none';
            })()
        }, config);
    function defineConfig(config) {
        return config;
    }
    let resolveConfigPath = (root, customConfig)=>{
        if (customConfig) {
            let customConfigPath = (0, external_node_path_.isAbsolute)(customConfig) ? customConfig : (0, external_node_path_.join)(root, customConfig);
            if (external_node_fs_default().existsSync(customConfigPath)) return customConfigPath;
            rslog_index_js_namespaceObject.logger.warn(`Cannot find config file: ${index_js_default().dim(customConfigPath)}\n`);
        }
        for (let file of [
            'rsbuild.config.mjs',
            'rsbuild.config.ts',
            'rsbuild.config.js',
            'rsbuild.config.cjs',
            'rsbuild.config.mts',
            'rsbuild.config.cts'
        ]){
            let configFile = (0, external_node_path_.join)(root, file);
            if (external_node_fs_default().existsSync(configFile)) return configFile;
        }
        return null;
    };
    async function watchFilesForRestart(files, root, isBuildWatch, watchOptions) {
        var func;
        let timeoutId;
        if (!files.length) return;
        let watcher = await createChokidar(files, root, {
            ignoreInitial: !0,
            ignorePermissionErrors: !0,
            ...watchOptions
        });
        let callback = (func = async (filePath)=>{
            watcher.close(), isBuildWatch ? await restartBuild({
                filePath
            }) : await restartDevServer({
                filePath
            });
        }, timeoutId = null, (...args)=>{
            null !== timeoutId && clearTimeout(timeoutId), timeoutId = setTimeout(()=>{
                func(...args);
            }, 300);
        });
        watcher.on('add', callback), watcher.on('change', callback), watcher.on('unlink', callback);
    }
    async function config_loadConfig({ cwd = process.cwd(), path, envMode, meta } = {}) {
        let configExport;
        let configFilePath = resolveConfigPath(cwd, path);
        if (!configFilePath) return {
            content: {},
            filePath: configFilePath
        };
        let applyMetaInfo = (config)=>(config._privateMeta = {
                configFilePath
            }, config);
        if (/\.(?:js|mjs|cjs)$/.test(configFilePath)) try {
            let exportModule = await import(`${configFilePath}?t=${Date.now()}`);
            configExport = exportModule.default ? exportModule.default : exportModule;
        } catch (err) {
            rslog_index_js_namespaceObject.logger.debug(`Failed to load file with dynamic import: ${index_js_default().dim(configFilePath)}`);
        }
        try {
            if (void 0 === configExport) {
                let { default: jiti } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../compiled/jiti/index.js"));
                configExport = jiti(constants_filename, {
                    esmResolve: !0,
                    requireCache: !1,
                    interopDefault: !0
                })(configFilePath);
            }
        } catch (err) {
            throw rslog_index_js_namespaceObject.logger.error(`Failed to load file with jiti: ${index_js_default().dim(configFilePath)}`), err;
        }
        if ('function' == typeof configExport) {
            let command = process.argv[2], nodeEnv = getNodeEnv(), result = await configExport({
                env: nodeEnv,
                command,
                envMode: envMode || nodeEnv,
                meta
            });
            if (void 0 === result) throw Error('[rsbuild:loadConfig] The config function must return a config object.');
            return {
                content: applyMetaInfo(result),
                filePath: configFilePath
            };
        }
        if (!isObject(configExport)) throw Error(`[rsbuild:loadConfig] The config must be an object or a function that returns an object, get ${index_js_default().yellow(configExport)}`);
        return {
            content: applyMetaInfo(configExport),
            filePath: configFilePath
        };
    }
    let normalizePluginObject = (plugin)=>{
        let { setup: _, ...rest } = plugin;
        return {
            ...rest,
            setup () {}
        };
    }, getRsbuildInspectConfig = ({ normalizedConfig, inspectOptions, pluginManager })=>{
        let { environments, ...rsbuildConfig } = normalizedConfig, rawRsbuildConfig = stringifyConfig({
            ...rsbuildConfig,
            plugins: pluginManager.getPlugins().map(normalizePluginObject)
        }, inspectOptions.verbose), environmentConfigs = {}, rawEnvironmentConfigs = [];
        for (let [name, config] of Object.entries(environments)){
            let debugConfig = {
                ...config,
                plugins: pluginManager.getPlugins({
                    environment: name
                }).map(normalizePluginObject)
            };
            rawEnvironmentConfigs.push({
                name,
                content: stringifyConfig(debugConfig, inspectOptions.verbose)
            }), environmentConfigs[name] = debugConfig;
        }
        return {
            rsbuildConfig,
            rawRsbuildConfig,
            environmentConfigs: environments,
            rawEnvironmentConfigs
        };
    };
    async function outputInspectConfigFiles({ rawBundlerConfigs, rawEnvironmentConfigs, inspectOptions, configType }) {
        let { outputPath } = inspectOptions, files = [
            ...rawEnvironmentConfigs.map(({ name, content })=>{
                if (1 === rawEnvironmentConfigs.length) return {
                    path: (0, external_node_path_.join)(outputPath, 'rsbuild.config.mjs'),
                    label: 'Rsbuild Config',
                    content
                };
                let outputFile = `rsbuild.config.${name}.mjs`;
                return {
                    path: (0, external_node_path_.join)(outputPath, outputFile),
                    label: `Rsbuild Config (${name})`,
                    content
                };
            }),
            ...rawBundlerConfigs.map(({ name, content })=>{
                let outputFile = `${configType}.config.${name}.mjs`, outputFilePath = (0, external_node_path_.join)(outputPath, outputFile);
                return external_node_fs_default().existsSync(outputFilePath) && (outputFilePath = outputFilePath.replace(/\.mjs$/, `.${Date.now()}.mjs`)), {
                    path: outputFilePath,
                    label: `${upperFirst(configType)} Config (${name})`,
                    content
                };
            })
        ];
        await external_node_fs_default().promises.mkdir(outputPath, {
            recursive: !0
        }), await Promise.all(files.map(async (item)=>external_node_fs_default().promises.writeFile(item.path, `export default ${item.content}`)));
        let fileInfos = files.map((item)=>`  - ${index_js_default().bold(index_js_default().yellow(item.label))}: ${index_js_default().underline(item.path)}`).join('\n');
        rslog_index_js_namespaceObject.logger.success(`Inspect config succeed, open following files to view the content: \n\n${fileInfos}\n`);
    }
    function stringifyConfig(config, verbose) {
        return (0, rspack_chain_index_js_default().toString)(config, {
            verbose
        });
    }
    let normalizePublicDirs = (publicDir)=>{
        if (!1 === publicDir) return [];
        let defaultConfig = {
            name: 'public',
            copyOnBuild: !0,
            watch: !1
        };
        return void 0 === publicDir ? [
            defaultConfig
        ] : Array.isArray(publicDir) ? publicDir.map((options)=>({
                ...defaultConfig,
                ...options
            })) : [
            {
                ...defaultConfig,
                ...publicDir
            }
        ];
    }, RSBUILD_ALL_ENVIRONMENT_SYMBOL = 'RSBUILD_ALL_ENVIRONMENT_SYMBOL', isPluginMatchEnvironment = (pluginEnvironment, currentEnvironment)=>pluginEnvironment === currentEnvironment || pluginEnvironment === RSBUILD_ALL_ENVIRONMENT_SYMBOL, pluginDagSort = (plugins)=>{
        let allLines = [];
        function getPlugin(name) {
            let targets = plugins.filter((item)=>item.instance.name === name);
            if (!targets.length) throw Error(`[rsbuild:plugin] Plugin "${name}" not existed`);
            return targets;
        }
        for (let plugin of plugins){
            if (plugin.instance.pre) for (let pre of plugin.instance.pre)pre && plugins.some((item)=>item.instance.name === pre) && allLines.push([
                pre,
                plugin.instance.name
            ]);
            if (plugin.instance.post) for (let post of plugin.instance.post)post && plugins.some((item)=>item.instance.name === post) && allLines.push([
                plugin.instance.name,
                post
            ]);
        }
        let zeroEndPoints = plugins.filter((item)=>!allLines.find((l)=>l[1] === item.instance.name)), sortedPoint = [];
        for(; zeroEndPoints.length;){
            let zep = zeroEndPoints.shift();
            sortedPoint.push(...getPlugin(zep.instance.name)), allLines = allLines.filter((l)=>l[0] !== getPlugin(zep.instance.name)[0].instance.name), zeroEndPoints = plugins.filter((item)=>!sortedPoint.find((sp)=>sp.instance.name === item.instance.name)).filter((item)=>!allLines.find((l)=>l[1] === item.instance.name));
        }
        if (allLines.length) {
            let restInRingPoints = {};
            for (let l of allLines)restInRingPoints[l[0]] = !0, restInRingPoints[l[1]] = !0;
            throw Error(`[rsbuild:plugin] Plugins dependencies has loop: ${Object.keys(restInRingPoints).join(',')}`);
        }
        return sortedPoint;
    };
    async function initPlugins({ getPluginAPI, pluginManager }) {
        rslog_index_js_namespaceObject.logger.debug('init plugins');
        let plugins = pluginDagSort(pluginManager.getAllPluginsWithMeta()), removedPlugins = plugins.reduce((ret, plugin)=>(plugin.instance.remove && (ret[plugin.environment] ??= [], ret[plugin.environment].push(...plugin.instance.remove)), ret), {});
        for (let plugin of plugins){
            var _removedPlugins_plugin_environment, _removedPlugins_RSBUILD_ALL_ENVIRONMENT_SYMBOL;
            let isGlobalPlugin = 'RSBUILD_ALL_ENVIRONMENT_SYMBOL' === plugin.environment;
            if ((null === (_removedPlugins_plugin_environment = removedPlugins[plugin.environment]) || void 0 === _removedPlugins_plugin_environment ? void 0 : _removedPlugins_plugin_environment.includes(plugin.instance.name)) || !isGlobalPlugin && (null === (_removedPlugins_RSBUILD_ALL_ENVIRONMENT_SYMBOL = removedPlugins[RSBUILD_ALL_ENVIRONMENT_SYMBOL]) || void 0 === _removedPlugins_RSBUILD_ALL_ENVIRONMENT_SYMBOL ? void 0 : _removedPlugins_RSBUILD_ALL_ENVIRONMENT_SYMBOL.includes(plugin.instance.name))) continue;
            let { instance, environment } = plugin;
            await instance.setup(getPluginAPI(environment));
        }
        rslog_index_js_namespaceObject.logger.debug('init plugins done');
    }
    function createEnvironmentAsyncHook() {
        let preGroup = [], postGroup = [], defaultGroup = [], tapEnvironment = ({ environment, handler: cb })=>{
            isFunction(cb) ? defaultGroup.push({
                environment,
                handler: cb
            }) : 'pre' === cb.order ? preGroup.push({
                environment,
                handler: cb.handler
            }) : 'post' === cb.order ? postGroup.push({
                environment,
                handler: cb.handler
            }) : defaultGroup.push({
                environment,
                handler: cb.handler
            });
        };
        return {
            tapEnvironment,
            tap: (handler)=>tapEnvironment({
                    handler
                }),
            callInEnvironment: async ({ environment, args: params })=>{
                for (let callback of [
                    ...preGroup,
                    ...defaultGroup,
                    ...postGroup
                ]){
                    if (callback.environment && environment && !isPluginMatchEnvironment(callback.environment, environment)) continue;
                    let result = await callback.handler(...params);
                    void 0 !== result && (params[0] = result);
                }
                return params;
            }
        };
    }
    function createAsyncHook() {
        let preGroup = [], postGroup = [], defaultGroup = [];
        return {
            tap: (cb)=>{
                isFunction(cb) ? defaultGroup.push(cb) : 'pre' === cb.order ? preGroup.push(cb.handler) : 'post' === cb.order ? postGroup.push(cb.handler) : defaultGroup.push(cb.handler);
            },
            call: async (...params)=>{
                for (let callback of [
                    ...preGroup,
                    ...defaultGroup,
                    ...postGroup
                ]){
                    let result = await callback(...params);
                    void 0 !== result && (params[0] = result);
                }
                return params;
            }
        };
    }
    let onBeforeCompile = ({ compiler, beforeCompile, beforeEnvironmentCompiler, isWatch })=>{
        let name = 'rsbuild:beforeCompile';
        if (isMultiCompiler(compiler)) {
            let waitBeforeCompileDone;
            let { compilers } = compiler, doneCompilers = 0;
            for(let index = 0; index < compilers.length; index++){
                let compiler = compilers[index], compilerDone = !1;
                (isWatch ? compiler.hooks.watchRun : compiler.hooks.run).tapPromise(name, async ()=>{
                    !compilerDone && (compilerDone = !0, doneCompilers++), !waitBeforeCompileDone && (waitBeforeCompileDone = null == beforeCompile ? void 0 : beforeCompile()), await waitBeforeCompileDone, await beforeEnvironmentCompiler(index);
                }), compiler.hooks.invalid.tap(name, ()=>{
                    compilerDone && (compilerDone = !1, doneCompilers--), doneCompilers <= 0 && (waitBeforeCompileDone = void 0);
                });
            }
        } else (isWatch ? compiler.hooks.watchRun : compiler.hooks.run).tapPromise(name, async ()=>{
            await (null == beforeCompile ? void 0 : beforeCompile()), await beforeEnvironmentCompiler(0);
        });
    }, onCompileDone = ({ compiler, onDone, onEnvironmentDone, MultiStatsCtor })=>{
        if (isMultiCompiler(compiler)) {
            let { compilers } = compiler, compilerStats = [], doneCompilers = 0;
            for(let index = 0; index < compilers.length; index++){
                let compiler = compilers[index], compilerIndex = index, compilerDone = !1;
                compiler.hooks.done.tapPromise('rsbuild:done', async (stats)=>{
                    !compilerDone && (compilerDone = !0, doneCompilers++), compilerStats[compilerIndex] = stats;
                    let lastCompilerDone = doneCompilers === compilers.length;
                    await onEnvironmentDone(index, stats), lastCompilerDone && await onDone(new MultiStatsCtor(compilerStats));
                }), compiler.hooks.invalid.tap('rsbuild:done', ()=>{
                    compilerDone && (compilerDone = !1, doneCompilers--);
                });
            }
        } else compiler.hooks.done.tapPromise('rsbuild:done', async (stats)=>{
            await onEnvironmentDone(0, stats), await onDone(stats);
        });
    }, registerBuildHook = ({ context, isWatch, compiler, bundlerConfigs, MultiStatsCtor })=>{
        let isFirstCompile = !0, environmentList = Object.values(context.environments).reduce((prev, curr)=>(prev[curr.index] = curr, prev), []), onDone = async (stats)=>{
            let p = context.hooks.onAfterBuild.call({
                isFirstCompile,
                stats,
                environments: context.environments,
                isWatch
            });
            isFirstCompile = !1, await p;
        }, onEnvironmentDone = async (buildIndex, stats)=>{
            await context.hooks.onAfterEnvironmentCompile.callInEnvironment({
                environment: environmentList[buildIndex].name,
                args: [
                    {
                        isFirstCompile,
                        stats,
                        environment: environmentList[buildIndex],
                        isWatch
                    }
                ]
            });
        };
        onBeforeCompile({
            compiler,
            beforeCompile: async ()=>await context.hooks.onBeforeBuild.call({
                    bundlerConfigs,
                    environments: context.environments,
                    isWatch,
                    isFirstCompile
                }),
            beforeEnvironmentCompiler: async (buildIndex)=>await context.hooks.onBeforeEnvironmentCompile.callInEnvironment({
                    environment: environmentList[buildIndex].name,
                    args: [
                        {
                            bundlerConfig: null == bundlerConfigs ? void 0 : bundlerConfigs[buildIndex],
                            environment: environmentList[buildIndex],
                            isWatch,
                            isFirstCompile
                        }
                    ]
                }),
            isWatch
        }), onCompileDone({
            compiler,
            onDone,
            onEnvironmentDone,
            MultiStatsCtor
        });
    }, registerDevHook = ({ context, compiler, bundlerConfigs, MultiStatsCtor })=>{
        let isFirstCompile = !0, environmentList = Object.values(context.environments).reduce((prev, curr)=>(prev[curr.index] = curr, prev), []), onDone = async (stats)=>{
            let p = context.hooks.onDevCompileDone.call({
                isFirstCompile,
                stats,
                environments: context.environments
            });
            isFirstCompile = !1, await p;
        }, onEnvironmentDone = async (buildIndex, stats)=>{
            await context.hooks.onAfterEnvironmentCompile.callInEnvironment({
                environment: environmentList[buildIndex].name,
                args: [
                    {
                        isFirstCompile,
                        stats,
                        environment: environmentList[buildIndex],
                        isWatch: !0
                    }
                ]
            });
        };
        onBeforeCompile({
            compiler,
            beforeEnvironmentCompiler: async (buildIndex)=>await context.hooks.onBeforeEnvironmentCompile.callInEnvironment({
                    environment: environmentList[buildIndex].name,
                    args: [
                        {
                            bundlerConfig: null == bundlerConfigs ? void 0 : bundlerConfigs[buildIndex],
                            environment: environmentList[buildIndex],
                            isWatch: !0,
                            isFirstCompile
                        }
                    ]
                }),
            isWatch: !0
        }), onCompileDone({
            compiler,
            onDone,
            onEnvironmentDone,
            MultiStatsCtor
        });
    }, mapProcessAssetsStage = (compiler, stage)=>{
        let { Compilation } = compiler.webpack;
        switch(stage){
            case 'additional':
                return Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL;
            case 'pre-process':
                return Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS;
            case 'derived':
                return Compilation.PROCESS_ASSETS_STAGE_DERIVED;
            case 'additions':
                return Compilation.PROCESS_ASSETS_STAGE_ADDITIONS;
            case 'none':
                return Compilation.PROCESS_ASSETS_STAGE_NONE;
            case 'optimize':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE;
            case 'optimize-count':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT;
            case 'optimize-compatibility':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY;
            case 'optimize-size':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE;
            case 'dev-tooling':
                return Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING;
            case 'optimize-inline':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE;
            case 'summarize':
                return Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE;
            case 'optimize-hash':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH;
            case 'optimize-transfer':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER;
            case 'analyse':
                return Compilation.PROCESS_ASSETS_STAGE_ANALYSE;
            case 'report':
                return Compilation.PROCESS_ASSETS_STAGE_REPORT;
            default:
                throw Error(`[rsbuild] Invalid process assets stage: ${stage}`);
        }
    }, browsersListCache = new Map();
    async function getBrowserslist(path) {
        let env = process.env.NODE_ENV, cacheKey = path + env;
        if (browsersListCache.has(cacheKey)) return browsersListCache.get(cacheKey);
        let result = function(opts) {
            if (opts.config) return pickEnv(parsePackageOrReadConfig(opts.config), opts);
            if (opts.path) {
                let config = function(from) {
                    let resolved;
                    let fromDir = isFile(from = external_node_path_.resolve(from)) ? external_node_path_.dirname(from) : from;
                    if (fromDir in configCache) return configCache[fromDir];
                    let configFile = eachParent(from, (dir)=>{
                        let pkgBrowserslist;
                        let config = external_node_path_.join(dir, 'browserslist'), pkg = external_node_path_.join(dir, 'package.json'), rc = external_node_path_.join(dir, '.browserslistrc');
                        if (isFile(pkg)) try {
                            pkgBrowserslist = parsePackage(pkg);
                        } catch (e) {
                            if (e instanceof BrowserslistError) throw e;
                            console.warn(`[Browserslist] Could not parse ${pkg}. Ignoring it.`);
                        }
                        if (isFile(config) && pkgBrowserslist) throw new BrowserslistError(`${dir} contains both browserslist and package.json with browsers`);
                        if (isFile(rc) && pkgBrowserslist) throw new BrowserslistError(`${dir} contains both .browserslistrc and package.json with browsers`);
                        if (isFile(config) && isFile(rc)) throw new BrowserslistError(`${dir} contains both .browserslistrc and browserslist`);
                        return isFile(config) ? config : isFile(rc) ? rc : pkgBrowserslist ? pkg : void 0;
                    });
                    configFile && (resolved = parsePackageOrReadConfig(configFile));
                    let configDir = configFile && external_node_path_.dirname(configFile);
                    return eachParent(from, (dir)=>{
                        if (resolved && (configCache[dir] = resolved), dir === configDir) return null;
                    }), resolved;
                }(opts.path);
                if (!config) return;
                return pickEnv(config, opts);
            }
        }({
            path,
            env
        });
        return result ? (browsersListCache.set(cacheKey, result), result) : null;
    }
    async function getBrowserslistByEnvironment(path, config) {
        let { target, overrideBrowserslist } = config.output;
        if (Array.isArray(overrideBrowserslist)) return overrideBrowserslist;
        if ('web' === target || 'web-worker' === target) {
            let browserslistrc = await getBrowserslist(path);
            if (browserslistrc) return browserslistrc;
        }
        return DEFAULT_BROWSERSLIST[target];
    }
    let getEnvironmentHTMLPaths = (entry, config)=>'web' !== config.output.target || !1 === config.tools.htmlPlugin ? {} : Object.keys(entry).reduce((prev, key)=>{
            let entryValue = entry[key];
            return ('string' == typeof entryValue || Array.isArray(entryValue) || !1 !== entryValue.html) && (prev[key] = function(entryName, config) {
                let filename;
                filename = config.output.filename.html ? config.output.filename.html.replace('[name]', entryName) : 'flat' === config.html.outputStructure ? `${entryName}.html` : `${entryName}/index.html`;
                let prefix = config.output.distPath.html;
                return prefix.startsWith('/') && rslog_index_js_namespaceObject.logger.warn(`Absolute path is not recommended at \`output.distPath.html\`: "${prefix}", please use relative path instead.`), removeLeadingSlash(external_node_path_.posix.join(prefix, filename));
            }(key, config)), prev;
        }, {});
    async function updateEnvironmentContext(context, configs) {
        for (let [index, [name, config]] of (context.environments ||= {}, Object.entries(configs).entries())){
            let tsconfigPath = config.source.tsconfigPath ? getAbsolutePath(context.rootPath, config.source.tsconfigPath) : void 0, browserslist = await getBrowserslistByEnvironment(context.rootPath, config), entry = config.source.entry ?? {}, htmlPaths = getEnvironmentHTMLPaths(entry, config), environmentContext = {
                index,
                name,
                distPath: function(cwd, config) {
                    var _config_output_distPath, _config_output;
                    return getAbsolutePath(cwd, (null === (_config_output = config.output) || void 0 === _config_output ? void 0 : null === (_config_output_distPath = _config_output.distPath) || void 0 === _config_output_distPath ? void 0 : _config_output_distPath.root) ?? ROOT_DIST_DIR);
                }(context.rootPath, config),
                entry,
                browserslist,
                htmlPaths,
                tsconfigPath,
                config
            };
            context.environments[name] = new Proxy(environmentContext, {
                get: (target, prop)=>target[prop],
                set: (_, prop)=>(rslog_index_js_namespaceObject.logger.error(`EnvironmentContext is readonly, you can not assign to the "environment.${prop}" prop.`), !0)
            });
        }
    }
    async function createContext(options, userConfig, bundlerType) {
        let { cwd } = options, rootPath = userConfig.root ? getAbsolutePath(cwd, userConfig.root) : cwd, rsbuildConfig = await withDefaultConfig(rootPath, userConfig), cachePath = (0, external_node_path_.join)(rootPath, 'node_modules', '.cache');
        return {
            version: "1.1.13",
            rootPath,
            distPath: '',
            cachePath,
            bundlerType,
            environments: {},
            hooks: {
                onExit: createAsyncHook(),
                onCloseBuild: createAsyncHook(),
                onAfterBuild: createAsyncHook(),
                onBeforeBuild: createAsyncHook(),
                onDevCompileDone: createAsyncHook(),
                onCloseDevServer: createAsyncHook(),
                onAfterStartDevServer: createAsyncHook(),
                onBeforeStartDevServer: createAsyncHook(),
                onAfterStartProdServer: createAsyncHook(),
                onBeforeStartProdServer: createAsyncHook(),
                onAfterCreateCompiler: createAsyncHook(),
                onBeforeCreateCompiler: createAsyncHook(),
                modifyHTMLTags: createEnvironmentAsyncHook(),
                modifyRspackConfig: createEnvironmentAsyncHook(),
                modifyBundlerChain: createEnvironmentAsyncHook(),
                modifyWebpackChain: createEnvironmentAsyncHook(),
                modifyWebpackConfig: createEnvironmentAsyncHook(),
                modifyRsbuildConfig: createAsyncHook(),
                modifyEnvironmentConfig: createEnvironmentAsyncHook(),
                onBeforeEnvironmentCompile: createEnvironmentAsyncHook(),
                onAfterEnvironmentCompile: createEnvironmentAsyncHook()
            },
            config: {
                ...rsbuildConfig
            },
            originalConfig: userConfig,
            specifiedEnvironments: options.environment
        };
    }
    let external_node_util_namespaceObject = require("node:util"), mrmime_index_js_namespaceObject = require("../compiled/mrmime/index.js"), pluginAppIcon = ()=>({
            name: 'rsbuild:app-icon',
            setup (api) {
                let htmlTagsMap = new Map(), iconFormatMap = new Map(), formatIcon = (icon, distDir, publicPath)=>{
                    let { src, size } = icon, cached = iconFormatMap.get(src);
                    if (cached) return {
                        ...cached,
                        ...icon
                    };
                    let sizes = `${size}x${size}`;
                    if (isURL(src)) {
                        let paths = {
                            sizes,
                            isURL: !0,
                            requestPath: src,
                            absolutePath: src,
                            relativePath: src,
                            mimeType: (0, mrmime_index_js_namespaceObject.lookup)(src)
                        };
                        return iconFormatMap.set(src, paths), {
                            ...paths,
                            ...icon
                        };
                    }
                    let absolutePath = external_node_path_default().isAbsolute(src) ? src : external_node_path_default().join(api.context.rootPath, src), relativePath = external_node_path_default().posix.join(distDir, external_node_path_default().basename(absolutePath)), paths = {
                        sizes,
                        requestPath: ensureAssetPrefix(relativePath, publicPath),
                        absolutePath,
                        relativePath,
                        mimeType: (0, mrmime_index_js_namespaceObject.lookup)(absolutePath)
                    };
                    return iconFormatMap.set(src, paths), {
                        ...paths,
                        ...icon
                    };
                };
                api.processAssets({
                    stage: 'additional'
                }, async ({ compilation, environment, sources })=>{
                    let { config } = environment, { appIcon } = config.html;
                    if (!appIcon) return;
                    let distDir = config.output.distPath.image, manifestFile = appIcon.filename ?? 'manifest.webmanifest', publicPath = getPublicPathFromCompiler(compilation), icons = appIcon.icons.map((icon)=>formatIcon(icon, distDir, publicPath)), tags = [];
                    for (let icon of icons){
                        if ('web-app-manifest' === icon.target && !appIcon.name) throw Error("[rsbuild:app-icon] `appIcon.name` is required when `target` is 'web-app-manifest'.");
                        if (!icon.isURL) {
                            if (!compilation.inputFileSystem) throw Error("[rsbuild:app-icon] 'compilation.inputFileSystem' is not available.");
                            if (!await fileExistsByCompilation(compilation, icon.absolutePath)) throw Error(`[rsbuild:app-icon] Can not find the app icon, please check if the '${icon.relativePath}' file exists'.`);
                            let source = await (0, external_node_util_namespaceObject.promisify)(compilation.inputFileSystem.readFile)(icon.absolutePath);
                            if (!source) throw Error(`[rsbuild:app-icon] Failed to read the app icon file, please check if the '${icon.relativePath}' file exists'.`);
                            compilation.emitAsset(icon.relativePath, new sources.RawSource(source));
                        }
                        ('apple-touch-icon' === icon.target || !icon.target && icon.size < 200) && tags.push({
                            tag: 'link',
                            attrs: {
                                rel: 'apple-touch-icon',
                                sizes: icon.sizes,
                                href: icon.requestPath
                            }
                        });
                    }
                    if (appIcon.name) {
                        let manifestIcons = icons.filter((icon)=>'web-app-manifest' === icon.target || !icon.target).map((icon)=>{
                            let result = {
                                src: icon.requestPath,
                                sizes: icon.sizes
                            };
                            return icon.mimeType ? {
                                ...result,
                                type: icon.mimeType
                            } : result;
                        }), manifest = {
                            name: appIcon.name,
                            icons: manifestIcons
                        };
                        compilation.emitAsset(manifestFile, new sources.RawSource(JSON.stringify(manifest))), tags.push({
                            tag: 'link',
                            attrs: {
                                rel: 'manifest',
                                href: ensureAssetPrefix(manifestFile, publicPath)
                            }
                        });
                    }
                    tags.length && htmlTagsMap.set(environment.name, tags);
                }), api.modifyHTMLTags(({ headTags, bodyTags }, { environment })=>{
                    let tags = htmlTagsMap.get(environment.name);
                    return tags && headTags.unshift(...tags), {
                        headTags,
                        bodyTags
                    };
                }), api.onCloseDevServer(()=>{
                    htmlTagsMap.clear(), iconFormatMap.clear();
                });
            }
        }), chainStaticAssetRule = ({ emit, rule, maxSize, filename, assetType })=>{
        let generatorOptions = {
            filename
        };
        !1 === emit && (generatorOptions.emit = !1), rule.oneOf(`${assetType}-asset-url`).type('asset/resource').resourceQuery(/(__inline=false|url)/).set('generator', generatorOptions), rule.oneOf(`${assetType}-asset-inline`).type('asset/inline').resourceQuery(/inline/), rule.oneOf(`${assetType}-asset`).type('asset').parser({
            dataUrlCondition: {
                maxSize
            }
        }).set('generator', generatorOptions);
    }, pluginAsset = ()=>({
            name: 'rsbuild:asset',
            setup (api) {
                api.modifyBundlerChain((chain, { isProd, environment })=>{
                    let { config } = environment, getMergedFilename = (assetType)=>{
                        let distDir = config.output.distPath[assetType], filename = getFilename(config, assetType, isProd);
                        return external_node_path_default().posix.join(distDir, filename);
                    }, createAssetRule = (assetType, exts, emit)=>{
                        let regExp = function(exts) {
                            let matcher = exts.map((ext)=>ext.trim()).map((ext)=>ext.startsWith('.') ? ext.slice(1) : ext).join('|');
                            return RegExp(1 === exts.length ? `\\.${matcher}$` : `\\.(?:${matcher})$`, 'i');
                        }(exts), { dataUriLimit } = config.output, maxSize = 'number' == typeof dataUriLimit ? dataUriLimit : dataUriLimit[assetType];
                        chainStaticAssetRule({
                            emit,
                            rule: chain.module.rule(assetType).test(regExp),
                            maxSize,
                            filename: getMergedFilename(assetType),
                            assetType
                        });
                    }, { emitAssets } = config.output;
                    createAssetRule('image', IMAGE_EXTENSIONS, emitAssets), createAssetRule('svg', [
                        'svg'
                    ], emitAssets), createAssetRule('media', [
                        ...VIDEO_EXTENSIONS,
                        ...AUDIO_EXTENSIONS
                    ], emitAssets), createAssetRule('font', FONT_EXTENSIONS, emitAssets);
                    let assetsFilename = getMergedFilename('assets');
                    chain.output.assetModuleFilename(assetsFilename), !emitAssets && chain.module.generator.merge({
                        'asset/resource': {
                            emit: !1
                        }
                    });
                    let { assetsInclude } = config.source;
                    if (assetsInclude) {
                        let { dataUriLimit } = config.output, rule = chain.module.rule('additional-assets').test(assetsInclude);
                        chainStaticAssetRule({
                            emit: emitAssets,
                            rule,
                            maxSize: 'number' == typeof dataUriLimit ? dataUriLimit : dataUriLimit.assets,
                            filename: assetsFilename,
                            assetType: 'additional'
                        });
                    }
                });
            }
        }), getJsSourceMap = (config)=>{
        let { sourceMap } = config.output, isProd = 'production' === config.mode;
        return !1 !== sourceMap && (!0 === sourceMap ? isProd ? 'source-map' : 'cheap-module-source-map' : void 0 === sourceMap.js ? !isProd && 'cheap-module-source-map' : sourceMap.js);
    }, pluginBasic = ()=>({
            name: 'rsbuild:basic',
            setup (api) {
                api.modifyBundlerChain((chain, { env, isDev, target, bundler, environment, CHAIN_ID })=>{
                    let { config } = environment;
                    chain.name(environment.name), chain.devtool(getJsSourceMap(config)), chain.context(api.context.rootPath), chain.mode(environment.config.mode), chain.merge({
                        infrastructureLogging: {
                            level: 'error'
                        }
                    }), chain.watchOptions({
                        ignored: /[\\/](?:\.git|node_modules)[\\/]/,
                        aggregateTimeout: 0
                    }), chain.performance.hints(!1), chain.module.parser.merge({
                        javascript: {
                            exportsPresence: 'error'
                        }
                    }), isDev && config.dev.hmr && 'web' === target && chain.plugin(CHAIN_ID.PLUGIN.HMR).use(bundler.HotModuleReplacementPlugin), 'development' === env && chain.output.devtoolModuleFilenameTemplate((info)=>external_node_path_default().resolve(info.absoluteResourcePath).replace(/\\/g, '/')), process.env.RSPACK_CONFIG_VALIDATE ||= 'loose-unrecognized-keys', process.env.WATCHPACK_WATCHER_LIMIT ||= '20', process.env.EXPERIMENTAL_RSPACK_INCREMENTAL && chain.experiments({
                        ...chain.get('experiments'),
                        incremental: isDev
                    });
                });
            }
        }), isUseAnalyzer = (config)=>{
        var _config_performance;
        return process.env.BUNDLE_ANALYZE || (null === (_config_performance = config.performance) || void 0 === _config_performance ? void 0 : _config_performance.bundleAnalyze);
    }, external_node_crypto_namespaceObject = require("node:crypto");
    var external_node_crypto_default = __webpack_require__.n(external_node_crypto_namespaceObject);
    async function validateCache(cacheDirectory, buildDependencies) {
        let configFile = (0, external_node_path_.join)(cacheDirectory, 'buildDependencies.json');
        if (await isFileExists(configFile)) {
            if (JSON.stringify(JSON.parse(await external_node_fs_default().promises.readFile(configFile, 'utf-8'))) === JSON.stringify(buildDependencies)) return;
            await external_node_fs_default().promises.rm(cacheDirectory, {
                force: !0,
                recursive: !0
            });
        }
        await external_node_fs_default().promises.mkdir(cacheDirectory, {
            recursive: !0
        }), await external_node_fs_default().promises.writeFile(configFile, JSON.stringify(buildDependencies));
    }
    async function getBuildDependencies(context, config, environmentContext) {
        var _config__privateMeta;
        let rootPackageJson = (0, external_node_path_.join)(context.rootPath, 'package.json'), browserslistConfig = (0, external_node_path_.join)(context.rootPath, '.browserslistrc'), buildDependencies = {};
        await isFileExists(rootPackageJson) && (buildDependencies.packageJson = [
            rootPackageJson
        ]);
        let { tsconfigPath } = environmentContext;
        tsconfigPath && (buildDependencies.tsconfig = [
            tsconfigPath
        ]), (null === (_config__privateMeta = config._privateMeta) || void 0 === _config__privateMeta ? void 0 : _config__privateMeta.configFilePath) && (buildDependencies.rsbuildConfig = [
            config._privateMeta.configFilePath
        ]), await isFileExists(browserslistConfig) && (buildDependencies.browserslistrc = [
            browserslistConfig
        ]);
        let tailwindConfig = findExists([
            'ts',
            'js',
            'cjs',
            'mjs'
        ].map((ext)=>(0, external_node_path_.join)(context.rootPath, `tailwind.config.${ext}`)));
        return tailwindConfig && (buildDependencies.tailwindcss = [
            tailwindConfig
        ]), buildDependencies;
    }
    let pluginCache = ()=>({
            name: 'rsbuild:cache',
            setup (api) {
                if ('rspack' !== api.context.bundlerType) api.modifyBundlerChain(async (chain, { environment, env })=>{
                    var digest;
                    let { config } = environment, { buildCache } = config.performance;
                    if (!1 === buildCache) {
                        chain.cache(!1);
                        return;
                    }
                    let { context } = api, cacheConfig = 'boolean' == typeof buildCache ? {} : buildCache, cacheDirectory = function({ cacheDirectory }, context) {
                        return cacheDirectory ? (0, external_node_path_.isAbsolute)(cacheDirectory) ? cacheDirectory : (0, external_node_path_.join)(context.rootPath, cacheDirectory) : (0, external_node_path_.join)(context.cachePath, context.bundlerType);
                    }(cacheConfig, context), buildDependencies = await getBuildDependencies(context, config, environment);
                    await validateCache(cacheDirectory, buildDependencies);
                    let useDigest = Array.isArray(cacheConfig.cacheDigest) && cacheConfig.cacheDigest.length;
                    chain.cache({
                        name: useDigest ? `${environment.name}-${env}-${digest = cacheConfig.cacheDigest, external_node_crypto_default().createHash('md5').update(JSON.stringify(digest)).digest('hex').slice(0, 8)}` : `${environment.name}-${env}`,
                        type: 'filesystem',
                        cacheDirectory,
                        buildDependencies
                    });
                });
            }
        }), addTrailingSep = (dir)=>dir.endsWith(external_node_path_.sep) ? dir : dir + external_node_path_.sep, isStrictSubdir = (parent, child)=>{
        let parentDir = addTrailingSep(parent), childDir = addTrailingSep(child);
        return parentDir !== childDir && childDir.startsWith(parentDir);
    }, dedupeCleanPaths = (paths)=>paths.sort((p1, p2)=>p2.length > p1.length ? -1 : 1).reduce((prev, curr)=>prev.find((p)=>curr.startsWith(p) || curr === p) ? prev : prev.concat(curr), []), pluginCleanOutput = ()=>({
            name: 'rsbuild:clean-output',
            setup (api) {
                let getRsbuildCleanPath = ()=>{
                    let { rootPath, distPath } = api.context, config = api.getNormalizedConfig(), cleanPath = (0, external_node_path_.join)(distPath, RSBUILD_OUTPUTS_PATH), { cleanDistPath } = config.output;
                    if (!0 === cleanDistPath || 'auto' === cleanDistPath && isStrictSubdir(rootPath, cleanPath)) return cleanPath;
                }, getCleanPath = (environment)=>{
                    let { rootPath } = api.context, { config, distPath } = environment, { cleanDistPath } = config.output;
                    if ('auto' === cleanDistPath && !(cleanDistPath = isStrictSubdir(rootPath, distPath)) && (rslog_index_js_namespaceObject.logger.warn('The dist path is not a subdir of root path, Rsbuild will not empty it.'), rslog_index_js_namespaceObject.logger.warn(`Please set ${index_js_default().yellow('`output.cleanDistPath`')} config manually.`), rslog_index_js_namespaceObject.logger.warn(`Current root path: ${index_js_default().dim(rootPath)}`), rslog_index_js_namespaceObject.logger.warn(`Current dist path: ${index_js_default().dim(distPath)}`)), cleanDistPath) return distPath;
                }, cleanAll = async (params)=>{
                    let cleanPaths = Object.values(params.environments).reduce((total, curr)=>(!total.find((t)=>t.distPath === curr.distPath) && total.push(curr), total), []).map((e)=>getCleanPath(e)).concat(getRsbuildCleanPath()).filter((p)=>!!p);
                    await Promise.all(dedupeCleanPaths(cleanPaths).map((p)=>emptyDir(p)));
                };
                api.onBeforeBuild(async ({ isFirstCompile, environments })=>{
                    isFirstCompile && await cleanAll({
                        environments
                    });
                }), api.onBeforeStartDevServer(cleanAll);
            }
        }), dist_isNil = (o)=>null == o, dist_isFunction = (func)=>'function' == typeof func, dist_isObject = (obj)=>null !== obj && 'object' == typeof obj, dist_isPlainObject = (obj)=>dist_isObject(obj) && '[object Object]' === Object.prototype.toString.call(obj);
    function reduceConfigs({ initial, config, mergeFn = Object.assign }) {
        return dist_isNil(config) ? initial : dist_isPlainObject(config) ? dist_isPlainObject(initial) ? mergeFn(initial, config) : config : dist_isFunction(config) ? config(initial) ?? initial : Array.isArray(config) ? config.reduce((initial, config)=>reduceConfigs({
                initial,
                config,
                mergeFn
            }), initial) : config ?? initial;
    }
    function reduceConfigsWithContext({ initial, config, ctx, mergeFn = Object.assign }) {
        return dist_isNil(config) ? initial : dist_isPlainObject(config) ? dist_isPlainObject(initial) ? mergeFn(initial, config) : config : dist_isFunction(config) ? config(initial, ctx) ?? initial : Array.isArray(config) ? config.reduce((initial, config)=>reduceConfigsWithContext({
                initial,
                config,
                ctx,
                mergeFn
            }), initial) : config ?? initial;
    }
    async function reduceConfigsAsyncWithContext({ initial, config, ctx, mergeFn = Object.assign }) {
        return dist_isNil(config) ? initial : dist_isPlainObject(config) ? dist_isPlainObject(initial) ? mergeFn(initial, config) : config : dist_isFunction(config) ? await config(initial, ctx) ?? initial : Array.isArray(config) ? config.reduce((initial, config)=>reduceConfigsWithContext({
                initial,
                config,
                ctx,
                mergeFn
            }), initial) : config ?? initial;
    }
    function reduceConfigsMergeContext({ initial, config, ctx, mergeFn = Object.assign }) {
        return dist_isNil(config) ? initial : dist_isPlainObject(config) ? dist_isPlainObject(initial) ? mergeFn(initial, config) : config : dist_isFunction(config) ? config({
            value: initial,
            ...ctx
        }) ?? initial : Array.isArray(config) ? config.reduce((initial, config)=>reduceConfigsMergeContext({
                initial,
                config,
                ctx,
                mergeFn
            }), initial) : config ?? initial;
    }
    let getCSSModulesLocalIdentName = (config, isProd)=>config.output.cssModules.localIdentName || (isProd ? '[local]-[hash:base64:6]' : '[path][name]__[local]-[hash:base64:6]'), normalizeCssLoaderOptions = (options, exportOnlyLocals)=>{
        if (options.modules && exportOnlyLocals) {
            let { modules } = options;
            return modules = !0 === modules ? {
                exportOnlyLocals: !0
            } : 'string' == typeof modules ? {
                mode: modules,
                exportOnlyLocals: !0
            } : {
                ...modules,
                exportOnlyLocals: !0
            }, {
                ...options,
                modules
            };
        }
        return options;
    }, userPostcssrcCache = new Map(), clonePostCSSConfig = (config)=>({
            ...config,
            plugins: config.plugins ? [
                ...config.plugins
            ] : void 0
        }), getCSSSourceMap = (config)=>{
        let { sourceMap } = config.output;
        return 'boolean' == typeof sourceMap ? sourceMap : sourceMap.css;
    };
    async function loadUserPostcssrc(root) {
        let cached = userPostcssrcCache.get(root);
        if (cached) return clonePostCSSConfig(await cached);
        let { default: postcssrc } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/postcss-load-config/index.js")), promise = postcssrc({}, root).catch((err)=>{
            var _err_message;
            if (null === (_err_message = err.message) || void 0 === _err_message ? void 0 : _err_message.includes('No PostCSS Config found')) return {};
            throw err;
        });
        return userPostcssrcCache.set(root, promise), promise.then((config)=>(userPostcssrcCache.set(root, config), clonePostCSSConfig(config)));
    }
    let isPostcssPluginCreator = (plugin)=>'function' == typeof plugin && !0 === plugin.postcss, getPostcssLoaderOptions = async ({ config, root })=>{
        let extraPlugins = [], userOptions = await loadUserPostcssrc(root);
        userOptions.plugins ||= [];
        let finalOptions = reduceConfigsWithContext({
            initial: {
                implementation: getCompiledPath('postcss'),
                postcssOptions: userOptions,
                sourceMap: getCSSSourceMap(config)
            },
            config: config.tools.postcss,
            ctx: {
                addPlugins (plugins) {
                    extraPlugins.push(...castArray(plugins));
                }
            }
        });
        finalOptions.postcssOptions ||= {};
        let updatePostcssOptions = (options)=>(options.plugins ||= [], extraPlugins.length && options.plugins.push(...extraPlugins), options.plugins = options.plugins.map((plugin)=>isPostcssPluginCreator(plugin) ? plugin() : plugin), options.config = !1, options), { postcssOptions } = finalOptions;
        if ('function' == typeof postcssOptions) {
            let postcssOptionsWrapper = (loaderContext)=>{
                let options = postcssOptions(loaderContext);
                if ('object' != typeof options || null === options) throw Error(`[rsbuild:css] \`postcssOptions\` function must return a PostCSSOptions object, got "${typeof options}".`);
                return updatePostcssOptions({
                    ...userOptions,
                    ...options,
                    plugins: [
                        ...userOptions.plugins || [],
                        ...options.plugins || []
                    ]
                });
            };
            return postcssOptionsWrapper.config = !1, {
                ...finalOptions,
                postcssOptions: postcssOptionsWrapper
            };
        }
        return finalOptions.postcssOptions = updatePostcssOptions(postcssOptions), finalOptions;
    }, getCSSLoaderOptions = ({ config, importLoaders, localIdentName, emitCss })=>{
        let { cssModules } = config.output;
        return normalizeCssLoaderOptions(reduceConfigs({
            initial: {
                importLoaders,
                modules: {
                    ...cssModules,
                    localIdentName
                },
                sourceMap: getCSSSourceMap(config)
            },
            config: config.tools.cssLoader,
            mergeFn: cjs_default()
        }), !emitCss);
    }, pluginCss = ()=>({
            name: 'rsbuild:css',
            setup (api) {
                api.modifyBundlerChain({
                    order: 'pre',
                    handler: async (chain, { target, isProd, CHAIN_ID, environment })=>{
                        let rule = chain.module.rule(CHAIN_ID.RULE.CSS), { config } = environment;
                        rule.test(CSS_REGEX).type('javascript/auto').dependency({
                            not: 'url'
                        });
                        let emitCss = config.output.emitCss ?? 'web' === target;
                        if (emitCss) {
                            if (config.output.injectStyles) {
                                let styleLoaderOptions = reduceConfigs({
                                    initial: {},
                                    config: config.tools.styleLoader
                                });
                                rule.use(CHAIN_ID.USE.STYLE).loader(getCompiledPath('style-loader')).options(styleLoaderOptions);
                            } else rule.use(CHAIN_ID.USE.MINI_CSS_EXTRACT).loader(getCssExtractPlugin().loader).options(config.tools.cssExtract.loaderOptions);
                        } else rule.use(CHAIN_ID.USE.IGNORE_CSS).loader(external_node_path_default().join(LOADER_PATH, 'ignoreCssLoader.mjs'));
                        let importLoaders = 0;
                        if (rule.use(CHAIN_ID.USE.CSS).loader(getCompiledPath('css-loader')), emitCss) {
                            var _postcssLoaderOptions_postcssOptions_plugins, _postcssLoaderOptions_postcssOptions;
                            if ('rspack' === api.context.bundlerType && !1 !== config.tools.lightningcssLoader) {
                                importLoaders++;
                                let userOptions = !0 === config.tools.lightningcssLoader ? {} : config.tools.lightningcssLoader, initialOptions = {
                                    targets: environment.browserslist
                                };
                                'production' === config.mode && config.output.injectStyles && (initialOptions.minify = !0);
                                let loaderOptions = reduceConfigs({
                                    initial: initialOptions,
                                    config: userOptions
                                });
                                rule.use(CHAIN_ID.USE.LIGHTNINGCSS).loader('builtin:lightningcss-loader').options(loaderOptions);
                            }
                            let postcssLoaderOptions = await getPostcssLoaderOptions({
                                config,
                                root: api.context.rootPath
                            });
                            ('function' == typeof postcssLoaderOptions.postcssOptions || (null === (_postcssLoaderOptions_postcssOptions = postcssLoaderOptions.postcssOptions) || void 0 === _postcssLoaderOptions_postcssOptions ? void 0 : null === (_postcssLoaderOptions_postcssOptions_plugins = _postcssLoaderOptions_postcssOptions.plugins) || void 0 === _postcssLoaderOptions_postcssOptions_plugins ? void 0 : _postcssLoaderOptions_postcssOptions_plugins.length)) && (importLoaders++, rule.use(CHAIN_ID.USE.POSTCSS).loader(getCompiledPath('postcss-loader')).options(postcssLoaderOptions));
                        }
                        let localIdentName = getCSSModulesLocalIdentName(config, isProd), cssLoaderOptions = getCSSLoaderOptions({
                            config,
                            importLoaders,
                            localIdentName,
                            emitCss
                        });
                        rule.use(CHAIN_ID.USE.CSS).options(cssLoaderOptions), rule.merge({
                            sideEffects: !0
                        }), rule.resolve.preferRelative(!0);
                    }
                });
            }
        }), pluginDefine = ()=>({
            name: 'rsbuild:define',
            setup (api) {
                api.modifyBundlerChain((chain, { CHAIN_ID, bundler, environment })=>{
                    let { config } = environment, baseUrl = JSON.stringify(config.server.base), assetPrefix = JSON.stringify(getPublicPathFromChain(chain, !1)), builtinVars = {
                        'import.meta.env.MODE': JSON.stringify(config.mode),
                        'import.meta.env.DEV': 'development' === config.mode,
                        'import.meta.env.PROD': 'production' === config.mode,
                        'import.meta.env.BASE_URL': baseUrl,
                        'import.meta.env.ASSET_PREFIX': assetPrefix,
                        'process.env.BASE_URL': baseUrl,
                        'process.env.ASSET_PREFIX': assetPrefix
                    };
                    chain.plugin(CHAIN_ID.PLUGIN.DEFINE).use(bundler.DefinePlugin, [
                        {
                            ...builtinVars,
                            ...config.source.define
                        }
                    ]);
                });
            }
        }), pluginEntry = ()=>({
            name: 'rsbuild:entry',
            setup (api) {
                api.modifyBundlerChain(async (chain, { environment, isServer })=>{
                    let { config, entry } = environment, { preEntry } = config.source, injectCoreJsEntry = 'entry' === config.output.polyfill && !isServer;
                    for (let entryName of Object.keys(entry)){
                        let entryPoint = chain.entry(entryName), addEntry = (item)=>{
                            if ('object' == typeof item && 'html' in item) {
                                let { html, ...rest } = item;
                                entryPoint.add(rest);
                            } else entryPoint.add(item);
                        };
                        preEntry.forEach(addEntry), injectCoreJsEntry && addEntry(createVirtualModule('import "core-js";')), castArray(entry[entryName]).forEach(addEntry);
                    }
                }), api.onBeforeCreateCompiler(({ bundlerConfigs })=>{
                    if (bundlerConfigs.every((config)=>!config.entry)) throw Error(`[rsbuild:config] Could not find any entry module, please make sure that ${index_js_default().cyan('src/index.(ts|js|tsx|jsx|mjs|cjs)')} exists, or customize entry through the ${index_js_default().cyan('source.entry')} configuration.`);
                });
            }
        }), external_node_zlib_namespaceObject = require("node:zlib");
    var external_node_zlib_default = __webpack_require__.n(external_node_zlib_namespaceObject);
    let fileSize_gzip = (0, external_node_util_namespaceObject.promisify)(external_node_zlib_default().gzip);
    async function gzipSize(input) {
        return (await fileSize_gzip(input)).length;
    }
    let excludeAsset = (asset)=>/\.(?:map|LICENSE\.txt)$/.test(asset.name), getAssetColor = (size)=>size > 300000 ? index_js_default().red : size > 100000 ? index_js_default().yellow : index_js_default().green, calcFileSize = (len)=>{
        let val = len / 1000;
        return `${val.toFixed(val < 1 ? 2 : 1)} kB`;
    }, coloringAssetName = (assetName)=>JS_REGEX.test(assetName) ? index_js_default().cyan(assetName) : CSS_REGEX.test(assetName) ? index_js_default().yellow(assetName) : HTML_REGEX.test(assetName) ? index_js_default().green(assetName) : index_js_default().magenta(assetName);
    async function printFileSizes(options, stats, rootPath, environmentName) {
        let logs = [];
        if (!1 === options.detail && !1 === options.total) return logs;
        let formatAsset = async (asset, distPath, distFolder)=>{
            let fileName = asset.name.split('?')[0], contents = await external_node_fs_default().promises.readFile(external_node_path_default().join(distPath, fileName)), size = contents.length, gzippedSize = options.compressed ? await gzipSize(contents) : null, gzipSizeLabel = gzippedSize ? getAssetColor(gzippedSize)(calcFileSize(gzippedSize)) : null;
            return {
                size,
                folder: external_node_path_default().join(distFolder, external_node_path_default().dirname(fileName)),
                name: external_node_path_default().basename(fileName),
                gzippedSize,
                sizeLabel: calcFileSize(size),
                gzipSizeLabel
            };
        }, getAssets = async ()=>{
            let distPath = stats.compilation.outputOptions.path;
            if (!distPath) return [];
            let origin = stats.toJson({
                all: !1,
                assets: !0,
                cachedAssets: !0,
                groupAssetsByInfo: !1,
                groupAssetsByPath: !1,
                groupAssetsByChunk: !1,
                groupAssetsByExtension: !1,
                groupAssetsByEmitStatus: !1
            }), exclude = options.exclude ?? excludeAsset, filteredAssets = origin.assets.filter((asset)=>{
                let assetInfo = {
                    name: asset.name,
                    size: asset.size
                };
                return !exclude(assetInfo) && (!options.include || options.include(assetInfo));
            }), distFolder = external_node_path_default().relative(rootPath, distPath);
            return Promise.all(filteredAssets.map((asset)=>formatAsset(asset, distPath, distFolder)));
        }, assets = await getAssets();
        if (0 === assets.length) return logs;
        logs.push(''), assets.sort((a, b)=>a.size - b.size);
        let longestLabelLength = Math.max(...assets.map((a)=>a.sizeLabel.length)), longestFileLength = Math.max(...assets.map((a)=>(a.folder + external_node_path_default().sep + a.name).length));
        !1 !== options.detail && logs.push(function(longestFileLength, longestLabelLength, options, environmentName) {
            let longestLengths = [
                longestFileLength,
                longestLabelLength
            ], rowTypes = [
                `File (${environmentName})`,
                'Size'
            ];
            options.compressed && rowTypes.push('Gzip');
            let headerRow = rowTypes.reduce((prev, cur, index)=>{
                let length = longestLengths[index], curLabel = cur;
                return length && (curLabel = cur.length < length ? cur + ' '.repeat(length - cur.length) : cur), `${prev + curLabel}    `;
            }, '  ');
            return index_js_default().blue(headerRow);
        }(longestFileLength, longestLabelLength, options, environmentName));
        let totalSize = 0, totalGzipSize = 0;
        for (let asset of assets){
            let { sizeLabel } = asset, { name, folder, gzipSizeLabel } = asset, fileNameLength = (folder + external_node_path_default().sep + name).length, sizeLength = sizeLabel.length;
            if (totalSize += asset.size, asset.gzippedSize && (totalGzipSize += asset.gzippedSize), !1 !== options.detail) {
                sizeLength < longestLabelLength && (sizeLabel += ' '.repeat(longestLabelLength - sizeLength));
                let fileNameLabel = index_js_default().dim(asset.folder + external_node_path_default().sep) + coloringAssetName(asset.name);
                fileNameLength < longestFileLength && (fileNameLabel += ' '.repeat(longestFileLength - fileNameLength));
                let log = `  ${fileNameLabel}    ${sizeLabel}`;
                gzipSizeLabel && (log += `    ${gzipSizeLabel}`), logs.push(log);
            }
        }
        if (!1 !== options.total && assets.length > 1) {
            let totalSizeLabel = `${index_js_default().blue('Total:')} ${calcFileSize(totalSize)}`, log = `\n  ${totalSizeLabel}`;
            options.compressed && (log += index_js_default().dim(` (gzip: ${calcFileSize(totalGzipSize)})`)), logs.push(log);
        }
        return logs.push(''), logs;
    }
    let pluginFileSize = ()=>({
            name: 'rsbuild:file-size',
            setup (api) {
                api.onAfterBuild(async ({ stats, environments, isFirstCompile })=>{
                    if (!stats || stats.hasErrors() || !isFirstCompile) return;
                    let logs = [];
                    await Promise.all(Object.values(environments).map(async (environment, index)=>{
                        let { printFileSize } = environment.config.performance;
                        if (!1 === printFileSize) return;
                        let multiStats = 'stats' in stats ? stats.stats : [
                            stats
                        ], defaultConfig = {
                            total: !0,
                            detail: !0,
                            compressed: 'node' !== environment.config.output.target
                        }, mergedConfig = !0 === printFileSize ? defaultConfig : {
                            ...defaultConfig,
                            ...printFileSize
                        }, statsLogs = await printFileSizes(mergedConfig, multiStats[index], api.context.rootPath, environment.name);
                        logs.length && logs.push(index_js_default().dim('  -----')), logs.push(...statsLogs);
                    })).catch((err)=>{
                        rslog_index_js_namespaceObject.logger.warn('Failed to print file size.'), rslog_index_js_namespaceObject.logger.warn(err);
                    }), rslog_index_js_namespaceObject.logger.log(logs.join('\n'));
                });
            }
        });
    function RsbuildHtmlPlugin_define_property(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    let VOID_TAGS = [
        'area',
        'base',
        'br',
        'col',
        'embed',
        'hr',
        'img',
        'input',
        'keygen',
        'link',
        'meta',
        'param',
        'source',
        'track',
        'wbr'
    ], HEAD_TAGS = [
        'title',
        'base',
        'link',
        'style',
        'meta',
        'script',
        'noscript',
        'template'
    ], FILE_ATTRS = {
        link: 'href',
        script: 'src'
    }, hasTitle = (html)=>!!html && /<title/i.test(html) && /<\/title/i.test(html), getTagPriority = (tag, tagConfig)=>{
        let priority = tag.head ?? HEAD_TAGS.includes(tag.tag) ? -2 : 2, append = tag.append ?? tagConfig.append;
        return 'boolean' == typeof append && (priority += append ? 1 : -1), priority;
    }, formatBasicTag = (tag)=>({
            tag: tag.tagName,
            attrs: tag.attributes,
            children: tag.innerHTML
        }), fromBasicTag = (tag)=>({
            meta: {},
            tagName: tag.tag,
            attributes: tag.attrs ?? {},
            voidTag: VOID_TAGS.includes(tag.tag),
            innerHTML: tag.children
        }), formatTags = (tags, override)=>tags.map((tag)=>({
                ...formatBasicTag(tag),
                publicPath: !1,
                ...override
            })), applyTagConfig = (data, tagConfig, compilationHash, entryName)=>{
        var _tagConfig_tags;
        if (!(null === (_tagConfig_tags = tagConfig.tags) || void 0 === _tagConfig_tags ? void 0 : _tagConfig_tags.length)) return data;
        let fromInjectTags = (tags)=>{
            let ret = [];
            for (let tag of tags){
                let attrs = {
                    ...tag.attrs
                }, filenameTag = FILE_ATTRS[tag.tag], filename = attrs[filenameTag];
                if ('string' == typeof filename) {
                    let optPublicPath = tag.publicPath ?? tagConfig.publicPath;
                    'function' == typeof optPublicPath ? filename = optPublicPath(filename, data.publicPath) : 'string' == typeof optPublicPath ? filename = ensureAssetPrefix(filename, optPublicPath) : !1 !== optPublicPath && (filename = ensureAssetPrefix(filename, data.publicPath));
                    let optHash = tag.hash ?? tagConfig.hash;
                    'function' == typeof optHash ? compilationHash.length && (filename = optHash(filename, compilationHash)) : 'string' == typeof optHash ? optHash.length && (filename = `${filename}?${optHash}`) : !0 === optHash && compilationHash.length && (filename = `${filename}?${compilationHash}`), attrs[filenameTag] = filename, tag.attrs = attrs;
                }
                ret.push(fromBasicTag(tag));
            }
            return ret;
        }, tags = [
            ...formatTags(data.headTags, {
                head: !0
            }),
            ...formatTags(data.bodyTags, {
                head: !1
            })
        ], context = {
            hash: compilationHash,
            entryName,
            outputName: data.outputName,
            publicPath: data.publicPath
        };
        for (let item of tagConfig.tags)isFunction(item) ? tags = item(tags, context) || tags : tags.push(item), tags = tags.sort((tag1, tag2)=>getTagPriority(tag1, tagConfig) - getTagPriority(tag2, tagConfig));
        let [headTags, bodyTags] = function(array, predicate) {
            let truthy = [], falsy = [];
            for (let value of array)predicate(value) ? truthy.push(value) : falsy.push(value);
            return [
                truthy,
                falsy
            ];
        }(tags, (tag)=>tag.head ?? HEAD_TAGS.includes(tag.tag));
        return data.headTags = fromInjectTags(headTags), data.bodyTags = fromInjectTags(bodyTags), data;
    }, addTitleTag = (headTags, title = '')=>{
        '' !== title && void 0 !== title && headTags.unshift({
            tagName: 'title',
            innerHTML: title,
            attributes: {},
            voidTag: !1,
            meta: {}
        });
    };
    class RsbuildHtmlPlugin {
        apply(compiler) {
            let emitFavicon = async (compilation, favicon)=>{
                let name = external_node_path_default().basename(favicon);
                if (compilation.assets[name]) return name;
                if (!compilation.inputFileSystem) throw Error("[rsbuild:html] 'compilation.inputFileSystem' is not available.");
                let filename = external_node_path_default().resolve(compilation.compiler.context, favicon), buf = await (0, external_node_util_namespaceObject.promisify)(compilation.inputFileSystem.readFile)(filename);
                if (!buf) throw Error(`[rsbuild:html] Failed to read the favicon, please check if the '${filename}' file exists'.`);
                let source = new compiler.webpack.sources.RawSource(buf, !1);
                return compilation.emitAsset(name, source), name;
            }, addFavicon = async (headTags, favicon, compilation, publicPath)=>{
                let href = favicon;
                !isURL(favicon) && (href = ensureAssetPrefix(await emitFavicon(compilation, favicon), publicPath));
                let tag = {
                    tagName: 'link',
                    voidTag: !0,
                    attributes: {
                        rel: 'icon',
                        href
                    },
                    meta: {}
                };
                href.endsWith('.svg') && (tag.attributes.type = 'image/svg+xml'), headTags.unshift(tag);
            };
            compiler.hooks.compilation.tap(this.name, (compilation)=>{
                getHTMLPlugin().getHooks(compilation).alterAssetTagGroups.tapPromise(this.name, async (data)=>{
                    var _data_plugin_options, _data_plugin_options1;
                    let entryName = null === (_data_plugin_options = data.plugin.options) || void 0 === _data_plugin_options ? void 0 : _data_plugin_options.entryName;
                    if (!entryName) return data;
                    let { headTags, bodyTags } = data, { favicon, tagConfig, templateContent } = this.options[entryName];
                    !hasTitle(templateContent) && addTitleTag(headTags, null === (_data_plugin_options1 = data.plugin.options) || void 0 === _data_plugin_options1 ? void 0 : _data_plugin_options1.title), favicon && await addFavicon(headTags, favicon, compilation, data.publicPath);
                    let tags = {
                        headTags: headTags.map(formatBasicTag),
                        bodyTags: bodyTags.map(formatBasicTag)
                    }, modified = this.modifyTagsFn ? await this.modifyTagsFn(tags, {
                        compiler,
                        compilation,
                        assetPrefix: data.publicPath,
                        filename: data.outputName,
                        environment: this.getEnvironment()
                    }) : tags;
                    return Object.assign(data, {
                        headTags: modified.headTags.map(fromBasicTag),
                        bodyTags: modified.bodyTags.map(fromBasicTag)
                    }), tagConfig && applyTagConfig(data, tagConfig, compilation.hash ?? '', entryName), data;
                });
            });
        }
        constructor(options, getEnvironment, modifyTagsFn){
            RsbuildHtmlPlugin_define_property(this, "name", void 0), RsbuildHtmlPlugin_define_property(this, "getEnvironment", void 0), RsbuildHtmlPlugin_define_property(this, "options", void 0), RsbuildHtmlPlugin_define_property(this, "modifyTagsFn", void 0), this.name = 'RsbuildHtmlPlugin', this.options = options, this.modifyTagsFn = modifyTagsFn, this.getEnvironment = getEnvironment;
        }
    }
    let getDefaultTemplateContent = (mountId)=>`<!doctype html><html><head></head><body><div id="${mountId}"></div></body></html>`, existTemplatePath = new Set();
    async function getTemplate(entryName, config, rootPath) {
        let templatePath = reduceConfigsMergeContext({
            initial: '',
            config: config.html.template,
            ctx: {
                entryName
            }
        });
        if (!templatePath) return {
            templatePath: void 0,
            templateContent: getDefaultTemplateContent(config.html.mountId)
        };
        let absolutePath = (0, external_node_path_.isAbsolute)(templatePath) ? templatePath : external_node_path_default().resolve(rootPath, templatePath);
        if (!existTemplatePath.has(absolutePath)) {
            if (!await isFileExists(absolutePath)) throw Error(`[rsbuild:html] Failed to resolve HTML template, please check if the file exists: ${index_js_default().cyan(absolutePath)}`);
            existTemplatePath.add(absolutePath);
        }
        let templateContent = await external_node_fs_default().promises.readFile(absolutePath, 'utf-8');
        return {
            templatePath: absolutePath,
            templateContent
        };
    }
    let getTagConfig = (config)=>{
        let tags = castArray(config.html.tags).filter(Boolean);
        if (!!tags.length) return {
            append: !0,
            hash: !1,
            publicPath: !0,
            tags
        };
    }, pluginHtml = (modifyTagsFn)=>({
            name: 'rsbuild:html',
            setup (api) {
                api.modifyBundlerChain(async (chain, { HtmlPlugin, CHAIN_ID, environment })=>{
                    let { config, htmlPaths } = environment;
                    if (0 === Object.keys(htmlPaths).length) return;
                    let assetPrefix = getPublicPathFromChain(chain, !1), entries = chain.entryPoints.entries() || {}, entryNames = Object.keys(entries).filter((entryName)=>!!htmlPaths[entryName]), htmlInfoMap = {}, finalOptions = await Promise.all(entryNames.map(async (entryName)=>{
                        var entryName1, entryName2, config1, assetPrefix1, entryName3, entryName4;
                        let entryValue = entries[entryName].values(), chunks = function(entryName, entryValue) {
                            let chunks = [
                                entryName
                            ];
                            for (let item of entryValue){
                                if (!isPlainObject(item)) continue;
                                let { dependOn } = item;
                                if (!!dependOn) 'string' == typeof dependOn ? chunks.unshift(dependOn) : chunks.unshift(...dependOn);
                            }
                            return chunks;
                        }(entryName, entryValue);
                        let inject = (entryName1 = entryName, reduceConfigsMergeContext({
                            initial: 'head',
                            config: config.html.inject,
                            ctx: {
                                entryName: entryName1
                            }
                        })), filename = htmlPaths[entryName], { templatePath, templateContent } = await getTemplate(entryName, config, api.context.rootPath);
                        let templateParameters = (entryName2 = entryName, config1 = config, assetPrefix1 = assetPrefix, (compilation, assets, assetTags, pluginOptions)=>{
                            let { mountId, templateParameters } = config1.html, rspackConfig = compilation.options, htmlPlugin = {
                                tags: assetTags,
                                files: assets,
                                options: pluginOptions
                            };
                            return reduceConfigsWithContext({
                                initial: {
                                    mountId,
                                    entryName: entryName2,
                                    assetPrefix: assetPrefix1,
                                    compilation,
                                    htmlPlugin,
                                    rspackConfig,
                                    webpackConfig: rspackConfig,
                                    htmlWebpackPlugin: htmlPlugin
                                },
                                config: templateParameters,
                                ctx: {
                                    entryName: entryName2
                                }
                            });
                        }), pluginOptions = {
                            meta: function(entryName, config, templateContent) {
                                let metaTags = reduceConfigsMergeContext({
                                    initial: {},
                                    config: config.html.meta,
                                    ctx: {
                                        entryName
                                    }
                                });
                                return templateContent && metaTags.charset && /<meta[^>]+charset=["'][^>]*>/i.test(templateContent) && delete metaTags.charset, metaTags;
                            }(entryName, config, templateContent),
                            chunks,
                            inject,
                            filename,
                            entryName,
                            templateParameters,
                            scriptLoading: config.html.scriptLoading
                        };
                        templatePath && (pluginOptions.template = templatePath), chunks.length > 1 && (pluginOptions.chunksSortMode = 'manual');
                        let htmlInfo = {};
                        htmlInfoMap[entryName] = htmlInfo, templateContent && (htmlInfo.templateContent = templateContent);
                        let tagConfig = getTagConfig(environment.config);
                        tagConfig && (htmlInfo.tagConfig = tagConfig), pluginOptions.title = (entryName3 = entryName, reduceConfigsMergeContext({
                            initial: '',
                            config: config.html.title,
                            ctx: {
                                entryName: entryName3
                            }
                        }));
                        let favicon = (entryName4 = entryName, reduceConfigsMergeContext({
                            initial: '',
                            config: config.html.favicon,
                            ctx: {
                                entryName: entryName4
                            }
                        }));
                        favicon && (htmlInfo.favicon = favicon);
                        let finalOptions = reduceConfigsWithContext({
                            initial: pluginOptions,
                            config: 'boolean' == typeof config.tools.htmlPlugin ? {} : config.tools.htmlPlugin,
                            ctx: {
                                entryName,
                                entryValue
                            }
                        });
                        return !finalOptions.template && !finalOptions.templateContent && (pluginOptions.template = '', pluginOptions.templateContent = templateContent), finalOptions;
                    }));
                    if (entryNames.forEach((entryName, index)=>{
                        chain.plugin(`${CHAIN_ID.PLUGIN.HTML}-${entryName}`).use(HtmlPlugin, [
                            finalOptions[index]
                        ]);
                    }), chain.plugin('rsbuild-html-plugin').use(RsbuildHtmlPlugin, [
                        htmlInfoMap,
                        ()=>environment,
                        null == modifyTagsFn ? void 0 : modifyTagsFn(environment.name)
                    ]), config.html) {
                        let { crossorigin } = config.html;
                        crossorigin && chain.output.crossOriginLoading(!0 === crossorigin ? 'anonymous' : crossorigin);
                    }
                }), api.modifyHTMLTags({
                    order: 'post',
                    handler: ({ headTags, bodyTags }, { environment })=>{
                        let { config } = environment, { crossorigin } = config.html, allTags = [
                            ...headTags,
                            ...bodyTags
                        ];
                        if (crossorigin) {
                            let formattedCrossorigin = !0 === crossorigin ? 'anonymous' : crossorigin;
                            for (let tag of allTags){
                                var _tag_attrs, _tag_attrs1;
                                ('script' === tag.tag && (null === (_tag_attrs = tag.attrs) || void 0 === _tag_attrs ? void 0 : _tag_attrs.src) || 'link' === tag.tag && (null === (_tag_attrs1 = tag.attrs) || void 0 === _tag_attrs1 ? void 0 : _tag_attrs1.rel) === 'stylesheet') && (tag.attrs.crossorigin ??= formattedCrossorigin);
                            }
                        }
                        return {
                            headTags,
                            bodyTags
                        };
                    }
                });
            }
        });
    function updateSourceMappingURL({ source, compilation, publicPath, type, config }) {
        let { devtool } = compilation.options;
        if (devtool && !devtool.includes('inline') && source.includes('# sourceMappingURL')) {
            let prefix = addTrailingSlash(external_node_path_default().join(publicPath, config.output.distPath[type] || ''));
            return source.replace(/# sourceMappingURL=/, `# sourceMappingURL=${prefix}`);
        }
        return source;
    }
    function matchTests(name, source, tests) {
        return tests.some((test)=>isFunction(test) ? test({
                name,
                size: source.length
            }) : test.exec(name));
    }
    let pluginInlineChunk = ()=>({
            name: 'rsbuild:inline-chunk',
            setup (api) {
                let inlinedAssets = new Set(), getInlinedScriptTag = (publicPath, tag, compilation, scriptTests, config)=>{
                    var _tag_attrs;
                    let { assets } = compilation;
                    if (!((null === (_tag_attrs = tag.attrs) || void 0 === _tag_attrs ? void 0 : _tag_attrs.src) && 'string' == typeof tag.attrs.src)) return tag;
                    let { src, ...otherAttrs } = tag.attrs, scriptName = publicPath ? src.replace(publicPath, '') : src, asset = assets[scriptName];
                    if (null == asset) return tag;
                    let source = asset.source().toString();
                    if (!matchTests(scriptName, source, scriptTests)) return tag;
                    let ret = {
                        tag: 'script',
                        children: updateSourceMappingURL({
                            source,
                            compilation,
                            publicPath,
                            type: 'js',
                            config
                        }),
                        attrs: {
                            ...otherAttrs
                        }
                    };
                    return inlinedAssets.add(scriptName), ret;
                }, getInlinedCSSTag = (publicPath, tag, compilation, styleTests, config)=>{
                    var _tag_attrs;
                    let { assets } = compilation;
                    if (!((null === (_tag_attrs = tag.attrs) || void 0 === _tag_attrs ? void 0 : _tag_attrs.href) && 'string' == typeof tag.attrs.href)) return tag;
                    let linkName = publicPath ? tag.attrs.href.replace(publicPath, '') : tag.attrs.href, asset = assets[linkName];
                    if (null == asset) return tag;
                    let source = asset.source().toString();
                    if (!matchTests(linkName, source, styleTests)) return tag;
                    let ret = {
                        tag: 'style',
                        children: updateSourceMappingURL({
                            source,
                            compilation,
                            publicPath,
                            type: 'css',
                            config
                        })
                    };
                    return inlinedAssets.add(linkName), ret;
                }, getInlinedTag = (publicPath, tag, compilation, scriptTests, styleTests, config)=>'script' === tag.tag ? getInlinedScriptTag(publicPath, tag, compilation, scriptTests, config) : 'link' === tag.tag && tag.attrs && 'stylesheet' === tag.attrs.rel ? getInlinedCSSTag(publicPath, tag, compilation, styleTests, config) : tag;
                api.processAssets({
                    stage: 'summarize'
                }, ({ compiler, compilation })=>{
                    if (0 === inlinedAssets.size) return;
                    let { devtool } = compiler.options;
                    for (let name of inlinedAssets)'hidden-source-map' === devtool ? compilation.deleteAsset(name) : delete compilation.assets[name];
                    inlinedAssets.clear();
                }), api.modifyHTMLTags(({ headTags, bodyTags }, { compiler, compilation, environment })=>{
                    let { htmlPaths, config } = environment;
                    if (0 === Object.keys(htmlPaths).length) return {
                        headTags,
                        bodyTags
                    };
                    let { inlineStyles, inlineScripts } = config.output, scriptTests = [], styleTests = [], isProdMode = 'production' === environment.config.mode;
                    if (inlineScripts && (!0 === inlineScripts ? isProdMode && scriptTests.push(JS_REGEX) : (0, types_namespaceObject.isRegExp)(inlineScripts) || isFunction(inlineScripts) ? isProdMode && scriptTests.push(inlineScripts) : ('auto' === inlineScripts.enable ? isProdMode : inlineScripts.enable) && scriptTests.push(inlineScripts.test)), inlineStyles && (!0 === inlineStyles ? isProdMode && styleTests.push(CSS_REGEX) : (0, types_namespaceObject.isRegExp)(inlineStyles) || isFunction(inlineStyles) ? isProdMode && styleTests.push(inlineStyles) : ('auto' === inlineStyles.enable ? isProdMode : inlineStyles.enable) && styleTests.push(inlineStyles.test)), !scriptTests.length && !styleTests.length) return {
                        headTags,
                        bodyTags
                    };
                    let publicPath = getPublicPathFromCompiler(compiler), updateTag = (tag)=>getInlinedTag(publicPath, tag, compilation, scriptTests, styleTests, environment.config);
                    return {
                        headTags: headTags.map(updateTag),
                        bodyTags: bodyTags.map(updateTag)
                    };
                });
            }
        }), pluginLazyCompilation = ()=>({
            name: 'rsbuild:lazy-compilation',
            setup (api) {
                api.modifyBundlerChain((chain, { environment, isProd, target })=>{
                    var _config_dev;
                    if (isProd || 'web' !== target) return;
                    let { config } = environment, options = null === (_config_dev = config.dev) || void 0 === _config_dev ? void 0 : _config_dev.lazyCompilation;
                    if (!!options) chain.experiments({
                        ...chain.get('experiments'),
                        lazyCompilation: options
                    });
                });
            }
        });
    function isAsync(chunk) {
        return 'canBeInitial' in chunk ? !chunk.canBeInitial() : 'isInitial' in chunk && !chunk.isInitial();
    }
    function recursiveChunkEntryNames(chunk) {
        let [...chunkGroups] = chunk.groupsIterable;
        return [
            ...new Set(chunkGroups.flatMap((chunkGroup)=>(function recursiveChunkGroup(chunkGroup) {
                    let parents = chunkGroup.getParents();
                    return parents.length ? parents.flatMap((chunkParent)=>recursiveChunkGroup(chunkParent)) : [
                        chunkGroup.name
                    ];
                })(chunkGroup)).filter((name)=>!!name))
        ];
    }
    let generateManifest = (htmlPaths)=>(_seed, files)=>{
            let chunkEntries = new Map(), licenseMap = new Map(), allFiles = files.map((file)=>{
                if (file.chunk) for (let name of recursiveChunkEntryNames(file.chunk))chunkEntries.set(name, [
                    file,
                    ...chunkEntries.get(name) || []
                ]);
                if (file.path.endsWith('.LICENSE.txt')) {
                    let sourceFilePath = file.path.split('.LICENSE.txt')[0];
                    licenseMap.set(sourceFilePath, file.path);
                }
                return file.path;
            }), entries = {};
            for (let [name, chunkFiles] of chunkEntries){
                var _files_find;
                let assets = new Set(), initialJS = [], asyncJS = [], initialCSS = [], asyncCSS = [];
                for (let file of chunkFiles){
                    file.isInitial ? file.path.endsWith('.css') ? initialCSS.push(file.path) : initialJS.push(file.path) : file.path.endsWith('.css') ? asyncCSS.push(file.path) : asyncJS.push(file.path);
                    let relatedLICENSE = licenseMap.get(file.path);
                    for (let auxiliaryFile of (relatedLICENSE && assets.add(relatedLICENSE), file.chunk.auxiliaryFiles))assets.add(auxiliaryFile);
                }
                let entryManifest = {};
                assets.size && (entryManifest.assets = Array.from(assets));
                let htmlPath = null === (_files_find = files.find((f)=>f.name === htmlPaths[name])) || void 0 === _files_find ? void 0 : _files_find.path;
                htmlPath && (entryManifest.html = [
                    htmlPath
                ]), initialJS.length && (entryManifest.initial = {
                    js: initialJS
                }), initialCSS.length && (entryManifest.initial = {
                    ...entryManifest.initial || {},
                    css: initialCSS
                }), asyncJS.length && (entryManifest.async = {
                    js: asyncJS
                }), asyncCSS.length && (entryManifest.async = {
                    ...entryManifest.async || {},
                    css: asyncCSS
                }), entries[name] = entryManifest;
            }
            return {
                allFiles,
                entries
            };
        }, pluginManifest = ()=>({
            name: 'rsbuild:manifest',
            setup (api) {
                api.modifyBundlerChain(async (chain, { CHAIN_ID, environment, isDev })=>{
                    let { output: { manifest }, dev: { writeToDisk } } = environment.config;
                    if (!1 === manifest) return;
                    let { RspackManifestPlugin } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/rspack-manifest-plugin/index.js")), { htmlPaths } = environment;
                    chain.plugin(CHAIN_ID.PLUGIN.MANIFEST).use(RspackManifestPlugin, [
                        {
                            fileName: 'string' == typeof manifest ? manifest : 'manifest.json',
                            writeToFileEmit: isDev && !0 !== writeToDisk,
                            generate: generateManifest(htmlPaths)
                        }
                    ]);
                });
            }
        }), getSwcMinimizerOptions = (config, jsOptions)=>{
        let options = {};
        options.minimizerOptions ||= {}, options.minimizerOptions.format ||= {};
        let { removeConsole } = config.performance;
        if (!0 === removeConsole) options.minimizerOptions.compress = {
            drop_console: !0
        };
        else if (Array.isArray(removeConsole)) {
            let pureFuncs = removeConsole.map((method)=>`console.${method}`);
            options.minimizerOptions.compress = {
                pure_funcs: pureFuncs
            };
        }
        switch(config.output.legalComments){
            case 'inline':
                options.minimizerOptions.format.comments = 'some', options.extractComments = !1;
                break;
            case 'linked':
                options.extractComments = !0;
                break;
            case 'none':
                options.minimizerOptions.format.comments = !1, options.extractComments = !1;
        }
        return (options.minimizerOptions.format.asciiOnly = 'ascii' === config.output.charset, jsOptions) ? cjs_default()(options, jsOptions) : options;
    }, parseMinifyOptions = (config, isProd)=>{
        let { minify } = config.output;
        return !1 !== minify && isProd ? !0 === minify ? {
            minifyJs: !0,
            minifyCss: !0
        } : {
            minifyJs: !1 !== minify.js,
            minifyCss: !1 !== minify.css,
            jsOptions: minify.jsOptions,
            cssOptions: minify.cssOptions
        } : {
            minifyJs: !1,
            minifyCss: !1
        };
    }, pluginMinimize = ()=>({
            name: 'rsbuild:minimize',
            setup (api) {
                let isRspack = 'rspack' === api.context.bundlerType;
                api.modifyBundlerChain(async (chain, { isProd, environment, CHAIN_ID })=>{
                    let { config } = environment, { minifyJs, minifyCss, jsOptions, cssOptions } = parseMinifyOptions(config, isProd);
                    if (chain.optimization.minimize(minifyJs || minifyCss), minifyJs && isRspack && chain.optimization.minimizer(CHAIN_ID.MINIMIZER.JS).use(core_namespaceObject.rspack.SwcJsMinimizerRspackPlugin, [
                        getSwcMinimizerOptions(config, jsOptions)
                    ]).end(), minifyCss && isRspack) {
                        let defaultOptions = {
                            minimizerOptions: {
                                targets: environment.browserslist
                            }
                        }, mergedOptions = cssOptions ? cjs_default()(defaultOptions, cssOptions) : defaultOptions;
                        chain.optimization.minimizer(CHAIN_ID.MINIMIZER.CSS).use(core_namespaceObject.rspack.LightningCssMinimizerRspackPlugin, [
                            mergedOptions
                        ]).end();
                    }
                });
            }
        });
    class PatchSplitChunksPlugin {
        apply(compiler) {
            let { splitChunks } = compiler.options.optimization;
            if (!splitChunks) return;
            let applyPatch = (cacheGroup)=>{
                if ('object' != typeof cacheGroup || (0, types_namespaceObject.isRegExp)(cacheGroup)) return;
                let { chunks } = cacheGroup;
                if (!!chunks && 'async' !== chunks) {
                    if ('function' == typeof chunks) {
                        cacheGroup.chunks = (chunk)=>(!chunk.name || chunk.name !== this.name) && chunks(chunk);
                        return;
                    }
                    if ('all' === chunks) {
                        cacheGroup.chunks = (chunk)=>(!chunk.name || chunk.name !== this.name) && !0;
                        return;
                    }
                    if ('initial' === chunks) {
                        cacheGroup.chunks = (chunk)=>(!chunk.name || chunk.name !== this.name) && chunk.isOnlyInitial();
                        return;
                    }
                }
            };
            applyPatch(splitChunks);
            let { cacheGroups } = splitChunks;
            if (!!cacheGroups) for (let cacheGroupKey of Object.keys(cacheGroups))applyPatch(cacheGroups[cacheGroupKey]);
        }
        constructor(name){
            !function(obj, key, value) {
                key in obj ? Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : obj[key] = value;
            }(this, "name", void 0), this.name = name;
        }
    }
    let pluginMoment = ()=>({
            name: 'rsbuild:moment',
            setup (api) {
                api.modifyBundlerChain(async (chain, { environment, bundler })=>{
                    let { config } = environment;
                    config.performance.removeMomentLocale && chain.plugin('remove-moment-locale').use(bundler.IgnorePlugin, [
                        {
                            resourceRegExp: /^\.\/locale$/,
                            contextRegExp: /moment$/
                        }
                    ]);
                });
            }
        }), nodeAddons_getFilename = (resourcePath)=>{
        let basename = '';
        if (resourcePath) {
            let parsed = external_node_path_default().parse(resourcePath);
            parsed.dir && (basename = parsed.name);
        }
        return basename ? `${basename}.node` : null;
    }, pluginNodeAddons = ()=>({
            name: 'rsbuild:node-addons',
            setup (api) {
                api.transform({
                    test: /\.node$/,
                    targets: [
                        'node'
                    ],
                    raw: !0
                }, ({ code, emitFile, resourcePath })=>{
                    let name = nodeAddons_getFilename(resourcePath);
                    if (null === name) throw Error(`[rsbuild:node-addons] Failed to load Node.js addon: "${resourcePath}"`);
                    return emitFile(name, code), `
try {
const path = require("path");
process.dlopen(module, path.join(__dirname, "${name}"));
} catch (error) {
throw new Error('Failed to load Node.js addon: "${name}"\\n' + error);
}
`;
                });
            }
        }), pluginNonce = ()=>({
            name: 'rsbuild:nonce',
            setup (api) {
                api.onAfterCreateCompiler(({ compiler, environments })=>{
                    let nonces = Object.values(environments).map((environment)=>{
                        let { nonce } = environment.config.security;
                        return nonce;
                    });
                    if (!nonces.some((nonce)=>!!nonce)) return;
                    let environmentList = Object.values(environments);
                    applyToCompiler(compiler, (compiler, index)=>{
                        let nonce = nonces[index], environment = environmentList.find((item)=>item.index === index);
                        if (!Object.keys((null == environment ? void 0 : environment.htmlPaths) ?? {}).length || !nonce) return;
                        let injectCode = createVirtualModule(`__webpack_nonce__ = "${nonce}";`);
                        new compiler.webpack.EntryPlugin(compiler.context, injectCode, {
                            name: void 0
                        }).apply(compiler);
                    });
                }), api.modifyHTMLTags({
                    order: 'post',
                    handler: ({ headTags, bodyTags }, { environment })=>{
                        let { config } = environment, { nonce } = config.security, allTags = [
                            ...headTags,
                            ...bodyTags
                        ];
                        if (nonce) for (let tag of allTags)('script' === tag.tag || 'style' === tag.tag) && (tag.attrs ??= {}, tag.attrs.nonce = nonce);
                        return {
                            headTags,
                            bodyTags
                        };
                    }
                });
            }
        });
    var external_node_child_process_ = __webpack_require__("node:child_process");
    let external_node_net_namespaceObject = require("node:net");
    var external_node_net_default = __webpack_require__.n(external_node_net_namespaceObject);
    let external_node_os_namespaceObject = require("node:os");
    var external_node_os_default = __webpack_require__.n(external_node_os_namespaceObject);
    let normalizeUrl = (url)=>url.replace(/([^:]\/)\/+/g, '$1'), formatPrefix = (input)=>{
        let prefix = input;
        if ((null == prefix ? void 0 : prefix.startsWith('./')) && (prefix = prefix.replace('./', '')), !prefix) return '/';
        let hasLeadingSlash = prefix.startsWith('/'), hasTailSlash = prefix.endsWith('/');
        return `${hasLeadingSlash ? '' : '/'}${prefix}${hasTailSlash ? '' : '/'}`;
    }, joinUrlSegments = (s1, s2)=>s1 && s2 ? addTrailingSlash(s1) + removeLeadingSlash(s2) : s1 || s2 || '', stripBase = (path, base)=>{
        if (path === base) return '/';
        let trailingSlashBase = addTrailingSlash(base);
        return path.startsWith(trailingSlashBase) ? path.slice(trailingSlashBase.length - 1) : path;
    }, getRoutes = (context)=>Object.values(context.environments).reduce((prev, environmentContext)=>{
            let { distPath, config } = environmentContext, distPrefix = (0, external_node_path_.relative)(context.distPath, distPath).split(external_node_path_.sep).join('/'), routes = formatRoutes(environmentContext.htmlPaths, context.normalizedConfig.server.base, external_node_path_.posix.join(distPrefix, config.output.distPath.html), config.html.outputStructure);
            return prev.concat(...routes);
        }, []), formatRoutes = (entry, base, distPathPrefix, outputStructure)=>{
        let prefix = joinUrlSegments(base, formatPrefix(distPathPrefix));
        return Object.keys(entry).map((entryName)=>({
                entryName,
                pathname: prefix + ('index' === entryName && 'nested' !== outputStructure ? '' : entryName)
            })).sort((a)=>'index' === a.entryName ? -1 : 1);
    };
    function printServerURLs({ urls: originalUrls, port, routes, protocol, printUrls, trailingLineBreak = !0 }) {
        if (!1 === printUrls) return null;
        let urls = originalUrls, useCustomUrl = isFunction(printUrls);
        if (useCustomUrl) {
            let newUrls = printUrls({
                urls: urls.map((item)=>item.url),
                port,
                routes,
                protocol
            });
            if (!newUrls) return null;
            if (!Array.isArray(newUrls)) throw Error(`[rsbuild:config] "server.printUrls" must return an array, but got ${typeof newUrls}.`);
            urls = newUrls.map((url)=>({
                    url,
                    label: getUrlLabel(url)
                }));
        }
        if (0 === urls.length || 0 === routes.length && !useCustomUrl) return null;
        let message = function(urls, routes) {
            if (routes.length <= 1) {
                let pathname = routes.length ? routes[0].pathname : '';
                return urls.map(({ label, url })=>{
                    let normalizedPathname = normalizeUrl(`${url}${pathname}`), prefix = `➜ ${index_js_default().dim(label.padEnd(10))}`;
                    return `  ${prefix}${index_js_default().cyan(normalizedPathname)}\n`;
                }).join('');
            }
            let message = '', maxNameLength = Math.max(...routes.map((r)=>r.entryName.length));
            return urls.forEach(({ label, url }, index)=>{
                for (let r of (index > 0 && (message += '\n'), message += `  ➜ ${label}\n`, routes))message += `  ${index_js_default().dim('-')} ${index_js_default().dim(r.entryName.padEnd(maxNameLength + 4))}${index_js_default().cyan(normalizeUrl(`${url}${r.pathname}`))}\n`;
            }), message;
        }(urls, routes);
        return !1 === trailingLineBreak && message.endsWith('\n') && (message = message.slice(0, -1)), rslog_index_js_namespaceObject.logger.log(message), message;
    }
    let getPort = async ({ host, port, strictPort, tryLimits = 20 })=>{
        'string' == typeof port && (port = Number.parseInt(port, 10)), strictPort && (tryLimits = 1);
        let original = port, found = !1, attempts = 0;
        for(; !found && attempts <= tryLimits;)try {
            await new Promise((resolve, reject)=>{
                let server = external_node_net_default().createServer();
                server.unref(), server.on('error', reject), server.listen({
                    port,
                    host
                }, ()=>{
                    found = !0, server.close(resolve);
                });
            });
        } catch (e) {
            if ('EADDRINUSE' !== e.code) throw e;
            port++, attempts++;
        }
        if (port !== original && strictPort) throw Error(`[rsbuild:server] Port "${original}" is occupied, please choose another one.`);
        return port;
    }, getServerConfig = async ({ config })=>{
        let host = config.server.host || DEFAULT_DEV_HOST, originalPort = config.server.port || 3000, port = await getPort({
            host,
            port: originalPort,
            strictPort: config.server.strictPort || !1
        }), https = !!config.server.https, portTip = port !== originalPort ? `Port ${originalPort} is in use, ${index_js_default().yellow(`using port ${port}.`)}` : void 0;
        return {
            port,
            host,
            https,
            portTip
        };
    }, getIpv4Interfaces = ()=>{
        let interfaces = external_node_os_default().networkInterfaces(), ipv4Interfaces = new Map();
        for (let key of Object.keys(interfaces))for (let detail of interfaces[key]){
            let familyV4Value = 'string' == typeof detail.family ? 'IPv4' : 4;
            detail.family === familyV4Value && !ipv4Interfaces.has(detail.address) && ipv4Interfaces.set(detail.address, detail);
        }
        return Array.from(ipv4Interfaces.values());
    }, isLoopbackHost = (host)=>[
            'localhost',
            '127.0.0.1',
            '::1',
            '0000:0000:0000:0000:0000:0000:0000:0001'
        ].includes(host), getHostInUrl = (host)=>host === DEFAULT_DEV_HOST ? 'localhost' : external_node_net_default().isIPv6(host) ? '::' === host ? '[::1]' : `[${host}]` : host, concatUrl = ({ host, port, protocol })=>`${protocol}://${host}:${port}`, LOCAL_LABEL = 'Local:  ', NETWORK_LABEL = 'Network:  ', getUrlLabel = (url)=>{
        try {
            let { host } = new URL(url);
            return isLoopbackHost(host) ? LOCAL_LABEL : NETWORK_LABEL;
        } catch (err) {
            return NETWORK_LABEL;
        }
    }, getAddressUrls = ({ protocol = 'http', port, host })=>{
        if (host && host !== DEFAULT_DEV_HOST) return [
            {
                label: isLoopbackHost(host) ? LOCAL_LABEL : NETWORK_LABEL,
                url: concatUrl({
                    port,
                    host: getHostInUrl(host),
                    protocol
                })
            }
        ];
        let ipv4Interfaces = getIpv4Interfaces(), addressUrls = [], hasLocalUrl = !1;
        for (let detail of ipv4Interfaces)if (isLoopbackHost(detail.address) || detail.internal) {
            if (hasLocalUrl) continue;
            addressUrls.push({
                label: LOCAL_LABEL,
                url: concatUrl({
                    host: 'localhost',
                    port,
                    protocol
                })
            }), hasLocalUrl = !0;
        } else addressUrls.push({
            label: NETWORK_LABEL,
            url: concatUrl({
                host: detail.address,
                port,
                protocol
            })
        });
        return addressUrls;
    }, COMPILATION_ID_REGEX = /[^a-zA-Z0-9_-]/g, getCompilationId = (compiler)=>{
        let uniqueName = compiler.options.output.uniqueName ?? '';
        return `${compiler.name ?? ''}_${uniqueName.replace(COMPILATION_ID_REGEX, '_')}`;
    };
    function getServerTerminator(server) {
        let listened = !1, pendingSockets = new Set(), onConnection = (socket)=>{
            pendingSockets.add(socket), socket.on('close', ()=>{
                pendingSockets.delete(socket);
            });
        };
        return server.on('connection', onConnection), server.on('secureConnection', onConnection), server.once('listening', ()=>{
            listened = !0;
        }), ()=>new Promise((resolve, reject)=>{
                for (let socket of pendingSockets)socket.destroy();
                listened ? server.close((err)=>err ? reject(err) : resolve()) : resolve();
            });
    }
    let execAsync = (0, external_node_util_namespaceObject.promisify)(external_node_child_process_.exec), supportedChromiumBrowsers = [
        'Google Chrome Canary',
        'Google Chrome Dev',
        'Google Chrome Beta',
        'Google Chrome',
        'Microsoft Edge',
        'Brave Browser',
        'Vivaldi',
        'Chromium'
    ], getTargetBrowser = async ()=>{
        let targetBrowser = process.env.BROWSER;
        if (!targetBrowser || !supportedChromiumBrowsers.includes(targetBrowser)) {
            let { stdout: ps } = await execAsync('ps cax');
            targetBrowser = supportedChromiumBrowsers.find((b)=>ps.includes(b));
        }
        return targetBrowser;
    };
    async function openBrowser(url) {
        if ('darwin' === process.platform) try {
            let targetBrowser = await getTargetBrowser();
            if (targetBrowser) return await execAsync(`osascript openChrome.applescript "${encodeURI(url)}" "${targetBrowser}"`, {
                cwd: STATIC_PATH
            }), !0;
            rslog_index_js_namespaceObject.logger.debug('Failed to find the target browser.');
        } catch (err) {
            rslog_index_js_namespaceObject.logger.debug('Failed to open start URL with apple script.'), rslog_index_js_namespaceObject.logger.debug(err);
        }
        try {
            let { default: open } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/open/index.js"));
            return await open(url), !0;
        } catch (err) {
            return rslog_index_js_namespaceObject.logger.error('Failed to open start URL.'), rslog_index_js_namespaceObject.logger.error(err), !1;
        }
    }
    let openedURLs = [], clearOpenedURLs = ()=>{
        openedURLs = [];
    }, replacePortPlaceholder = (url, port)=>url.replace(/<port>/g, String(port)), normalizeOpenConfig = (config)=>{
        let { open } = config.server;
        return 'boolean' == typeof open ? {
            targets: []
        } : 'string' == typeof open ? {
            targets: [
                open
            ]
        } : Array.isArray(open) ? {
            targets: open
        } : {
            targets: open.target ? castArray(open.target) : [],
            before: open.before
        };
    };
    async function open_open({ https, port, routes, config, clearCache }) {
        let { targets, before } = normalizeOpenConfig(config);
        if ('true' === process.env.CSB) return;
        clearCache && clearOpenedURLs();
        let urls = [], host = getHostInUrl(config.server.host), baseUrl = `${https ? 'https' : 'http'}://${host}:${port}`;
        for (let url of (targets.length ? urls.push(...targets.map((target)=>(function(str, base) {
                if (canParse(str)) return str;
                try {
                    return new URL(str, base).href;
                } catch (e) {
                    throw Error('[rsbuild:open]: Invalid input: not a valid URL or pathname');
                }
            })(replacePortPlaceholder(target, port), baseUrl))) : routes.length && urls.push(`${baseUrl}${routes[0].pathname}`), before && await before(), urls))!openedURLs.includes(url) && (openBrowser(url), openedURLs.push(url));
    }
    let getJsAsyncPath = (jsPath, isServer, jsAsync)=>void 0 !== jsAsync ? jsAsync : isServer ? jsPath : jsPath ? `${jsPath}/async` : 'async', pluginOutput = ()=>({
            name: 'rsbuild:output',
            setup (api) {
                api.modifyBundlerChain(async (chain, { CHAIN_ID, target, isProd, isServer, environment })=>{
                    let { distPath, config } = environment, publicPath = function({ isProd, config, context }) {
                        var _context_devServer, _context_devServer1, _context_devServer2;
                        let { dev, output, server } = config, publicPath = DEFAULT_ASSET_PREFIX, port = (null === (_context_devServer = context.devServer) || void 0 === _context_devServer ? void 0 : _context_devServer.port) || 3000;
                        if (isProd) 'string' == typeof output.assetPrefix && (publicPath = output.assetPrefix);
                        else if ('string' == typeof dev.assetPrefix) publicPath = dev.assetPrefix;
                        else if (!0 === dev.assetPrefix) {
                            let protocol = (null === (_context_devServer1 = context.devServer) || void 0 === _context_devServer1 ? void 0 : _context_devServer1.https) ? 'https' : 'http', hostname = (null === (_context_devServer2 = context.devServer) || void 0 === _context_devServer2 ? void 0 : _context_devServer2.hostname) || DEFAULT_DEV_HOST;
                            publicPath = hostname === DEFAULT_DEV_HOST ? `${protocol}://localhost:<port>/` : `${protocol}://${hostname}:<port>/`, server.base && '/' !== server.base && (publicPath = urlJoin(publicPath, server.base));
                        }
                        return formatPublicPath(replacePortPlaceholder(publicPath, port));
                    }({
                        config,
                        isProd,
                        context: api.context
                    }), jsPath = config.output.distPath.js, jsAsyncPath = getJsAsyncPath(jsPath, isServer, config.output.distPath.jsAsync), jsFilename = getFilename(config, 'js', isProd, isServer), isJsFilenameFn = 'function' == typeof jsFilename;
                    if (chain.output.path(distPath).filename(isJsFilenameFn ? (...args)=>{
                        let name = jsFilename(...args);
                        return external_node_path_.posix.join(jsPath, name);
                    } : external_node_path_.posix.join(jsPath, jsFilename)).chunkFilename(isJsFilenameFn ? (...args)=>{
                        let name = jsFilename(...args);
                        return external_node_path_.posix.join(jsAsyncPath, name);
                    } : external_node_path_.posix.join(jsAsyncPath, jsFilename)).publicPath(publicPath).pathinfo(!1).hashFunction('xxhash64'), isServer && chain.output.library({
                        type: 'commonjs2',
                        ...chain.output.get('library') || {}
                    }), config.output.copy && 'rspack' === api.context.bundlerType) {
                        let { copy } = config.output, options = Array.isArray(copy) ? {
                            patterns: copy
                        } : copy;
                        chain.plugin(CHAIN_ID.PLUGIN.COPY).use(core_namespaceObject.rspack.CopyRspackPlugin, [
                            options
                        ]);
                    }
                    let emitCss = config.output.emitCss ?? 'web' === target;
                    if (!config.output.injectStyles && emitCss) {
                        let extractPluginOptions = config.tools.cssExtract.pluginOptions, cssPath = config.output.distPath.css, cssFilename = getFilename(config, 'css', isProd), isCssFilenameFn = 'function' == typeof cssFilename, cssAsyncPath = config.output.distPath.cssAsync ?? (cssPath ? `${cssPath}/async` : 'async');
                        chain.plugin(CHAIN_ID.PLUGIN.MINI_CSS_EXTRACT).use(getCssExtractPlugin(), [
                            {
                                filename: isCssFilenameFn ? (...args)=>{
                                    let name = cssFilename(...args);
                                    return external_node_path_.posix.join(cssPath, name);
                                } : external_node_path_.posix.join(cssPath, cssFilename),
                                chunkFilename: isCssFilenameFn ? (...args)=>{
                                    let name = cssFilename(...args);
                                    return external_node_path_.posix.join(cssAsyncPath, name);
                                } : external_node_path_.posix.join(cssAsyncPath, cssFilename),
                                ...extractPluginOptions
                            }
                        ]);
                    }
                });
            }
        }), pluginPerformance = ()=>({
            name: 'rsbuild:performance',
            setup (api) {
                api.modifyRsbuildConfig({
                    order: 'post',
                    handler: (rsbuildConfig)=>{
                        var _rsbuildConfig_performance, _config_performance;
                        let applyBundleAnalyzeConfig = (config)=>{
                            var _config_performance;
                            (null === (_config_performance = config.performance) || void 0 === _config_performance ? void 0 : _config_performance.bundleAnalyze) ? config.performance.bundleAnalyze = {
                                generateStatsFile: !0,
                                ...config.performance.bundleAnalyze || {}
                            } : (config.performance ??= {}, config.performance.bundleAnalyze = {
                                analyzerMode: 'disabled',
                                generateStatsFile: !0
                            });
                        };
                        if (null === (_rsbuildConfig_performance = rsbuildConfig.performance) || void 0 === _rsbuildConfig_performance ? void 0 : _rsbuildConfig_performance.profile) applyBundleAnalyzeConfig(rsbuildConfig);
                        else if (rsbuildConfig.environments) for (let config of Object.values(rsbuildConfig.environments))(null === (_config_performance = config.performance) || void 0 === _config_performance ? void 0 : _config_performance.profile) && applyBundleAnalyzeConfig(config);
                    }
                }), api.modifyBundlerChain((chain, { environment })=>{
                    let { config } = environment, { profile } = config.performance;
                    if (!!profile) chain.profile(profile);
                });
            }
        }), pluginProgress = ()=>({
            name: 'rsbuild:progress',
            setup (api) {
                if ('webpack' !== api.context.bundlerType) api.modifyBundlerChain(async (chain, { CHAIN_ID, environment })=>{
                    let { config } = environment, options = config.dev.progressBar ?? 'production' === config.mode;
                    if (!options) return;
                    let prefix = !0 !== options && void 0 !== options.id ? options.id : environment.name;
                    chain.plugin(CHAIN_ID.PLUGIN.PROGRESS).use(core_namespaceObject.rspack.ProgressPlugin, [
                        {
                            prefix,
                            ...!0 === options ? {} : options
                        }
                    ]);
                });
            }
        }), resolve_require = (0, external_node_module_namespaceObject.createRequire)(__rslib_import_meta_url__), pluginResolve = ()=>({
            name: 'rsbuild:resolve',
            setup (api) {
                api.modifyBundlerChain({
                    order: 'pre',
                    handler: (chain, { environment, CHAIN_ID })=>{
                        let { config, tsconfigPath } = environment;
                        chain.resolve.extensions.merge([
                            ...config.resolve.extensions
                        ]), tsconfigPath && chain.resolve.extensionAlias.merge({
                            '.js': [
                                '.ts',
                                '.tsx',
                                '.js'
                            ],
                            '.jsx': [
                                '.tsx',
                                '.jsx'
                            ]
                        }), !function({ chain, config, rootPath }) {
                            let mergedAlias = reduceConfigs({
                                initial: {},
                                config: config.resolve.alias
                            });
                            if (mergedAlias = reduceConfigs({
                                initial: mergedAlias,
                                config: config.source.alias
                            }), config.resolve.dedupe) for (let pkgName of config.resolve.dedupe){
                                let pkgPath;
                                if (mergedAlias[pkgName]) {
                                    rslog_index_js_namespaceObject.logger.debug(`[rsbuild:resolve] The package "${pkgName}" is already in the alias config, dedupe option for "${pkgName}" will be ignored.`);
                                    continue;
                                }
                                try {
                                    pkgPath = (0, external_node_path_.dirname)(resolve_require.resolve(`${pkgName}/package.json`, {
                                        paths: [
                                            rootPath
                                        ]
                                    }));
                                } catch (e) {}
                                if (!pkgPath) try {
                                    pkgPath = resolve_require.resolve(pkgName, {
                                        paths: [
                                            rootPath
                                        ]
                                    });
                                    let trailing = [
                                        'node_modules',
                                        ...pkgName.split('/')
                                    ].join(external_node_path_.sep);
                                    for(; !pkgPath.endsWith(trailing) && pkgPath.includes('node_modules');)pkgPath = (0, external_node_path_.dirname)(pkgPath);
                                } catch (e) {
                                    rslog_index_js_namespaceObject.logger.debug(`[rsbuild:resolve] The package "${pkgName}" is not resolved in the project, dedupe option for "${pkgName}" will be ignored.`);
                                    continue;
                                }
                                mergedAlias[pkgName] = pkgPath;
                            }
                            for (let name of Object.keys(mergedAlias)){
                                let formattedValues = castArray(mergedAlias[name]).map((value)=>'string' == typeof value && value.startsWith('.') ? ensureAbsolutePath(rootPath, value) : value);
                                chain.resolve.alias.set(name, 1 === formattedValues.length ? formattedValues[0] : formattedValues);
                            }
                        }({
                            chain,
                            config,
                            rootPath: api.context.rootPath
                        }), chain.module.rule(CHAIN_ID.RULE.MJS).test(/\.m?js/).resolve.set('fullySpecified', !1);
                        let aliasStrategy = config.source.aliasStrategy ?? config.resolve.aliasStrategy;
                        tsconfigPath && 'rspack' === api.context.bundlerType && 'prefer-tsconfig' === aliasStrategy && chain.resolve.tsConfig({
                            configFile: tsconfigPath,
                            references: 'auto'
                        });
                    }
                });
            }
        });
    function HtmlPreloadOrPrefetchPlugin_define_property(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    let HtmlPreloadOrPrefetchPlugin_defaultOptions = {
        type: 'async-chunks'
    };
    class HtmlPreloadOrPrefetchPlugin {
        apply(compiler) {
            compiler.hooks.compilation.tap(this.constructor.name, (compilation)=>{
                getHTMLPlugin().getHooks(compilation).beforeAssetTagGeneration.tap(`HTML${upperFirst(this.type)}Plugin`, (htmlPluginData)=>(this.resourceHints = function(options, type, compilation, htmlPluginData, HTMLCount) {
                        let extractedChunks = function({ compilation, includeType }) {
                            let chunks = [
                                ...compilation.chunks
                            ];
                            if (void 0 === includeType || 'async-chunks' === includeType) return chunks.filter(isAsync);
                            if ('initial' === includeType) return chunks.filter((chunk)=>!isAsync(chunk));
                            if ('all-chunks' === includeType) return chunks;
                            if ('all-assets' === includeType) {
                                var _compilation_assetsInfo;
                                let licenseAssets = [
                                    ...(null === (_compilation_assetsInfo = compilation.assetsInfo) || void 0 === _compilation_assetsInfo ? void 0 : _compilation_assetsInfo.values()) || []
                                ].map((info)=>{
                                    var _info_related;
                                    return (null === (_info_related = info.related) || void 0 === _info_related ? !!void 0 : !!_info_related.license) && info.related.license;
                                }).filter(Boolean);
                                return [
                                    {
                                        files: Object.keys(compilation.assets).filter((t)=>!licenseAssets.includes(t))
                                    }
                                ];
                            }
                            return chunks;
                        }({
                            compilation,
                            includeType: options.type
                        }), sortedFilteredFiles = [
                            ...new Set(('all-assets' === options.type || 1 === HTMLCount ? extractedChunks : extractedChunks.filter((chunk)=>(function({ chunk, htmlPluginData }) {
                                    let { options } = htmlPluginData.plugin;
                                    return recursiveChunkEntryNames(chunk).some((chunkName)=>{
                                        var chunkName1, includeChunks, excludeChunks;
                                        return chunkName1 = chunkName, includeChunks = null == options ? void 0 : options.chunks, excludeChunks = null == options ? void 0 : options.excludeChunks, !(Array.isArray(includeChunks) && -1 === includeChunks.indexOf(chunkName1) || Array.isArray(excludeChunks) && -1 !== excludeChunks.indexOf(chunkName1)) && !0;
                                    });
                                })({
                                    chunk: chunk,
                                    compilation,
                                    htmlPluginData,
                                    pluginOptions: options
                                }))).reduce((accumulated, chunk)=>accumulated.concat([
                                    ...chunk.files,
                                    ...chunk.auxiliaryFiles || []
                                ]), []))
                        ].filter((file)=>[
                                /.map$/
                            ].every((regex)=>!regex.test(file))).filter((file)=>!options.include || ('function' == typeof options.include ? options.include(file) : options.include.some((regex)=>new RegExp(regex).test(file)))).filter((file)=>!options.exclude || ('function' == typeof options.exclude ? !options.exclude(file) : options.exclude.every((regex)=>!new RegExp(regex).test(file)))).sort(), links = [], { publicPath, crossOriginLoading } = compilation.outputOptions;
                        for (let file of sortedFilteredFiles){
                            let href = ensureAssetPrefix(file, publicPath), attributes = {
                                href,
                                rel: type
                            };
                            'preload' === type && (attributes.as = function({ href, file }) {
                                let url = new external_node_url_namespaceObject.URL(file || href, 'https://example.com'), extension = external_node_path_default().extname(url.pathname).slice(1);
                                return [
                                    'css'
                                ].includes(extension) ? 'style' : IMAGE_EXTENSIONS.includes(extension) ? 'image' : VIDEO_EXTENSIONS.includes(extension) ? 'video' : AUDIO_EXTENSIONS.includes(extension) ? 'audio' : FONT_EXTENSIONS.includes(extension) ? 'font' : [
                                    'vtt'
                                ].includes(extension) ? 'track' : 'script';
                            }({
                                href,
                                file
                            }), 'font' === attributes.as && (attributes.crossorigin = ''), ('script' === attributes.as || 'style' === attributes.as) && crossOriginLoading && !('use-credentials' !== crossOriginLoading && '/' === publicPath) && (attributes.crossorigin = 'anonymous' === crossOriginLoading ? '' : crossOriginLoading)), links.push({
                                tagName: 'link',
                                attributes,
                                voidTag: !0,
                                meta: {}
                            });
                        }
                        return links;
                    }(this.options, this.type, compilation, htmlPluginData, this.HTMLCount), htmlPluginData)), getHTMLPlugin().getHooks(compilation).alterAssetTags.tap(`HTML${upperFirst(this.type)}Plugin`, (htmlPluginData)=>{
                    if (this.resourceHints) {
                        var resourceHints, scripts;
                        htmlPluginData.assetTags.styles = [
                            ...(resourceHints = this.resourceHints, scripts = htmlPluginData.assetTags.scripts, resourceHints.filter((resourceHint)=>!scripts.find((script)=>script.attributes.src === resourceHint.attributes.href))),
                            ...htmlPluginData.assetTags.styles
                        ];
                    }
                    return htmlPluginData;
                });
            });
        }
        constructor(options, type, HTMLCount){
            HtmlPreloadOrPrefetchPlugin_define_property(this, "options", void 0), HtmlPreloadOrPrefetchPlugin_define_property(this, "resourceHints", []), HtmlPreloadOrPrefetchPlugin_define_property(this, "type", void 0), HtmlPreloadOrPrefetchPlugin_define_property(this, "HTMLCount", void 0), this.options = {
                ...HtmlPreloadOrPrefetchPlugin_defaultOptions,
                ...'boolean' == typeof options ? {} : options
            }, this.type = type, this.HTMLCount = HTMLCount;
        }
    }
    let resourceHints_generateLinks = (options, rel)=>options.map((option)=>({
                tag: 'link',
                attrs: {
                    rel,
                    ...option
                }
            })), pluginResourceHints = ()=>({
            name: 'rsbuild:resource-hints',
            setup (api) {
                api.modifyHTMLTags(({ headTags, bodyTags }, { environment })=>{
                    let { config } = environment, { dnsPrefetch, preconnect } = config.performance;
                    if (dnsPrefetch) {
                        let attrs = dnsPrefetch.map((option)=>({
                                href: option
                            }));
                        attrs.length && headTags.unshift(...resourceHints_generateLinks(attrs, 'dns-prefetch'));
                    }
                    if (preconnect) {
                        let attrs = preconnect.map((option)=>'string' == typeof option ? {
                                href: option
                            } : option);
                        attrs.length && headTags.unshift(...resourceHints_generateLinks(attrs, 'preconnect'));
                    }
                    return {
                        headTags,
                        bodyTags
                    };
                }), api.modifyBundlerChain(async (chain, { CHAIN_ID, environment })=>{
                    let { config, htmlPaths } = environment;
                    if (0 === Object.keys(htmlPaths).length) return;
                    let { performance: { preload, prefetch } } = config, HTMLCount = chain.entryPoints.values().length;
                    prefetch && chain.plugin(CHAIN_ID.PLUGIN.HTML_PREFETCH).use(HtmlPreloadOrPrefetchPlugin, [
                        prefetch,
                        'prefetch',
                        HTMLCount
                    ]), preload && chain.plugin(CHAIN_ID.PLUGIN.HTML_PRELOAD).use(HtmlPreloadOrPrefetchPlugin, [
                        preload,
                        'preload',
                        HTMLCount
                    ]);
                });
            }
        }), rsdoctor_require = (0, external_node_module_namespaceObject.createRequire)(__rslib_import_meta_url__), pluginRsdoctor = ()=>({
            name: 'rsbuild:rsdoctor',
            setup (api) {
                api.onBeforeCreateCompiler(async ({ bundlerConfigs })=>{
                    let packagePath, module;
                    if ('true' !== process.env.RSDOCTOR) return;
                    let isRspack = 'rspack' === api.context.bundlerType, pluginName = isRspack ? 'RsdoctorRspackPlugin' : 'RsdoctorWebpackPlugin', isRsdoctorPlugin = (plugin)=>{
                        var _plugin_constructor;
                        return (null == plugin ? void 0 : plugin.isRsdoctorPlugin) === !0 || (null == plugin ? void 0 : null === (_plugin_constructor = plugin.constructor) || void 0 === _plugin_constructor ? void 0 : _plugin_constructor.name) === pluginName;
                    };
                    for (let config of bundlerConfigs){
                        var _config_plugins;
                        if (null === (_config_plugins = config.plugins) || void 0 === _config_plugins ? void 0 : _config_plugins.some((plugin)=>isRsdoctorPlugin(plugin))) return;
                    }
                    let packageName = isRspack ? '@rsdoctor/rspack-plugin' : '@rsdoctor/webpack-plugin';
                    try {
                        packagePath = rsdoctor_require.resolve(packageName, {
                            paths: [
                                api.context.rootPath
                            ]
                        });
                    } catch (err) {
                        rslog_index_js_namespaceObject.logger.warn(`\`process.env.RSDOCTOR\` enabled, please install ${index_js_default().bold(index_js_default().yellow(packageName))} package.`);
                        return;
                    }
                    try {
                        module = await import(packagePath);
                    } catch (err) {
                        rslog_index_js_namespaceObject.logger.error(`\`process.env.RSDOCTOR\` enabled, but failed to load ${index_js_default().bold(index_js_default().yellow(packageName))} module.`);
                        return;
                    }
                    if (!!module && !!module[pluginName]) {
                        for (let config of bundlerConfigs)config.plugins ||= [], config.plugins.push(new module[pluginName]());
                        rslog_index_js_namespaceObject.logger.info(`${index_js_default().bold(index_js_default().yellow(packageName))} enabled.`);
                    }
                });
            }
        }), external_node_inspector_namespaceObject = require("node:inspector");
    var external_node_inspector_default = __webpack_require__.n(external_node_inspector_namespaceObject);
    let stopProfiler = (output, profileSession)=>{
        if (!!profileSession) profileSession.post('Profiler.stop', (error, param)=>{
            if (error) {
                rslog_index_js_namespaceObject.logger.error('Failed to generate JS CPU profile:', error);
                return;
            }
            external_node_fs_default().writeFileSync(output, JSON.stringify(param.profile));
        });
    }, pluginRspackProfile = ()=>({
            name: 'rsbuild:rspack-profile',
            async setup (api) {
                var _process_env_RSPACK_PROFILE;
                let profileSession;
                if ('webpack' === api.context.bundlerType) return;
                let RSPACK_PROFILE = null === (_process_env_RSPACK_PROFILE = process.env.RSPACK_PROFILE) || void 0 === _process_env_RSPACK_PROFILE ? void 0 : _process_env_RSPACK_PROFILE.toUpperCase();
                if (!RSPACK_PROFILE) return;
                let timestamp = Date.now(), profileDirName = `rspack-profile-${timestamp}`, enableProfileTrace = 'ALL' === RSPACK_PROFILE || RSPACK_PROFILE.includes('TRACE'), enableCPUProfile = 'ALL' === RSPACK_PROFILE || RSPACK_PROFILE.includes('CPU'), enableLogging = 'ALL' === RSPACK_PROFILE || RSPACK_PROFILE.includes('LOGGING'), onStart = ()=>{
                    let profileDir = external_node_path_default().join(api.context.distPath, profileDirName), traceFilePath = external_node_path_default().join(profileDir, 'trace.json');
                    !external_node_fs_default().existsSync(profileDir) && external_node_fs_default().mkdirSync(profileDir, {
                        recursive: !0
                    }), enableProfileTrace && core_default().experiments.globalTrace.register('trace', 'chrome', traceFilePath), enableCPUProfile && ((profileSession = new (external_node_inspector_default()).Session()).connect(), profileSession.post('Profiler.enable'), profileSession.post('Profiler.start'));
                };
                api.onBeforeBuild(({ isFirstCompile })=>{
                    isFirstCompile && onStart();
                }), api.onBeforeStartDevServer(onStart), api.onAfterBuild(async ({ stats })=>{
                    let loggingFilePath = external_node_path_default().join(api.context.distPath, profileDirName, 'logging.json');
                    if (enableLogging && stats) {
                        let logging = stats.toJson({
                            all: !1,
                            logging: 'verbose',
                            loggingTrace: !0
                        });
                        external_node_fs_default().writeFileSync(loggingFilePath, JSON.stringify(logging));
                    }
                }), api.onExit(()=>{
                    enableProfileTrace && core_default().experiments.globalTrace.cleanup();
                    let profileDir = external_node_path_default().join(api.context.distPath, profileDirName);
                    stopProfiler(external_node_path_default().join(profileDir, 'jscpuprofile.json'), profileSession), rslog_index_js_namespaceObject.logger.info(`Saved Rspack profile file to ${profileDir}`);
                });
            }
        }), pluginServer = ()=>({
            name: 'rsbuild:server',
            setup (api) {
                let onStartServer = async ({ port, routes })=>{
                    let config = api.getNormalizedConfig();
                    if (config.server.open) {
                        var _api_context_devServer;
                        open_open({
                            https: null === (_api_context_devServer = api.context.devServer) || void 0 === _api_context_devServer ? void 0 : _api_context_devServer.https,
                            port,
                            routes,
                            config
                        });
                    }
                };
                api.onAfterStartDevServer(onStartServer), api.onAfterStartProdServer(onStartServer), api.onBeforeBuild(async ({ isFirstCompile })=>{
                    if (!!isFirstCompile) for (let publicDir of normalizePublicDirs(api.getNormalizedConfig().server.publicDir)){
                        let { name, copyOnBuild } = publicDir;
                        if (!copyOnBuild || !name) continue;
                        let normalizedPath = (0, external_node_path_.isAbsolute)(name) ? name : (0, external_node_path_.join)(api.context.rootPath, name);
                        if (!!external_node_fs_default().existsSync(normalizedPath)) try {
                            await external_node_fs_default().promises.cp(normalizedPath, api.context.distPath, {
                                recursive: !0,
                                dereference: !0
                            });
                        } catch (err) {
                            throw err instanceof Error && (err.message = `Copy public dir (${normalizedPath}) to dist failed:\n${err.message}`), err;
                        }
                    }
                });
            }
        }), external_node_assert_namespaceObject = require("node:assert");
    var external_node_assert_default = __webpack_require__.n(external_node_assert_namespaceObject);
    let MODULE_PATH_REGEX = /.*[\\/]node_modules[\\/](?!\.pnpm[\\/])(?:(@[^\\/]+)[\\/])?([^\\/]+)/, SPLIT_STRATEGY_DISPATCHER = {
        'split-by-experience': function(ctx) {
            let { override, polyfill, defaultConfig, forceSplittingGroups } = ctx, experienceCacheGroup = {}, packageRegExps = {
                axios: /node_modules[\\/]axios(-.+)?[\\/]/
            };
            for (let [name, test] of (('entry' === polyfill || 'usage' === polyfill) && (packageRegExps.polyfill = /node_modules[\\/](?:tslib|core-js|@swc[\\/]helpers)[\\/]/), Object.entries(packageRegExps))){
                let key = `lib-${name}`;
                experienceCacheGroup[key] = {
                    test,
                    priority: 0,
                    name: key
                };
            }
            return {
                ...defaultConfig,
                ...override,
                cacheGroups: {
                    ...defaultConfig.cacheGroups,
                    ...experienceCacheGroup,
                    ...forceSplittingGroups,
                    ...override.cacheGroups
                }
            };
        },
        'split-by-module': function(ctx) {
            let { override, forceSplittingGroups, defaultConfig } = ctx;
            return {
                ...defaultConfig,
                minSize: 0,
                maxInitialRequests: Number.POSITIVE_INFINITY,
                ...override,
                cacheGroups: {
                    ...defaultConfig.cacheGroups,
                    ...forceSplittingGroups,
                    vendors: {
                        priority: -9,
                        test: NODE_MODULES_REGEX,
                        name: (module)=>module ? function(modulePath) {
                                let handleModuleContext = null == modulePath ? void 0 : modulePath.match(MODULE_PATH_REGEX);
                                if (!handleModuleContext) return;
                                let [, scope, name] = handleModuleContext;
                                return [
                                    'npm',
                                    (scope ?? '').replace('@', ''),
                                    name
                                ].filter(Boolean).join('.');
                            }(module.context) : void 0
                    },
                    ...override.cacheGroups
                }
            };
        },
        'split-by-size': function(ctx) {
            let { override, forceSplittingGroups, defaultConfig, userConfig } = ctx;
            return external_node_assert_default()('split-by-size' === userConfig.strategy), {
                ...defaultConfig,
                minSize: userConfig.minSize ?? 0,
                maxSize: userConfig.maxSize ?? Number.POSITIVE_INFINITY,
                ...override,
                cacheGroups: {
                    ...defaultConfig.cacheGroups,
                    ...forceSplittingGroups,
                    ...override.cacheGroups
                }
            };
        },
        custom: function(ctx) {
            let { override, forceSplittingGroups, defaultConfig } = ctx;
            return {
                ...defaultConfig,
                ...override,
                cacheGroups: {
                    ...defaultConfig.cacheGroups,
                    ...forceSplittingGroups,
                    ...override.cacheGroups
                }
            };
        },
        'all-in-one': function(_ctx) {
            return !1;
        },
        'single-vendor': function(ctx) {
            let { override, defaultConfig, forceSplittingGroups } = ctx;
            return {
                ...defaultConfig,
                ...override,
                cacheGroups: {
                    ...defaultConfig.cacheGroups,
                    singleVendor: {
                        test: NODE_MODULES_REGEX,
                        priority: 0,
                        chunks: 'all',
                        name: 'vendor',
                        enforce: !0
                    },
                    ...forceSplittingGroups,
                    ...override.cacheGroups
                }
            };
        }
    }, pluginSplitChunks = ()=>({
            name: 'rsbuild:split-chunks',
            setup (api) {
                api.modifyBundlerChain(async (chain, { environment, isServer, isWebWorker })=>{
                    var _config_moduleFederation_options, _config_moduleFederation;
                    if (isServer || isWebWorker) {
                        chain.optimization.splitChunks(!1), isWebWorker && chain.module.parser.merge({
                            javascript: {
                                dynamicImportMode: 'eager'
                            }
                        });
                        return;
                    }
                    let { config } = environment, defaultConfig = {
                        chunks: (null === (_config_moduleFederation = config.moduleFederation) || void 0 === _config_moduleFederation ? void 0 : null === (_config_moduleFederation_options = _config_moduleFederation.options) || void 0 === _config_moduleFederation_options ? void 0 : _config_moduleFederation_options.exposes) ? 'async' : 'all',
                        cacheGroups: {}
                    };
                    'webpack' === api.context.bundlerType && (defaultConfig.enforceSizeThreshold = 50000);
                    let { chunkSplit } = config.performance, forceSplittingGroups = {};
                    chunkSplit.forceSplitting && (forceSplittingGroups = function(forceSplitting) {
                        let cacheGroups = {};
                        for (let [key, regexp] of Array.isArray(forceSplitting) ? forceSplitting.map((regexp, index)=>[
                                `force-split-${index}`,
                                regexp
                            ]) : Object.entries(forceSplitting))cacheGroups[key] = {
                            test: regexp,
                            name: key,
                            chunks: 'all',
                            priority: 0,
                            enforce: !0
                        };
                        return cacheGroups;
                    }(chunkSplit.forceSplitting));
                    let override = 'custom' === chunkSplit.strategy ? chunkSplit.splitChunks ?? chunkSplit.override : chunkSplit.override, splitChunksOptions = await SPLIT_STRATEGY_DISPATCHER[chunkSplit.strategy || 'split-by-experience']({
                        defaultConfig,
                        override: override || {},
                        forceSplittingGroups,
                        userConfig: chunkSplit,
                        rootPath: api.context.rootPath,
                        polyfill: config.output.polyfill
                    });
                    chain.optimization.splitChunks(splitChunksOptions);
                });
            }
        }), getAssetName = (url, assetPrefix)=>url.startsWith(assetPrefix) ? removeLeadingSlash(url.replace(assetPrefix, '')) : removeLeadingSlash(url), isSriLinkRel = (rel)=>'string' == typeof rel && [
            'stylesheet',
            'preload',
            'modulepreload'
        ].includes(rel), pluginSri = ()=>({
            name: 'rsbuild:sri',
            setup (api) {
                let placeholder = 'RSBUILD_INTEGRITY_PLACEHOLDER:', getAlgorithm = (environment)=>{
                    let { config } = environment, { sri } = config.security;
                    if (!('auto' === sri.enable ? 'production' === config.mode : sri.enable)) return null;
                    let { algorithm = 'sha384' } = sri;
                    return algorithm;
                };
                api.modifyHTMLTags({
                    order: 'post',
                    handler (tags, { assetPrefix, environment }) {
                        if (!getAlgorithm(environment)) return tags;
                        for (let tag of [
                            ...tags.headTags,
                            ...tags.bodyTags
                        ]){
                            let url = '';
                            if (!tag.attrs) continue;
                            if ('script' === tag.tag && 'string' == typeof tag.attrs.src ? url = tag.attrs.src : 'link' === tag.tag && isSriLinkRel(tag.attrs.rel) && 'string' == typeof tag.attrs.href && (url = tag.attrs.href), !url) continue;
                            let assetName = getAssetName(url, assetPrefix);
                            if (!!assetName) tag.attrs.integrity ??= `${placeholder}${assetName}`;
                        }
                        return tags;
                    }
                });
                let replaceIntegrity = (htmlContent, assets, algorithm, integrityCache)=>{
                    let matches = htmlContent.matchAll(/integrity="RSBUILD_INTEGRITY_PLACEHOLDER:([^"]+)"/g), replacedHtml = htmlContent, calcIntegrity = (algorithm, assetName, data)=>{
                        if (integrityCache.has(assetName)) return integrityCache.get(assetName);
                        let hash = external_node_crypto_default().createHash(algorithm).update(data).digest().toString('base64'), integrity = `${algorithm}-${hash}`;
                        return integrityCache.set(assetName, integrity), integrity;
                    };
                    for (let match of matches){
                        let assetName = match[1];
                        if (!!assetName) if (assets[assetName]) {
                            let integrity = calcIntegrity(algorithm, assetName, assets[assetName].buffer());
                            replacedHtml = replacedHtml.replaceAll(`integrity="${placeholder}${assetName}"`, `integrity="${integrity}"`);
                        } else rslog_index_js_namespaceObject.logger.debug(`[rsbuild:sri] failed to generate integrity for ${assetName}.`), replacedHtml = replacedHtml.replace(`integrity="${placeholder}${assetName}"`, '');
                    }
                    return replacedHtml;
                };
                api.processAssets({
                    stage: 'report'
                }, ({ assets, sources, environment })=>{
                    let { htmlPaths } = environment;
                    if (0 === Object.keys(htmlPaths).length) return;
                    let algorithm = getAlgorithm(environment);
                    if (!algorithm) return;
                    let integrityCache = new Map();
                    for (let asset of Object.keys(assets)){
                        if (!HTML_REGEX.test(asset)) continue;
                        let htmlContent = assets[asset].source();
                        if (!!htmlContent.includes(placeholder)) assets[asset] = new sources.RawSource(replaceIntegrity(htmlContent, assets, algorithm, integrityCache));
                    }
                });
            }
        }), swc_require = (0, external_node_module_namespaceObject.createRequire)(__rslib_import_meta_url__), builtinSwcLoaderName = 'builtin:swc-loader', pluginSwc = ()=>({
            name: PLUGIN_SWC_NAME,
            setup (api) {
                api.modifyBundlerChain({
                    order: 'pre',
                    handler: async (chain, { CHAIN_ID, isDev, target, environment })=>{
                        var browserslist, target1;
                        let { config, browserslist: browserslist1 } = environment, cacheRoot = external_node_path_default().join(api.context.cachePath, '.swc'), rule = chain.module.rule(CHAIN_ID.RULE.JS).test(SCRIPT_REGEX).type('javascript/auto').dependency({
                            not: 'url'
                        }), dataUriRule = chain.module.rule(CHAIN_ID.RULE.JS_DATA_URI).mimetype({
                            or: [
                                'text/javascript',
                                'application/javascript'
                            ]
                        });
                        if (!function({ rule, isDev, config, context, rsbuildTarget }) {
                            for (let condition of (rule.include.add({
                                and: [
                                    context.rootPath,
                                    {
                                        not: NODE_MODULES_REGEX
                                    }
                                ]
                            }), rule.include.add(/\.(?:ts|tsx|jsx|mts|cts)$/), 'web' === rsbuildTarget && isDev && rule.include.add(/[\\/]@rsbuild[\\/]core[\\/]dist[\\/]/), config.source.include || []))rule.include.add(condition);
                            for (let condition of config.source.exclude || [])rule.exclude.add(condition);
                        }({
                            rule,
                            isDev,
                            config,
                            context: api.context,
                            rsbuildTarget: target
                        }), 'webpack' === api.context.bundlerType) return;
                        let swcConfig = (browserslist = browserslist1, {
                            jsc: {
                                externalHelpers: !0,
                                parser: {
                                    tsx: !1,
                                    syntax: 'typescript',
                                    decorators: !0
                                },
                                experimental: {
                                    cacheRoot: cacheRoot,
                                    keepImportAttributes: !0
                                }
                            },
                            isModule: 'unknown',
                            env: {
                                targets: browserslist
                            }
                        });
                        if (function(swcConfig, pluginImport) {
                            let finalPluginImport = reduceTransformImportConfig(pluginImport);
                            (null == finalPluginImport ? void 0 : finalPluginImport.length) && (swcConfig.rspackExperiments ??= {}, swcConfig.rspackExperiments.import ??= [], swcConfig.rspackExperiments.import.push(...finalPluginImport));
                        }(swcConfig, config.source.transformImport), function(swcConfig, config) {
                            swcConfig.jsc ||= {}, swcConfig.jsc.transform ||= {};
                            let { version } = config.source.decorators;
                            switch(version){
                                case 'legacy':
                                    swcConfig.jsc.transform.legacyDecorator = !0, swcConfig.jsc.transform.decoratorMetadata = !0, swcConfig.jsc.transform.useDefineForClassFields = !1;
                                    break;
                                case '2022-03':
                                    swcConfig.jsc.transform.legacyDecorator = !1, swcConfig.jsc.transform.decoratorVersion = '2022-03';
                                    break;
                                default:
                                    throw Error(`[rsbuild:swc] Unknown decorators version: ${version}`);
                            }
                        }(swcConfig, config), castArray(target1 = target).includes('web') || target1.includes('web-worker')) {
                            let polyfillMode = config.output.polyfill;
                            if ('off' === polyfillMode) swcConfig.env.mode = void 0;
                            else {
                                swcConfig.env.mode = polyfillMode;
                                let coreJsDir = await applyCoreJs(swcConfig, polyfillMode);
                                for (let item of [
                                    rule,
                                    dataUriRule
                                ])item.resolve.alias.set('core-js', coreJsDir);
                            }
                        }
                        let mergedSwcConfig = reduceConfigs({
                            initial: swcConfig,
                            config: config.tools.swc,
                            mergeFn: cjs_default()
                        });
                        rule.use(CHAIN_ID.USE.SWC).loader(builtinSwcLoaderName).options(mergedSwcConfig), dataUriRule.resolve.set('fullySpecified', !1).end().use(CHAIN_ID.USE.SWC).loader(builtinSwcLoaderName).options(cloneDeep(mergedSwcConfig));
                    }
                });
            }
        }), getCoreJsVersion = (corejsPkgPath)=>{
        try {
            let rawJson = external_node_fs_default().readFileSync(corejsPkgPath, 'utf-8'), { version } = JSON.parse(rawJson), [major, minor] = version.split('.');
            return `${major}.${minor}`;
        } catch (err) {
            return '3';
        }
    };
    async function applyCoreJs(swcConfig, polyfillMode) {
        let coreJsPath = swc_require.resolve('core-js/package.json'), version = getCoreJsVersion(coreJsPath), coreJsDir = external_node_path_default().dirname(coreJsPath);
        return swcConfig.env.coreJs = version, 'usage' === polyfillMode && (swcConfig.env.shippedProposals = !0), coreJsDir;
    }
    let reduceTransformImportConfig = (options)=>{
        if (!options) return [];
        let imports = [];
        for (let item of castArray(options))isFunction(item) ? imports = item(imports) ?? imports : imports.push(item);
        return imports;
    }, pluginTarget = ()=>({
            name: 'rsbuild:target',
            setup (api) {
                api.modifyBundlerChain({
                    order: 'pre',
                    handler: async (chain, { target, environment })=>{
                        if ('node' === target) {
                            chain.target('node');
                            return;
                        }
                        let { browserslist } = environment, isDefaultBrowserslist = browserslist.join(',') === DEFAULT_WEB_BROWSERSLIST.join(',');
                        if ('web-worker' === target) {
                            chain.target(isDefaultBrowserslist ? [
                                'webworker',
                                'es2017'
                            ] : [
                                'webworker',
                                'es5'
                            ]);
                            return;
                        }
                        let esQuery = isDefaultBrowserslist ? 'es2017' : `browserslist:${browserslist.join(',')}`;
                        chain.target([
                            'web',
                            esQuery
                        ]);
                    }
                });
            }
        }), pluginWasm = ()=>({
            name: 'rsbuild:wasm',
            setup (api) {
                api.modifyBundlerChain(async (chain, { CHAIN_ID, environment })=>{
                    let { config } = environment, distPath = config.output.distPath.wasm;
                    chain.experiments({
                        ...chain.get('experiments'),
                        asyncWebAssembly: !0
                    });
                    let wasmFilename = external_node_path_.posix.join(distPath, '[hash].module.wasm');
                    chain.output.merge({
                        webassemblyModuleFilename: wasmFilename
                    }), chain.module.rule(CHAIN_ID.RULE.WASM).test(/\.wasm$/).merge({
                        dependency: 'url'
                    }).type('asset/resource').set('generator', {
                        filename: wasmFilename
                    });
                });
            }
        }), getInspectOutputPath = (context, inspectOptions)=>{
        if (inspectOptions.outputPath) return (0, external_node_path_.isAbsolute)(inspectOptions.outputPath) ? inspectOptions.outputPath : (0, external_node_path_.join)(context.distPath, inspectOptions.outputPath);
        return (0, external_node_path_.join)(context.distPath, RSBUILD_OUTPUTS_PATH);
    };
    async function inspectConfig({ context, pluginManager, rsbuildOptions, bundlerConfigs, inspectOptions = {} }) {
        inspectOptions.mode ? setNodeEnv(inspectOptions.mode) : !getNodeEnv() && setNodeEnv('development');
        let rspackConfigs = bundlerConfigs || (await initConfigs({
            context,
            pluginManager,
            rsbuildOptions
        })).rspackConfigs, rawBundlerConfigs = rspackConfigs.map((config, index)=>({
                name: config.name || String(index),
                content: stringifyConfig(config, inspectOptions.verbose)
            })), { rsbuildConfig, rawRsbuildConfig, environmentConfigs, rawEnvironmentConfigs } = getRsbuildInspectConfig({
            normalizedConfig: context.normalizedConfig,
            inspectOptions,
            pluginManager
        }), outputPath = getInspectOutputPath(context, inspectOptions);
        return inspectOptions.writeToDisk && await outputInspectConfigFiles({
            rawBundlerConfigs,
            rawEnvironmentConfigs,
            inspectOptions: {
                ...inspectOptions,
                outputPath
            },
            configType: 'rspack'
        }), {
            rsbuildConfig: rawRsbuildConfig,
            environmentConfigs: rawEnvironmentConfigs.map((r)=>r.content),
            bundlerConfigs: rawBundlerConfigs.map((r)=>r.content),
            origin: {
                rsbuildConfig,
                environmentConfigs,
                bundlerConfigs: rspackConfigs
            }
        };
    }
    async function modifyBundlerChain(context, utils) {
        var _utils_environment_config_tools;
        rslog_index_js_namespaceObject.logger.debug('modify bundler chain');
        let bundlerChain = new (rspack_chain_index_js_default())(), [modifiedBundlerChain] = await context.hooks.modifyBundlerChain.callInEnvironment({
            environment: utils.environment.name,
            args: [
                bundlerChain,
                utils
            ]
        });
        if (null === (_utils_environment_config_tools = utils.environment.config.tools) || void 0 === _utils_environment_config_tools ? void 0 : _utils_environment_config_tools.bundlerChain) for (let item of castArray(utils.environment.config.tools.bundlerChain))await item(modifiedBundlerChain, utils);
        return rslog_index_js_namespaceObject.logger.debug('modify bundler chain done'), modifiedBundlerChain;
    }
    function chainToConfig(chain) {
        let config = chain.toConfig(), { entry } = config;
        if (!isPlainObject(entry)) return config;
        let formattedEntry = {};
        for (let [entryName, entryValue] of Object.entries(entry)){
            let entryImport = [], entryDescription = null;
            for (let item of castArray(entryValue)){
                if ('string' == typeof item) {
                    entryImport.push(item);
                    continue;
                }
                item.import && entryImport.push(...castArray(item.import)), entryDescription ? Object.assign(entryDescription, item) : entryDescription = item;
            }
            formattedEntry[entryName] = entryDescription ? {
                ...entryDescription,
                import: entryImport
            } : entryImport;
        }
        return config.entry = formattedEntry, config;
    }
    let configChain_CHAIN_ID = {
        RULE: {
            MJS: 'mjs',
            FONT: 'font',
            IMAGE: 'image',
            MEDIA: 'media',
            JS: 'js',
            JS_DATA_URI: 'js-data-uri',
            TS: 'ts',
            CSS: 'css',
            LESS: 'less',
            SASS: 'sass',
            STYLUS: 'stylus',
            SVG: 'svg',
            PUG: 'pug',
            VUE: 'vue',
            WASM: 'wasm',
            SVELTE: 'svelte'
        },
        ONE_OF: {
            SVG: 'svg',
            SVG_URL: 'svg-asset-url',
            SVG_ASSET: 'svg-asset',
            SVG_REACT: 'svg-react',
            SVG_INLINE: 'svg-asset-inline'
        },
        USE: {
            TS: 'ts',
            CSS: 'css',
            SASS: 'sass',
            LESS: 'less',
            STYLUS: 'stylus',
            URL: 'url',
            PUG: 'pug',
            VUE: 'vue',
            SWC: 'swc',
            SVGR: 'svgr',
            BABEL: 'babel',
            STYLE: 'style-loader',
            SVELTE: 'svelte',
            POSTCSS: 'postcss',
            LIGHTNINGCSS: 'lightningcss',
            IGNORE_CSS: 'ignore-css',
            CSS_MODULES_TS: 'css-modules-typescript',
            MINI_CSS_EXTRACT: 'mini-css-extract',
            RESOLVE_URL: 'resolve-url-loader'
        },
        PLUGIN: {
            HMR: 'hmr',
            COPY: 'copy',
            HTML: 'html',
            DEFINE: 'define',
            PROGRESS: 'progress',
            MANIFEST: 'webpack-manifest',
            TS_CHECKER: 'ts-checker',
            BUNDLE_ANALYZER: 'bundle-analyze',
            MODULE_FEDERATION: 'module-federation',
            HTML_PREFETCH: 'html-prefetch-plugin',
            HTML_PRELOAD: 'html-preload-plugin',
            MINI_CSS_EXTRACT: 'mini-css-extract',
            VUE_LOADER_PLUGIN: 'vue-loader-plugin',
            REACT_FAST_REFRESH: 'react-fast-refresh',
            SUBRESOURCE_INTEGRITY: 'subresource-integrity',
            AUTO_SET_ROOT_SIZE: 'auto-set-root-size'
        },
        MINIMIZER: {
            JS: 'js',
            CSS: 'css'
        },
        RESOLVE_PLUGIN: {
            TS_CONFIG_PATHS: 'ts-config-paths'
        }
    };
    async function modifyRspackConfig(context, rspackConfig, utils) {
        var _utils_environment_config_tools;
        rslog_index_js_namespaceObject.logger.debug('modify Rspack config');
        let [modifiedConfig] = await context.hooks.modifyRspackConfig.callInEnvironment({
            environment: utils.environment.name,
            args: [
                rspackConfig,
                utils
            ]
        });
        return (null === (_utils_environment_config_tools = utils.environment.config.tools) || void 0 === _utils_environment_config_tools ? void 0 : _utils_environment_config_tools.rspack) && (modifiedConfig = await reduceConfigsAsyncWithContext({
            initial: modifiedConfig,
            config: utils.environment.config.tools.rspack,
            ctx: utils,
            mergeFn: utils.mergeConfig
        })), rslog_index_js_namespaceObject.logger.debug('modify Rspack config done'), modifiedConfig;
    }
    async function getConfigUtils(config, chainUtils) {
        let { merge } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/webpack-merge/index.js"));
        return {
            ...chainUtils,
            rspack: core_namespaceObject.rspack,
            mergeConfig: merge,
            addRules (rules) {
                let ruleArr = castArray(rules);
                !config.module && (config.module = {}), !config.module.rules && (config.module.rules = []), config.module.rules.unshift(...ruleArr);
            },
            appendRules (rules) {
                let ruleArr = castArray(rules);
                !config.module && (config.module = {}), !config.module.rules && (config.module.rules = []), config.module.rules.push(...ruleArr);
            },
            prependPlugins (plugins) {
                let pluginArr = castArray(plugins);
                !config.plugins && (config.plugins = []), config.plugins.unshift(...pluginArr);
            },
            appendPlugins (plugins) {
                let pluginArr = castArray(plugins);
                !config.plugins && (config.plugins = []), config.plugins.push(...pluginArr);
            },
            removePlugin (pluginName) {
                if (!!config.plugins) config.plugins = config.plugins.filter((plugin)=>!plugin || (plugin.name || plugin.constructor.name) !== pluginName);
            }
        };
    }
    function getChainUtils(target, environment) {
        return {
            environment,
            env: getNodeEnv(),
            target,
            isDev: 'development' === environment.config.mode,
            isProd: 'production' === environment.config.mode,
            isServer: 'node' === target,
            isWebWorker: 'web-worker' === target,
            CHAIN_ID: configChain_CHAIN_ID,
            HtmlPlugin: getHTMLPlugin()
        };
    }
    async function generateRspackConfig({ target, context, environment }) {
        let chainUtils = getChainUtils(target, context.environments[environment]), { BannerPlugin, DefinePlugin, IgnorePlugin, ProvidePlugin, HotModuleReplacementPlugin } = core_namespaceObject.rspack, rspackConfig = chainToConfig(await modifyBundlerChain(context, {
            ...chainUtils,
            bundler: {
                BannerPlugin,
                DefinePlugin,
                IgnorePlugin,
                ProvidePlugin,
                HotModuleReplacementPlugin
            }
        }));
        if ((rspackConfig = await modifyRspackConfig(context, rspackConfig, await getConfigUtils(rspackConfig, chainUtils))).plugins) {
            for (let plugin of rspackConfig.plugins)if (plugin && void 0 === plugin.apply && 'name' in plugin && 'setup' in plugin) {
                let name = index_js_default().bold(index_js_default().yellow(plugin.name));
                throw Error(`[rsbuild:plugin] "${name}" appears to be an Rsbuild plugin. It cannot be used as an Rspack plugin.`);
            }
        }
        return rspackConfig;
    }
    async function modifyRsbuildConfig(context) {
        rslog_index_js_namespaceObject.logger.debug('modify Rsbuild config');
        let [modified] = await context.hooks.modifyRsbuildConfig.call(context.config, {
            mergeRsbuildConfig: mergeRsbuildConfig
        });
        context.config = modified, rslog_index_js_namespaceObject.logger.debug('modify Rsbuild config done');
    }
    async function modifyEnvironmentConfig(context, config, name) {
        rslog_index_js_namespaceObject.logger.debug(`modify Rsbuild environment(${name}) config`);
        let [modified] = await context.hooks.modifyEnvironmentConfig.callInEnvironment({
            environment: name,
            args: [
                config,
                {
                    name,
                    mergeEnvironmentConfig: mergeRsbuildConfig
                }
            ]
        });
        return rslog_index_js_namespaceObject.logger.debug(`modify Rsbuild environment(${name}) config done`), modified;
    }
    let initEnvironmentConfigs = (normalizedConfig, rootPath, specifiedEnvironments)=>{
        let defaultEntry;
        let getDefaultEntryWithMemo = ()=>(!defaultEntry && (defaultEntry = function(root) {
                let entryFile = findExists([
                    'ts',
                    'js',
                    'tsx',
                    'jsx',
                    'mjs',
                    'cjs'
                ].map((ext)=>(0, external_node_path_.join)(root, `src/index.${ext}`)));
                return entryFile ? {
                    index: entryFile
                } : {};
            }(rootPath)), defaultEntry), { environments, dev, server, provider, ...rsbuildSharedConfig } = normalizedConfig, isEnvironmentEnabled = (name)=>!specifiedEnvironments || specifiedEnvironments.includes(name), applyEnvironmentDefaultConfig = (config)=>{
            (!config.source.entry || 0 === Object.keys(config.source.entry).length) && (config.source.entry = getDefaultEntryWithMemo());
            let isServer = 'node' === config.output.target;
            return void 0 === config.output.distPath.js && (config.output.distPath.js = isServer ? '' : 'static/js'), config;
        };
        if (environments && Object.keys(environments).length) {
            let resolvedEnvironments = Object.fromEntries(Object.entries(environments).filter(([name])=>isEnvironmentEnabled(name)).map(([name, config])=>[
                    name,
                    applyEnvironmentDefaultConfig({
                        ...mergeRsbuildConfig({
                            ...rsbuildSharedConfig,
                            dev: pick(dev, [
                                'writeToDisk',
                                'hmr',
                                'assetPrefix',
                                'progressBar',
                                'lazyCompilation'
                            ])
                        }, config)
                    })
                ]));
            if (!Object.keys(resolvedEnvironments).length) throw Error(`[rsbuild:config] The current build is specified to run only in the ${index_js_default().yellow(null == specifiedEnvironments ? void 0 : specifiedEnvironments.join(','))} environment, but the configuration of the specified environment was not found.`);
            return resolvedEnvironments;
        }
        let defaultEnvironmentName = camelCase(rsbuildSharedConfig.output.target);
        if (!isEnvironmentEnabled(defaultEnvironmentName)) throw Error(`[rsbuild:config] The current build is specified to run only in the ${index_js_default().yellow(null == specifiedEnvironments ? void 0 : specifiedEnvironments.join(','))} environment, but the configuration of the specified environment was not found.`);
        return {
            [defaultEnvironmentName]: applyEnvironmentDefaultConfig({
                ...rsbuildSharedConfig,
                dev: pick(dev, [
                    'hmr',
                    'assetPrefix',
                    'progressBar',
                    'lazyCompilation',
                    'writeToDisk'
                ])
            })
        };
    };
    async function initRsbuildConfig({ context, pluginManager }) {
        if (context.normalizedConfig) return context.normalizedConfig;
        await initPlugins({
            getPluginAPI: context.getPluginAPI,
            pluginManager
        }), await modifyRsbuildConfig(context);
        let normalizeBaseConfig = normalizeConfig(context.config), environments = {}, mergedEnvironments = initEnvironmentConfigs(normalizeBaseConfig, context.rootPath, context.specifiedEnvironments), { dev: { hmr, assetPrefix, progressBar, lazyCompilation, writeToDisk, ...rsbuildSharedDev }, server } = normalizeBaseConfig;
        for (let [name, config] of Object.entries(mergedEnvironments)){
            let environmentConfig = await modifyEnvironmentConfig(context, config, name);
            environments[name] = {
                ...environmentConfig,
                dev: {
                    ...environmentConfig.dev,
                    ...rsbuildSharedDev
                },
                server
            };
        }
        return context.normalizedConfig = {
            ...normalizeBaseConfig,
            environments
        }, await updateEnvironmentContext(context, environments), !function(context) {
            let distPaths = Object.values(context.environments).map((item)=>item.distPath);
            context.distPath = function(paths) {
                let uniquePaths = [
                    ...new Set(paths)
                ];
                if (1 === uniquePaths.length) return uniquePaths[0];
                let [first, ...rest] = uniquePaths.map((p)=>p.split(external_node_path_.sep)), common = [];
                for(let i = 0; i < first.length; i++){
                    let segment = first[i];
                    if (rest.every((p)=>p[i] === segment)) common.push(segment);
                    else break;
                }
                return common.join(external_node_path_.sep);
            }(distPaths);
        }(context), context.normalizedConfig;
    }
    async function initConfigs({ context, pluginManager, rsbuildOptions }) {
        let normalizedConfig = await initRsbuildConfig({
            context,
            pluginManager
        }), rspackConfigs = await Promise.all(Object.entries(normalizedConfig.environments).map(([environment, config])=>generateRspackConfig({
                target: config.output.target,
                context,
                environment
            })));
        if (isDebug()) {
            let inspect = async ()=>{
                await inspectConfig({
                    context,
                    pluginManager,
                    inspectOptions: {
                        verbose: !0,
                        writeToDisk: !0
                    },
                    rsbuildOptions,
                    bundlerConfigs: rspackConfigs
                });
            };
            context.hooks.onBeforeBuild.tap(async ({ isFirstCompile })=>{
                isFirstCompile && await inspect();
            }), context.hooks.onAfterStartDevServer.tap(inspect);
        }
        return {
            rspackConfigs
        };
    }
    let external_node_readline_namespaceObject = require("node:readline");
    var external_node_readline_default = __webpack_require__.n(external_node_readline_namespaceObject);
    let isCliShortcutsEnabled = (devConfig)=>devConfig.cliShortcuts && isTTY('stdin');
    function setupCliShortcuts({ help = !0, openPage, closeServer, printUrls, restartServer, customShortcuts }) {
        let shortcuts = [
            {
                key: 'c',
                description: `${index_js_default().bold('c + enter')}  ${index_js_default().dim('clear console')}`,
                action: ()=>{
                    console.clear();
                }
            },
            {
                key: 'o',
                description: `${index_js_default().bold('o + enter')}  ${index_js_default().dim('open in browser')}`,
                action: openPage
            },
            {
                key: 'q',
                description: `${index_js_default().bold('q + enter')}  ${index_js_default().dim('quit process')}`,
                action: async ()=>{
                    try {
                        await closeServer();
                    } finally{
                        process.exit(0);
                    }
                }
            },
            restartServer ? {
                key: 'r',
                description: `${index_js_default().bold('r + enter')}  ${index_js_default().dim('restart server')}`,
                action: restartServer
            } : null,
            {
                key: 'u',
                description: `${index_js_default().bold('u + enter')}  ${index_js_default().dim('show urls')}`,
                action: printUrls
            }
        ].filter(Boolean);
        if (customShortcuts && !Array.isArray(shortcuts = customShortcuts(shortcuts))) throw Error('[rsbuild:config] `dev.cliShortcuts` must return an array of shortcuts.');
        help && rslog_index_js_namespaceObject.logger.log(`  ➜ ${index_js_default().dim('press')} ${index_js_default().bold('h + enter')} ${index_js_default().dim('to show shortcuts')}\n`);
        let rl = external_node_readline_default().createInterface({
            input: process.stdin
        });
        return rl.on('line', (input)=>{
            if ('h' === input) {
                let message = `\n  ${index_js_default().bold(index_js_default().blue('Shortcuts:'))}\n`;
                for (let shortcut of shortcuts)message += `  ${shortcut.description}\n`;
                rslog_index_js_namespaceObject.logger.log(message);
            }
            for (let shortcut of shortcuts)if (input === shortcut.key) {
                shortcut.action();
                return;
            }
        }), ()=>{
            rl.close();
        };
    }
    let isClientCompiler = (compiler)=>{
        let { target } = compiler.options;
        return !!target && (Array.isArray(target) ? target.includes('web') : 'web' === target);
    }, isNodeCompiler = (compiler)=>{
        let { target } = compiler.options;
        return !!target && (Array.isArray(target) ? target.includes('node') : 'node' === target);
    }, setupServerHooks = (compiler, hookCallbacks)=>{
        if (isNodeCompiler(compiler)) return;
        let { compile, invalid, done } = compiler.hooks;
        compile.tap('rsbuild-dev-server', ()=>{
            hookCallbacks.onInvalid(getCompilationId(compiler));
        }), invalid.tap('rsbuild-dev-server', (fileName)=>{
            hookCallbacks.onInvalid(getCompilationId(compiler), fileName);
        }), done.tap('rsbuild-dev-server', hookCallbacks.onDone);
    }, getDevMiddleware = async (multiCompiler)=>{
        let { default: rsbuildDevMiddleware } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/rsbuild-dev-middleware/index.js"));
        return (options)=>{
            let { clientPaths, clientConfig, callbacks, liveReload, ...restOptions } = options;
            return applyToCompiler(multiCompiler, (compiler)=>{
                clientPaths && !function({ compiler, clientPaths, clientConfig = {}, liveReload = !0 }) {
                    if (!!isClientCompiler(compiler)) for (let clientPath of (new compiler.webpack.DefinePlugin({
                        RSBUILD_COMPILATION_NAME: JSON.stringify(getCompilationId(compiler)),
                        RSBUILD_CLIENT_CONFIG: JSON.stringify(clientConfig),
                        RSBUILD_DEV_LIVE_RELOAD: liveReload
                    }).apply(compiler), clientPaths))new compiler.webpack.EntryPlugin(compiler.context, clientPath, {
                        name: void 0
                    }).apply(compiler);
                }({
                    compiler,
                    clientPaths,
                    clientConfig,
                    liveReload
                }), setupServerHooks(compiler, callbacks);
            }), rsbuildDevMiddleware(multiCompiler, restOptions);
        };
    }, external_node_querystring_namespaceObject = require("node:querystring"), colors = {
        black: '#000',
        red: '#fb6a6a',
        green: '#6ef790',
        yellow: '#eff986',
        cyan: '#6eecf7',
        blue: '#6eb2f7',
        magenta: '#f76ebe',
        lightgrey: '#f0f0f0',
        darkgrey: '#888'
    }, styles = {
        30: 'black',
        31: 'red',
        32: 'green',
        33: 'yellow',
        34: 'blue',
        35: 'magenta',
        36: 'cyan',
        37: 'lightgrey'
    }, openTags = {
        1: 'font-weight:bold',
        2: 'opacity:0.5',
        3: '<i>',
        4: '<u>',
        8: 'display:none',
        9: '<del>'
    }, closeTags = {
        23: '</i>',
        24: '</u>',
        29: '</del>'
    };
    for (let n of [
        0,
        21,
        22,
        27,
        28,
        39,
        49
    ])closeTags[n.toString()] = '</span>';
    !function() {
        for(let code in openTags['90'] = `color:${colors.darkgrey}`, styles){
            let oriColor = colors[styles[code]] || colors.black;
            openTags[code] = `color:${oriColor}`;
        }
    }();
    let server_ansiHTML = function(text) {
        if (!RegExp(`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))`, 'g').test(text)) return text;
        let ansiCodes = [], ret = text.replace(/\x1B\[(\d+)m/g, (_match, seq)=>{
            let ot = openTags[seq];
            if (ot) return -1 !== ansiCodes.indexOf(seq) ? (ansiCodes.pop(), '</span>') : (ansiCodes.push(seq), '<' === ot[0] ? ot : `<span style="${ot}">`);
            let ct = closeTags[seq];
            return ct ? (ansiCodes.pop(), ct) : '';
        }), l = ansiCodes.length;
        return l > 0 && (ret += Array(l + 1).join('</span>')), ret;
    };
    function socketServer_define_property(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    class SocketServer {
        upgrade(req, sock, head) {
            if (!!this.wsServer.shouldHandle(req)) this.wsServer.handleUpgrade(req, sock, head, (connection)=>{
                this.wsServer.emit('connection', connection, req);
            });
        }
        async prepare() {
            var _this_options_client;
            let { default: ws } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/ws/index.js"));
            this.wsServer = new ws.Server({
                noServer: !0,
                path: null === (_this_options_client = this.options.client) || void 0 === _this_options_client ? void 0 : _this_options_client.path
            }), this.wsServer.on('error', (err)=>{
                rslog_index_js_namespaceObject.logger.error(err);
            }), this.timer = setInterval(()=>{
                for (let socket of this.wsServer.clients)socket.isAlive ? (socket.isAlive = !1, socket.ping(()=>{})) : socket.terminate();
            }, 30000), this.wsServer.on('connection', (socket, req)=>{
                let queryStr = req.url ? req.url.split('?')[1] : '';
                this.onConnect(socket, queryStr ? (0, external_node_querystring_namespaceObject.parse)(queryStr) : {});
            });
        }
        updateStats(stats) {
            let compilationId = getCompilationId(stats.compilation);
            this.stats[compilationId] = stats, this.sendStats({
                compilationId
            });
        }
        sockWrite({ type, compilationId, data }) {
            for (let socket of this.sockets)this.send(socket, JSON.stringify({
                type,
                data,
                compilationId
            }));
        }
        singleWrite(socket, { type, data, compilationId }) {
            this.send(socket, JSON.stringify({
                type,
                data,
                compilationId
            }));
        }
        close() {
            for (let socket of this.sockets)socket.close();
            this.timer && (clearInterval(this.timer), this.timer = null);
        }
        onConnect(socket, params) {
            if (socket.isAlive = !0, socket.on('pong', ()=>{
                socket.isAlive = !0;
            }), !!socket) this.sockets.push(socket), socket.on('close', ()=>{
                let idx = this.sockets.indexOf(socket);
                idx >= 0 && this.sockets.splice(idx, 1);
            }), (this.options.hmr || this.options.liveReload) && this.singleWrite(socket, {
                type: 'hot',
                compilationId: params.compilationId
            }), this.stats && this.sendStats({
                force: !0,
                compilationId: params.compilationId
            });
        }
        getStats(name) {
            let curStats = this.stats[name];
            if (!curStats) return null;
            let statsOptions = getStatsOptions(curStats.compilation.compiler);
            return curStats.toJson({
                all: !1,
                hash: !0,
                assets: !0,
                warnings: !0,
                warningsCount: !0,
                errors: !0,
                errorsCount: !0,
                errorDetails: !1,
                entrypoints: !0,
                children: !0,
                moduleTrace: !0,
                ...statsOptions
            });
        }
        sendStats({ force = !1, compilationId }) {
            let stats = this.getStats(compilationId);
            if (!stats) return null;
            let newInitialChunks = new Set();
            if (stats.entrypoints) for (let entrypoint of Object.values(stats.entrypoints)){
                let chunks = entrypoint.chunks;
                if (!!Array.isArray(chunks)) for (let chunkName of chunks){
                    if (!!chunkName) newInitialChunks.add(String(chunkName));
                }
            }
            let initialChunks = this.initialChunks[compilationId], shouldReload = !!stats.entrypoints && !!initialChunks && !function(a, b) {
                if (a.size !== b.size) return !1;
                for (let v of a.values())if (!b.has(v)) return !1;
                return !0;
            }(initialChunks, newInitialChunks);
            if (this.initialChunks[compilationId] = newInitialChunks, shouldReload) return this.sockWrite({
                type: 'content-changed',
                compilationId
            });
            if (!force && stats && !stats.errorsCount && stats.assets && stats.assets.every((asset)=>!asset.emitted)) return this.sockWrite({
                type: 'still-ok',
                compilationId
            });
            if (this.sockWrite({
                type: 'hash',
                compilationId,
                data: stats.hash
            }), stats.errorsCount) {
                let { errors: formattedErrors } = formatStatsMessages({
                    errors: getAllStatsErrors(stats),
                    warnings: []
                });
                return this.sockWrite({
                    type: 'errors',
                    compilationId,
                    data: {
                        text: formattedErrors,
                        html: formattedErrors.map((item)=>{
                            var text;
                            return server_ansiHTML((text = item) ? text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;') : '');
                        })
                    }
                });
            }
            if (stats.warningsCount) {
                let { warnings: formattedWarnings } = formatStatsMessages({
                    warnings: getAllStatsWarnings(stats),
                    errors: []
                });
                return this.sockWrite({
                    type: 'warnings',
                    compilationId,
                    data: {
                        text: formattedWarnings
                    }
                });
            }
            return this.sockWrite({
                type: 'ok',
                compilationId
            });
        }
        send(connection, message) {
            if (1 === connection.readyState) connection.send(message);
        }
        constructor(options){
            socketServer_define_property(this, "wsServer", void 0), socketServer_define_property(this, "sockets", []), socketServer_define_property(this, "options", void 0), socketServer_define_property(this, "stats", void 0), socketServer_define_property(this, "initialChunks", void 0), socketServer_define_property(this, "timer", null), this.options = options, this.stats = {}, this.initialChunks = {};
        }
    }
    function compilerDevMiddleware_define_property(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    let compilerDevMiddleware_require = (0, external_node_module_namespaceObject.createRequire)(__rslib_import_meta_url__), formatDevConfig = (config, environments)=>{
        let writeToDiskValues = Object.values(environments).map((env)=>env.config.dev.writeToDisk);
        return 1 === new Set(writeToDiskValues).size ? {
            ...config,
            writeToDisk: writeToDiskValues[0]
        } : {
            ...config,
            writeToDisk (filePath, compilationName) {
                let { writeToDisk } = config;
                return compilationName && environments[compilationName] && (writeToDisk = environments[compilationName].config.dev.writeToDisk ?? writeToDisk), 'function' == typeof writeToDisk ? writeToDisk(filePath) : writeToDisk;
            }
        };
    };
    class CompilerDevMiddleware {
        async init() {
            let devMiddleware = await getDevMiddleware(this.compiler);
            this.middleware = this.setupDevMiddleware(devMiddleware, this.publicPaths), await this.socketServer.prepare();
        }
        upgrade(req, sock, head) {
            this.socketServer.upgrade(req, sock, head);
        }
        async close() {
            this.socketServer.close(), this.middleware && await new Promise((resolve)=>{
                this.middleware.close(()=>{
                    resolve();
                });
            }), await new Promise((resolve)=>{
                this.compiler.close(()=>{
                    resolve();
                });
            });
        }
        sockWrite(type, data) {
            this.socketServer.sockWrite({
                type,
                data
            });
        }
        setupDevMiddleware(devMiddleware, publicPaths) {
            let { devConfig, serverConfig: { headers, base } } = this, middleware = devMiddleware({
                headers,
                publicPath: '/',
                stats: !1,
                callbacks: {
                    onInvalid: (compilationId, fileName)=>{
                        if ('string' == typeof fileName && HTML_REGEX.test(fileName)) {
                            this.socketServer.sockWrite({
                                type: 'content-changed',
                                compilationId
                            });
                            return;
                        }
                        this.socketServer.sockWrite({
                            type: 'invalid',
                            compilationId
                        });
                    },
                    onDone: (stats)=>{
                        this.socketServer.updateStats(stats);
                    }
                },
                clientPaths: function(devConfig) {
                    var _devConfig_client;
                    let clientPaths = [];
                    return devConfig.hmr || devConfig.liveReload ? (clientPaths.push(compilerDevMiddleware_require.resolve('@rsbuild/core/client/hmr')), (null === (_devConfig_client = devConfig.client) || void 0 === _devConfig_client ? void 0 : _devConfig_client.overlay) && clientPaths.push(`${compilerDevMiddleware_require.resolve('@rsbuild/core/client/overlay')}`), clientPaths) : clientPaths;
                }(devConfig),
                clientConfig: devConfig.client,
                liveReload: devConfig.liveReload,
                writeToDisk: devConfig.writeToDisk,
                serverSideRender: !0,
                etag: 'weak'
            }), assetPrefixes = publicPaths.map(pathnameParse).map((prefix)=>base && '/' !== base ? stripBase(prefix, base) : prefix), warp = async (req, res, next)=>{
                let { url } = req, assetPrefix = url && assetPrefixes.find((prefix)=>url.startsWith(prefix));
                assetPrefix && '/' !== assetPrefix ? (req.url = url.slice(assetPrefix.length - 1), middleware(req, res, (...args)=>{
                    req.url = url, next(...args);
                })) : middleware(req, res, next);
            };
            return warp.close = middleware.close, warp;
        }
        constructor({ dev, server, compiler, publicPaths, environments }){
            compilerDevMiddleware_define_property(this, "middleware", void 0), compilerDevMiddleware_define_property(this, "devConfig", void 0), compilerDevMiddleware_define_property(this, "serverConfig", void 0), compilerDevMiddleware_define_property(this, "compiler", void 0), compilerDevMiddleware_define_property(this, "publicPaths", void 0), compilerDevMiddleware_define_property(this, "socketServer", void 0), this.devConfig = formatDevConfig(dev, environments), this.serverConfig = server, this.compiler = compiler, this.publicPaths = publicPaths, this.socketServer = new SocketServer(dev);
        }
    }
    let external_node_vm_namespaceObject = require("node:vm");
    var external_node_vm_default = __webpack_require__.n(external_node_vm_namespaceObject);
    let SYNTHETIC_MODULES_STORE = '__SYNTHETIC_MODULES_STORE', asModule = async (something, context, unlinked)=>{
        if (something instanceof external_node_vm_default().Module) return something;
        context[SYNTHETIC_MODULES_STORE] = context[SYNTHETIC_MODULES_STORE] || [];
        let i = context[SYNTHETIC_MODULES_STORE].length;
        context[SYNTHETIC_MODULES_STORE].push(something);
        let code = [
            ...new Set([
                'default',
                ...Object.keys(something)
            ])
        ].map((name)=>`const _${name} = ${SYNTHETIC_MODULES_STORE}[${i}]${'default' === name ? '' : `[${JSON.stringify(name)}]`}; export { _${name} as ${name}};`).join('\n'), m = new (external_node_vm_default()).SourceTextModule(code, {
            context
        });
        return unlinked ? m : (await m.link(()=>{}), m.instantiate && m.instantiate(), await m.evaluate(), m);
    };
    function basic_define_property(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    let isRelativePath = (p)=>/^\.\.?\//.test(p), getSubPath = (p)=>{
        let lastSlash = p.lastIndexOf('/'), firstSlash = p.indexOf('/');
        if (-1 !== lastSlash && firstSlash !== lastSlash) {
            if (-1 !== firstSlash) {
                let next = p.indexOf('/', firstSlash + 1), dir = p.slice(firstSlash + 1, next);
                for(; '.' === dir;)firstSlash = next, next = p.indexOf('/', firstSlash + 1), dir = p.slice(firstSlash + 1, next);
            }
            return p.slice(firstSlash + 1, lastSlash + 1);
        }
        return '';
    };
    class BasicRunner {
        run(file) {
            !this.globalContext && (this.globalContext = this.createGlobalContext()), this.baseModuleScope = this.createBaseModuleScope(), this.createRunner();
            let res = this.getRequire()(this._options.dist, file.startsWith('./') ? file : `./${file}`);
            return 'object' == typeof res && 'then' in res ? res : Promise.resolve(res);
        }
        getRequire() {
            let entryRequire = this.requirers.get('entry');
            return (currentDirectory, modulePath, context = {})=>entryRequire(currentDirectory, Array.isArray(modulePath) ? modulePath : modulePath.split('?')[0], context);
        }
        getFile(modulePath, currentDirectory) {
            if (Array.isArray(modulePath)) return {
                path: external_node_path_default().join(currentDirectory, '.array-require.js'),
                content: `module.exports = (${modulePath.map((arg)=>`require(${JSON.stringify(`./${arg}`)})`).join(', ')});`,
                subPath: ''
            };
            if (isRelativePath(modulePath)) {
                let p = external_node_path_default().join(currentDirectory, modulePath);
                return {
                    path: p,
                    content: this._options.readFileSync(p),
                    subPath: getSubPath(modulePath)
                };
            }
            return null;
        }
        preExecute(_code, _file) {}
        postExecute(_m, _file) {}
        createRunner() {
            this.requirers.set('entry', (_currentDirectory, _modulePath, _context = {})=>{
                throw Error('[rsbuild:runner] Not implement');
            });
        }
        constructor(_options){
            basic_define_property(this, "_options", void 0), basic_define_property(this, "globalContext", void 0), basic_define_property(this, "baseModuleScope", void 0), basic_define_property(this, "requirers", void 0), this._options = _options, this.globalContext = null, this.baseModuleScope = null, this.requirers = new Map();
        }
    }
    let cjs_require = (0, external_node_module_namespaceObject.createRequire)(__rslib_import_meta_url__), cjs_define = (...args)=>{
        args.pop()();
    };
    class CommonJsRunner extends BasicRunner {
        createGlobalContext() {
            return {
                console: console,
                setTimeout: (cb, ms, ...args)=>{
                    let timeout = setTimeout(cb, ms, ...args);
                    return timeout.unref(), timeout;
                },
                clearTimeout: clearTimeout,
                queueMicrotask
            };
        }
        createBaseModuleScope() {
            return {
                console: this.globalContext.console,
                setTimeout: this.globalContext.setTimeout,
                clearTimeout: this.globalContext.clearTimeout,
                nsObj: (m)=>(Object.defineProperty(m, Symbol.toStringTag, {
                        value: 'Module'
                    }), m),
                queueMicrotask
            };
        }
        createModuleScope(requireFn, m, file) {
            return {
                ...this.baseModuleScope,
                require: requireFn.bind(null, external_node_path_default().dirname(file.path)),
                module: m,
                exports: m.exports,
                __dirname: external_node_path_default().dirname(file.path),
                __filename: file.path,
                define: cjs_define
            };
        }
        createRunner() {
            this.requirers.set('miss', this.createMissRequirer()), this.requirers.set('entry', this.createCjsRequirer());
        }
        createMissRequirer() {
            return (_currentDirectory, modulePath, _context = {})=>cjs_require(modulePath.startsWith('node:') ? modulePath.slice(5) : modulePath);
        }
        createCjsRequirer() {
            let requireCache = Object.create(null);
            return (currentDirectory, modulePath, context = {})=>{
                let file = context.file || this.getFile(modulePath, currentDirectory);
                if (!file) return this.requirers.get('miss')(currentDirectory, modulePath);
                if (file.path in requireCache) return requireCache[file.path].exports;
                let m = {
                    exports: {}
                };
                requireCache[file.path] = m;
                let currentModuleScope = this.createModuleScope(this.getRequire(), m, file), args = Object.keys(currentModuleScope), argValues = args.map((arg)=>currentModuleScope[arg]), code = `(function(${args.join(', ')}) {
        ${file.content}
      })`;
                return this.preExecute(code, file), (this._options.runInNewContext ? external_node_vm_default().runInNewContext(code, this.globalContext, file.path) : external_node_vm_default().runInThisContext(code, file.path)).call(m.exports, ...argValues), this.postExecute(m, file), m.exports;
            };
        }
    }
    var type_EsmMode = function(EsmMode) {
        return EsmMode[EsmMode.Unknown = 0] = "Unknown", EsmMode[EsmMode.Evaluated = 1] = "Evaluated", EsmMode[EsmMode.Unlinked = 2] = "Unlinked", EsmMode;
    }({});
    class EsmRunner extends CommonJsRunner {
        createRunner() {
            super.createRunner(), this.requirers.set('cjs', this.getRequire()), this.requirers.set('esm', this.createEsmRequirer()), this.requirers.set('entry', (currentDirectory, modulePath, context)=>{
                var _this__options_compilerOptions_experiments;
                let file = this.getFile(modulePath, currentDirectory);
                return file ? file.path.endsWith('.mjs') && (null === (_this__options_compilerOptions_experiments = this._options.compilerOptions.experiments) || void 0 === _this__options_compilerOptions_experiments ? void 0 : _this__options_compilerOptions_experiments.outputModule) ? this.requirers.get('esm')(currentDirectory, modulePath, {
                    ...context,
                    file
                }) : this.requirers.get('cjs')(currentDirectory, modulePath, {
                    ...context,
                    file
                }) : this.requirers.get('miss')(currentDirectory, modulePath);
            });
        }
        createEsmRequirer() {
            let esmContext = external_node_vm_default().createContext(this.baseModuleScope, {
                name: 'context for esm'
            }), esmCache = new Map(), esmIdentifier = this._options.name;
            return (currentDirectory, modulePath, context = {})=>{
                if (!external_node_vm_default().SourceTextModule) throw Error('[rsbuild:runner] Running ESM bundle needs add Node.js option "--experimental-vm-modules".');
                let _require = this.getRequire(), file = context.file || this.getFile(modulePath, currentDirectory);
                if (!file) return this.requirers.get('miss')(currentDirectory, modulePath);
                let esm = esmCache.get(file.path);
                return (!esm && (esm = new (external_node_vm_default()).SourceTextModule(file.content, {
                    identifier: `${esmIdentifier}-${file.path}`,
                    url: `${(0, external_node_url_namespaceObject.pathToFileURL)(file.path).href}?${esmIdentifier}`,
                    context: esmContext,
                    initializeImportMeta: (meta, _)=>{
                        meta.url = (0, external_node_url_namespaceObject.pathToFileURL)(file.path).href;
                    },
                    importModuleDynamically: async (specifier, module)=>{
                        let result = await _require(external_node_path_default().dirname(file.path), specifier, {
                            esmMode: type_EsmMode.Evaluated
                        });
                        return await asModule(result, module.context);
                    }
                }), esmCache.set(file.path, esm)), context.esmMode === type_EsmMode.Unlinked) ? esm : (async ()=>{
                    if (await esm.link(async (specifier, referencingModule)=>await asModule(await _require(external_node_path_default().dirname(referencingModule.identifier ? referencingModule.identifier.slice(esmIdentifier.length + 1) : (0, external_node_url_namespaceObject.fileURLToPath)(referencingModule.url)), specifier, {
                            esmMode: type_EsmMode.Unlinked
                        }), referencingModule.context, !0)), esm.instantiate && esm.instantiate(), await esm.evaluate(), context.esmMode === type_EsmMode.Evaluated) return esm;
                    let ns = esm.namespace;
                    return ns.default && ns.default instanceof Promise ? ns.default : ns;
                })();
            };
        }
    }
    class BasicRunnerFactory {
        create(compilerOptions, dist, readFileSync) {
            return this.createRunner(compilerOptions, dist, readFileSync);
        }
        createRunner(compilerOptions, dist, readFileSync) {
            let runnerOptions = {
                name: this.name,
                dist,
                compilerOptions,
                readFileSync
            };
            if ('web' === compilerOptions.target || 'webworker' === compilerOptions.target) throw Error(`[rsbuild:runner] Not support run "${compilerOptions.target}" resource in Rsbuild server`);
            return new EsmRunner(runnerOptions);
        }
        constructor(name){
            !function(obj, key, value) {
                key in obj ? Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : obj[key] = value;
            }(this, "name", void 0), this.name = name;
        }
    }
    let run = async (bundlePath, outputPath, compilerOptions, readFileSync)=>new BasicRunnerFactory(bundlePath).create(compilerOptions, outputPath, readFileSync).run(bundlePath), loadBundle = async (stats, entryName, utils)=>{
        let { chunks, entrypoints, outputPath } = stats.toJson({
            all: !1,
            chunks: !0,
            entrypoints: !0,
            outputPath: !0
        });
        if (!(null == entrypoints ? void 0 : entrypoints[entryName])) throw Error(`[rsbuild:loadBundle] Can't find entry: "${entryName}"`);
        let { chunks: entryChunks = [] } = entrypoints[entryName], files = entryChunks.reduce((prev, entryChunkName)=>{
            let chunk = null == chunks ? void 0 : chunks.find((chunk)=>{
                var _chunk_names;
                return chunk.entry && (null === (_chunk_names = chunk.names) || void 0 === _chunk_names ? void 0 : _chunk_names.includes(String(entryChunkName)));
            });
            return (null == chunk ? void 0 : chunk.files) ? prev.concat(chunk.files.filter((file)=>!file.endsWith('.css'))) : prev;
        }, []);
        if (0 === files.length) throw Error(`[rsbuild:loadBundle] Failed to get bundle by entryName: "${entryName}"`);
        if (files.length > 1) throw Error(`[rsbuild:loadBundle] Only support load single entry chunk, but got ${files.length}: ${files.join(',')}`);
        return await run(files[0], outputPath, stats.compilation.options, utils.readFileSync);
    }, getTransformedHtml = async (entryName, utils)=>{
        let { htmlPaths, distPath } = utils.environment, htmlPath = htmlPaths[entryName];
        if (!htmlPath) throw Error(`[rsbuild:getTransformedHtml] Failed to get HTML file by entryName: "${entryName}"`);
        let fileName = (0, external_node_path_.join)(distPath, htmlPath);
        return utils.readFileSync(fileName);
    }, createCacheableFunction = (getter)=>{
        let cache = new WeakMap();
        return async (stats, entryName, utils)=>{
            let cachedEntries = cache.get(stats);
            if (null == cachedEntries ? void 0 : cachedEntries[entryName]) return cachedEntries[entryName];
            let res = await getter(stats, entryName, utils);
            return cache.set(stats, {
                ...cachedEntries || {},
                [entryName]: res
            }), res;
        };
    }, ENCODING_REGEX = /\bgzip\b/, CONTENT_TYPE_REGEX = /text|javascript|\/json|xml/i, shouldCompress = (res)=>{
        if (res.getHeader('Content-Encoding')) return !1;
        let contentType = String(res.getHeader('Content-Type'));
        if (contentType && !CONTENT_TYPE_REGEX.test(contentType)) return !1;
        let size = res.getHeader('Content-Length');
        return void 0 === size || Number(size) > 1024;
    }, gzipMiddleware = ({ level = external_node_zlib_default().constants.Z_BEST_SPEED } = {})=>(req, res, next)=>{
            let gzip, writeHeadStatus;
            let accept = req.headers['accept-encoding'], encoding = 'string' == typeof accept && ENCODING_REGEX.test(accept);
            if ('HEAD' === req.method || !encoding) {
                next();
                return;
            }
            let started = !1, { end, write, on, writeHead } = res, listeners = [], start = ()=>{
                if (!started) {
                    if (started = !0, shouldCompress(res)) for (let listener of (res.setHeader('Content-Encoding', 'gzip'), res.removeHeader('Content-Length'), (gzip = external_node_zlib_default().createGzip({
                        level
                    })).on('data', (chunk)=>{
                        !1 === write.call(res, chunk) && gzip.pause();
                    }), on.call(res, 'drain', ()=>gzip.resume()), gzip.on('end', ()=>{
                        end.call(res);
                    }), listeners))gzip.on.apply(gzip, listener);
                    else for (let listener of listeners)on.apply(res, listener);
                    writeHead.call(res, writeHeadStatus ?? res.statusCode);
                }
            };
            res.writeHead = (status, reason, headers)=>{
                if (reason) for (let [key, value] of Object.entries(headers || reason))res.setHeader(key, value);
                return writeHeadStatus = status, res;
            }, res.write = (...args)=>(start(), gzip ? gzip.write(...args) : write.apply(res, args)), res.end = (...args)=>(start(), gzip ? gzip.end(...args) : end.apply(res, args)), res.on = (type, listener)=>(started ? gzip && 'drain' === type ? gzip.on(type, listener) : on.call(res, type, listener) : listeners.push([
                    type,
                    listener
                ]), res), next();
        }, faviconFallbackMiddleware = (req, res, next)=>{
        '/favicon.ico' === req.url ? (res.statusCode = 204, res.end()) : next();
    }, getStatusCodeColor = (status)=>status >= 500 ? index_js_default().red : status >= 400 ? index_js_default().yellow : status >= 300 ? index_js_default().cyan : status >= 200 ? index_js_default().green : (res)=>res, getRequestLoggerMiddleware = async ()=>{
        let { default: onFinished } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/on-finished/index.js"));
        return (req, res, next)=>{
            let _startAt = process.hrtime();
            onFinished(res, ()=>{
                let method = req.method, url = req.originalUrl || req.url, status = Number(res.statusCode), statusColor = getStatusCodeColor(status), endAt = process.hrtime(), totalTime = (endAt[0] - _startAt[0]) * 1e3 + (endAt[1] - _startAt[1]) * 1e-6;
                rslog_index_js_namespaceObject.logger.debug(`${statusColor(status)} ${method} ${index_js_default().gray(url)} ${index_js_default().gray(`${totalTime.toFixed(3)} ms`)}`);
            }), next();
        };
    }, notFoundMiddleware = (_req, res, _next)=>{
        res.statusCode = 404, res.end();
    }, middlewares_isFileExists = async (filePath, outputFileSystem)=>new Promise((resolve)=>{
            outputFileSystem.stat(filePath, (_error, stats)=>{
                resolve(null == stats ? void 0 : stats.isFile());
            });
        }), maybeHTMLRequest = (req)=>{
        if (!req.url || !req.headers || 'GET' !== req.method && 'HEAD' !== req.method) return !1;
        let { accept } = req.headers;
        return 'string' == typeof accept && (accept.includes('text/html') || accept.includes('*/*'));
    }, postfixRE = /[?#].*$/, getUrlPathname = (url)=>url.replace(postfixRE, ''), getHtmlCompletionMiddleware = ({ distPath, callback, outputFileSystem })=>async (req, res, next)=>{
            if (!maybeHTMLRequest(req)) return next();
            let pathname = getUrlPathname(req.url), rewrite = (newUrl)=>(req.url = newUrl, callback(req, res, (...args)=>{
                    next(...args);
                }));
            if (pathname.endsWith('/')) {
                let newUrl = `${pathname}index.html`, filePath = external_node_path_default().join(distPath, newUrl);
                if (await middlewares_isFileExists(filePath, outputFileSystem)) return rewrite(newUrl);
            } else if (!external_node_path_default().extname(pathname)) {
                let newUrl = `${pathname}.html`, filePath = external_node_path_default().join(distPath, newUrl);
                if (await middlewares_isFileExists(filePath, outputFileSystem)) return rewrite(newUrl);
            }
            next();
        }, getBaseMiddleware = ({ base })=>async (req, res, next)=>{
            var _req_headers_accept;
            let url = req.url, pathname = getUrlPathname(url);
            if (pathname.startsWith(base)) return req.url = stripBase(url, base), next();
            let redirectPath = addTrailingSlash(url) !== base ? joinUrlSegments(base, url) : base;
            if ('/' === pathname || '/index.html' === pathname) {
                res.writeHead(302, {
                    Location: redirectPath
                }), res.end();
                return;
            }
            if (null === (_req_headers_accept = req.headers.accept) || void 0 === _req_headers_accept ? void 0 : _req_headers_accept.includes('text/html')) {
                res.writeHead(404, {
                    'Content-Type': 'text/html'
                }), res.end(`The server is configured with a base URL of ${base} - did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`);
                return;
            }
            res.writeHead(404, {
                'Content-Type': 'text/plain'
            }), res.end(`The server is configured with a base URL of ${base} - did you mean to visit ${redirectPath} instead?`);
        }, getHtmlFallbackMiddleware = ({ htmlFallback, distPath, callback, outputFileSystem })=>async (req, res, next)=>{
            if (!maybeHTMLRequest(req) || '/favicon.ico' === req.url || 'index' !== htmlFallback) return next();
            let filePath = external_node_path_default().join(distPath, 'index.html');
            if (await middlewares_isFileExists(filePath, outputFileSystem)) {
                let newUrl = '/index.html';
                return 'verbose' === rslog_index_js_namespaceObject.logger.level && rslog_index_js_namespaceObject.logger.debug(`${req.method} ${index_js_default().gray(`${req.url} ${index_js_default().yellow('fallback')} to ${newUrl}`)}`), req.url = newUrl, callback(req, res, (...args)=>next(...args));
            }
            next();
        }, viewingServedFilesMiddleware = ({ environments })=>async (req, res, next)=>{
            if ('/rsbuild-dev-server' === getUrlPathname(req.url)) {
                res.writeHead(200, {
                    'Content-Type': 'text/html; charset=utf-8'
                }), res.write(`<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body {
        margin: 0;
        color: #f6f7f9;
        padding: 32px 40px;
        line-height: 1.8;
        min-height: 100vh;
        background-image: linear-gradient(#020917, #101725);
        font-family: ui-sans-serif,system-ui,sans-serif;
      }
      h1, h2 {
        font-weight: 500;
      }
      h1 {
        margin: 0;
        font-size: 36px;
      }
      h2 {
        font-size: 20px;
        margin: 24px 0 16px;
      }
      ul {
        margin: 0;
        padding-left: 16px;
      }
      a {
        color: #58c4dc;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <h1>Assets Report</h1>
  </body>
</html>`);
                try {
                    for(let key in environments){
                        let list = [];
                        res.write(`<h2>Environment: ${key}</h2>`);
                        let environment = environments[key], { assets = [] } = (await environment.getStats()).toJson();
                        for (let asset of (res.write('<ul>'), assets))list.push(`<li><a target="_blank" href="${null == asset ? void 0 : asset.name}">${null == asset ? void 0 : asset.name}</a></li>`);
                        res.write(null == list ? void 0 : list.join('')), res.write('</ul>');
                    }
                    res.end('</body></html>');
                } catch (err) {
                    rslog_index_js_namespaceObject.logger.error(err), res.writeHead(500), res.end('Failed to list the files');
                }
            } else next();
        }, createProxyMiddleware = async (proxyOptions)=>{
        let formattedOptions = function(proxyOptions) {
            let ret = [];
            if (Array.isArray(proxyOptions)) ret.push(...proxyOptions);
            else if ('target' in proxyOptions) ret.push(proxyOptions);
            else for (let [context, options] of Object.entries(proxyOptions)){
                let opts = {
                    context,
                    changeOrigin: !0,
                    logLevel: 'warn'
                };
                'string' == typeof options ? opts.target = options : Object.assign(opts, options), ret.push(opts);
            }
            let handleError = (err)=>rslog_index_js_namespaceObject.logger.error(err);
            for (let opts of ret)opts.onError ??= handleError;
            return ret;
        }(proxyOptions), proxyMiddlewares = [], middlewares = [], { createProxyMiddleware: baseMiddleware } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/http-proxy-middleware/index.js"));
        for (let opts of formattedOptions){
            let proxyMiddleware = baseMiddleware(opts.context, opts), middleware = async (req, res, next)=>{
                let bypassUrl = 'function' == typeof opts.bypass ? opts.bypass(req, res, opts) : null;
                !1 === bypassUrl ? (res.statusCode = 404, next()) : 'string' == typeof bypassUrl ? (req.url = bypassUrl, next()) : !0 === bypassUrl ? next() : proxyMiddleware(req, res, next);
            };
            middlewares.push(middleware), opts.ws && proxyMiddlewares.push(proxyMiddleware);
        }
        return {
            middlewares,
            upgrade: (req, socket, head)=>{
                for (let middleware of proxyMiddlewares)'function' == typeof middleware.upgrade && middleware.upgrade(req, socket, head);
            }
        };
    }, applySetupMiddlewares = (dev, environments, compileMiddlewareAPI)=>{
        let setupMiddlewares = dev.setupMiddlewares || [], serverOptions = {
            sockWrite: (type, data)=>null == compileMiddlewareAPI ? void 0 : compileMiddlewareAPI.sockWrite(type, data),
            environments
        }, before = [], after = [];
        for (let handler of setupMiddlewares)handler({
            unshift: (...handlers)=>before.unshift(...handlers),
            push: (...handlers)=>after.push(...handlers)
        }, serverOptions);
        return {
            before,
            after
        };
    }, applyDefaultMiddlewares = async ({ middlewares, server, compileMiddlewareAPI, output, pwd, outputFileSystem, environments })=>{
        let upgradeEvents = [];
        if (server.compress && middlewares.push(gzipMiddleware()), middlewares.push((req, res, next)=>{
            var _parseUrl;
            res.setHeader('Access-Control-Allow-Origin', '*');
            let path = req.url ? null === (_parseUrl = parseUrl(req.url)) || void 0 === _parseUrl ? void 0 : _parseUrl.pathname : '';
            (null == path ? void 0 : path.includes('hot-update')) && res.setHeader('Access-Control-Allow-Credentials', 'false');
            let confHeaders = server.headers;
            if (confHeaders) for (let [key, value] of Object.entries(confHeaders))res.setHeader(key, value);
            next();
        }), server.cors) {
            let { default: corsMiddleware } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/cors/index.js"));
            middlewares.push(corsMiddleware('boolean' == typeof server.cors ? {} : server.cors));
        }
        if (server.proxy) {
            let { middlewares: proxyMiddlewares, upgrade } = await createProxyMiddleware(server.proxy);
            for (let middleware of (upgradeEvents.push(upgrade), proxyMiddlewares))middlewares.push(middleware);
        }
        server.base && '/' !== server.base && middlewares.push(getBaseMiddleware({
            base: server.base
        }));
        let { default: launchEditorMiddleware } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/launch-editor-middleware/index.js"));
        middlewares.push([
            '/__open-in-editor',
            launchEditorMiddleware()
        ]), middlewares.push(viewingServedFilesMiddleware({
            environments
        })), compileMiddlewareAPI && (middlewares.push(compileMiddlewareAPI.middleware), upgradeEvents.push(compileMiddlewareAPI.onUpgrade.bind(compileMiddlewareAPI)), middlewares.push((req, res, next)=>{
            var _req_url;
            (null === (_req_url = req.url) || void 0 === _req_url ? void 0 : _req_url.endsWith('.hot-update.json')) && 'OPTIONS' !== req.method ? (res.statusCode = 404, res.end()) : next();
        }));
        let distPath = (0, external_node_path_.isAbsolute)(output.distPath) ? output.distPath : (0, external_node_path_.join)(pwd, output.distPath);
        for (let publicDir of (compileMiddlewareAPI && middlewares.push(getHtmlCompletionMiddleware({
            distPath,
            callback: compileMiddlewareAPI.middleware,
            outputFileSystem
        })), normalizePublicDirs(null == server ? void 0 : server.publicDir))){
            let { default: sirv } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/sirv/index.js")), { name } = publicDir, assetMiddleware = sirv((0, external_node_path_.isAbsolute)(name) ? name : (0, external_node_path_.join)(pwd, name), {
                etag: !0,
                dev: !0
            });
            middlewares.push(assetMiddleware);
        }
        if (compileMiddlewareAPI && middlewares.push(getHtmlFallbackMiddleware({
            distPath,
            callback: compileMiddlewareAPI.middleware,
            htmlFallback: server.htmlFallback,
            outputFileSystem
        })), server.historyApiFallback) {
            let { default: connectHistoryApiFallback } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/connect-history-api-fallback/index.js")), historyApiFallbackMiddleware = connectHistoryApiFallback(!0 === server.historyApiFallback ? {} : server.historyApiFallback);
            middlewares.push(historyApiFallbackMiddleware), (null == compileMiddlewareAPI ? void 0 : compileMiddlewareAPI.middleware) && middlewares.push(compileMiddlewareAPI.middleware);
        }
        return middlewares.push(faviconFallbackMiddleware), middlewares.push((req, res, next)=>{
            if ('OPTIONS' === req.method) {
                res.statusCode = 204, res.setHeader('Content-Length', '0'), res.end();
                return;
            }
            next();
        }), {
            onUpgrade: (...args)=>{
                for (let cb of upgradeEvents)cb(...args);
            }
        };
    }, getMiddlewares = async (options)=>{
        let middlewares = [], { environments, compileMiddlewareAPI } = options;
        'verbose' === rslog_index_js_namespaceObject.logger.level && middlewares.push(await getRequestLoggerMiddleware());
        let { before, after } = applySetupMiddlewares(options.dev, environments, compileMiddlewareAPI);
        middlewares.push(...before);
        let { onUpgrade } = await applyDefaultMiddlewares({
            ...options,
            middlewares
        });
        return middlewares.push(...after), {
            close: async ()=>{
                await (null == compileMiddlewareAPI ? void 0 : compileMiddlewareAPI.close());
            },
            onUpgrade,
            middlewares
        };
    }, createHttpServer = async ({ serverConfig, middlewares })=>{
        if (serverConfig.https) {
            if (serverConfig.proxy) {
                let { createServer } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "node:https"));
                return createServer(serverConfig.https, middlewares);
            }
            let { createSecureServer } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "node:http2"));
            return createSecureServer({
                allowHTTP1: !0,
                maxSessionMemory: 1024,
                ...serverConfig.https
            }, middlewares);
        }
        let { createServer } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "node:http"));
        return createServer(middlewares);
    }, devServer_formatDevConfig = (config, port)=>('<port>' === config.client.port && (config.client.port = String(port)), config);
    async function devServer_createDevServer(options, createCompiler, config, { compiler: customCompiler, getPortSilently, runCompile = !0 } = {}) {
        let lastStats;
        rslog_index_js_namespaceObject.logger.debug('create dev server');
        let { port, host, https, portTip } = await getServerConfig({
            config
        }), devConfig = devServer_formatDevConfig(config.dev, port), routes = getRoutes(options.context);
        options.context.devServer = {
            hostname: host,
            port,
            https
        };
        let outputFileSystem = external_node_fs_default(), waitFirstCompileDone = runCompile ? new Promise((resolve)=>{
            options.context.hooks.onDevCompileDone.tap(({ stats, isFirstCompile })=>{
                if (lastStats = 'stats' in stats ? stats.stats : [
                    stats
                ], !!isFirstCompile) resolve();
            });
        }) : Promise.resolve(), startCompile = async ()=>{
            let compiler = customCompiler || await createCompiler();
            if (!compiler) throw Error('[rsbuild:server] Failed to get compiler instance.');
            let publicPaths = isMultiCompiler(compiler) ? compiler.compilers.map(getPublicPathFromCompiler) : [
                getPublicPathFromCompiler(compiler)
            ], compilerDevMiddleware = new CompilerDevMiddleware({
                dev: devConfig,
                server: config.server,
                publicPaths: publicPaths,
                compiler,
                environments: options.context.environments
            });
            return await compilerDevMiddleware.init(), outputFileSystem = (isMultiCompiler(compiler) ? compiler.compilers[0].outputFileSystem : compiler.outputFileSystem) || external_node_fs_default(), {
                middleware: compilerDevMiddleware.middleware,
                sockWrite: (...args)=>compilerDevMiddleware.sockWrite(...args),
                onUpgrade: (...args)=>compilerDevMiddleware.upgrade(...args),
                close: ()=>null == compilerDevMiddleware ? void 0 : compilerDevMiddleware.close()
            };
        }, protocol = https ? 'https' : 'http', urls = getAddressUrls({
            protocol,
            port,
            host
        });
        await options.context.hooks.onBeforeStartDevServer.call({
            environments: options.context.environments
        });
        let cliShortcutsEnabled = isCliShortcutsEnabled(devConfig), printUrls = ()=>printServerURLs({
                urls,
                port,
                routes,
                protocol,
                printUrls: config.server.printUrls,
                trailingLineBreak: !cliShortcutsEnabled
            }), openPage = async ()=>open_open({
                https,
                port,
                routes,
                config,
                clearCache: !0
            }), closeServer = async ()=>{
            await options.context.hooks.onCloseDevServer.call(), await Promise.all([
                devMiddlewares.close(),
                null == fileWatcher ? void 0 : fileWatcher.close()
            ]);
        }, beforeCreateCompiler = ()=>{
            if (printUrls(), cliShortcutsEnabled) {
                let shortcutsOptions = 'boolean' == typeof devConfig.cliShortcuts ? {} : devConfig.cliShortcuts, cleanup = setupCliShortcuts({
                    openPage,
                    closeServer,
                    printUrls,
                    restartServer: ()=>restartDevServer({
                            clear: !1
                        }),
                    help: shortcutsOptions.help,
                    customShortcuts: shortcutsOptions.custom
                });
                options.context.hooks.onCloseDevServer.tap(cleanup);
            }
            !getPortSilently && portTip && rslog_index_js_namespaceObject.logger.info(portTip);
        };
        runCompile ? options.context.hooks.onBeforeCreateCompiler.tap(beforeCreateCompiler) : beforeCreateCompiler();
        let compileMiddlewareAPI = runCompile ? await startCompile() : void 0, root = options.context.rootPath, fileWatcher = await setupWatchFiles({
            dev: devConfig,
            server: config.server,
            compileMiddlewareAPI,
            root
        }), readFileSync = (fileName)=>'readFileSync' in outputFileSystem ? outputFileSystem.readFileSync(fileName, 'utf-8') : external_node_fs_default().readFileSync(fileName, 'utf-8'), cacheableLoadBundle = createCacheableFunction(loadBundle), cacheableTransformedHtml = createCacheableFunction((_stats, entryName, utils)=>getTransformedHtml(entryName, utils)), environmentAPI = Object.fromEntries(Object.entries(options.context.environments).map(([name, environment])=>[
                name,
                {
                    getStats: async ()=>{
                        if (!runCompile) throw Error('[rsbuild:server] Can not get stats info when "runCompile" is false');
                        return await waitFirstCompileDone, lastStats[environment.index];
                    },
                    loadBundle: async (entryName)=>(await waitFirstCompileDone, cacheableLoadBundle(lastStats[environment.index], entryName, {
                            readFileSync,
                            environment
                        })),
                    getTransformedHtml: async (entryName)=>(await waitFirstCompileDone, cacheableTransformedHtml(lastStats[environment.index], entryName, {
                            readFileSync,
                            environment
                        }))
                }
            ])), devMiddlewares = await getMiddlewares({
            pwd: root,
            compileMiddlewareAPI,
            dev: devConfig,
            server: config.server,
            environments: environmentAPI,
            output: {
                distPath: options.context.distPath || ROOT_DIST_DIR
            },
            outputFileSystem
        }), { default: connect } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/connect/index.js")), middlewares = connect();
        for (let item of devMiddlewares.middlewares)Array.isArray(item) ? middlewares.use(...item) : middlewares.use(item);
        let devServerAPI = {
            port,
            middlewares,
            environments: environmentAPI,
            listen: async ()=>{
                let httpServer = await createHttpServer({
                    serverConfig: config.server,
                    middlewares
                }), serverTerminator = getServerTerminator(httpServer);
                return rslog_index_js_namespaceObject.logger.debug('listen dev server'), options.context.hooks.onCloseDevServer.tap(serverTerminator), new Promise((resolve)=>{
                    httpServer.listen({
                        host,
                        port
                    }, async (err)=>{
                        if (err) throw err;
                        middlewares.use(notFoundMiddleware), httpServer.on('upgrade', devMiddlewares.onUpgrade), rslog_index_js_namespaceObject.logger.debug('listen dev server done'), await devServerAPI.afterListen(), onBeforeRestartServer(devServerAPI.close), resolve({
                            port,
                            urls: urls.map((item)=>item.url),
                            server: {
                                close: devServerAPI.close
                            }
                        });
                    });
                });
            },
            afterListen: async ()=>{
                await options.context.hooks.onAfterStartDevServer.call({
                    port,
                    routes,
                    environments: options.context.environments
                });
            },
            connectWebSocket: ({ server })=>{
                server.on('upgrade', devMiddlewares.onUpgrade);
            },
            close: closeServer,
            printUrls,
            open: openPage
        };
        return rslog_index_js_namespaceObject.logger.debug('create dev server done'), devServerAPI;
    }
    async function createCompiler_createCompiler(options) {
        rslog_index_js_namespaceObject.logger.debug('create compiler');
        let { context } = options, { rspackConfigs } = await initConfigs(options);
        if (await context.hooks.onBeforeCreateCompiler.call({
            bundlerConfigs: rspackConfigs,
            environments: context.environments
        }), !await isSatisfyRspackVersion(core_namespaceObject.rspack.rspackVersion)) throw Error(`[rsbuild] The current Rspack version does not meet the requirements, the minimum supported version of Rspack is ${index_js_default().green(rspackMinVersion)}`);
        let compiler = 1 === rspackConfigs.length ? (0, core_namespaceObject.rspack)(rspackConfigs[0]) : (0, core_namespaceObject.rspack)(rspackConfigs), isVersionLogged = !1, isCompiling = !1, logRspackVersion = ()=>{
            !isVersionLogged && (rslog_index_js_namespaceObject.logger.debug(`Use Rspack v${core_namespaceObject.rspack.rspackVersion}`), isVersionLogged = !0);
        };
        compiler.hooks.watchRun.tap('rsbuild:compiling', ()=>{
            logRspackVersion(), !isCompiling && rslog_index_js_namespaceObject.logger.start('Building...'), isCompiling = !0;
        }), 'build' === context.command && compiler.hooks.run.tap('rsbuild:run', logRspackVersion);
        let done = (stats)=>{
            let statsOptions = getStatsOptions(compiler), statsJson = stats.toJson({
                children: !0,
                moduleTrace: !0,
                timings: !0,
                preset: 'errors-warnings',
                ...statsOptions
            }), printTime = (c, index)=>{
                if (c.time) {
                    let time = prettyTime(c.time / 1000), { name } = rspackConfigs[index], suffix = name ? index_js_default().gray(` (${name})`) : '';
                    rslog_index_js_namespaceObject.logger.ready(`Built in ${time}${suffix}`);
                }
            }, hasErrors = stats.hasErrors();
            if (!hasErrors) {
                var _statsJson_children;
                rspackConfigs.length > 1 && (null === (_statsJson_children = statsJson.children) || void 0 === _statsJson_children ? void 0 : _statsJson_children.length) ? statsJson.children.forEach((c, index)=>{
                    printTime(c, index);
                }) : printTime(statsJson, 0);
            }
            let { message, level } = formatStats(statsJson, hasErrors);
            'error' === level && rslog_index_js_namespaceObject.logger.error(message), 'warning' === level && rslog_index_js_namespaceObject.logger.warn(message), isCompiling = !1;
        };
        return compiler.hooks.done.tap('rsbuild:done', (stats)=>{
            done(stats);
        }), 'dev' === context.command && registerDevHook({
            context,
            compiler,
            bundlerConfigs: rspackConfigs,
            MultiStatsCtor: core_namespaceObject.rspack.MultiStats
        }), await context.hooks.onAfterCreateCompiler.call({
            compiler,
            environments: context.environments
        }), rslog_index_js_namespaceObject.logger.debug('create compiler done'), {
            compiler,
            rspackConfigs
        };
    }
    let build_build = async (initOptions, { watch, compiler: customCompiler } = {})=>{
        let compiler, bundlerConfigs;
        let { context } = initOptions;
        if (customCompiler) compiler = customCompiler;
        else {
            let result = await createCompiler_createCompiler(initOptions);
            compiler = result.compiler, bundlerConfigs = result.rspackConfigs;
        }
        if (registerBuildHook({
            context,
            bundlerConfigs,
            compiler,
            isWatch: !!watch,
            MultiStatsCtor: core_namespaceObject.rspack.MultiStats
        }), watch) return compiler.watch({}, (err)=>{
            err && rslog_index_js_namespaceObject.logger.error(err);
        }), {
            close: ()=>new Promise((resolve)=>{
                    compiler.close(()=>{
                        resolve();
                    });
                })
        };
        let { stats } = await new Promise((resolve, reject)=>{
            compiler.run((err, stats)=>{
                err ? reject(err) : (null == stats ? void 0 : stats.hasErrors()) ? reject(Error('Rspack build failed!')) : compiler.close((closeErr)=>{
                    closeErr && rslog_index_js_namespaceObject.logger.error(closeErr), resolve({
                        stats
                    });
                });
            });
        });
        return {
            stats,
            close: async ()=>{}
        };
    }, rspackProvider = async ({ context, pluginManager, rsbuildOptions })=>{
        let createCompiler = async ()=>(await createCompiler_createCompiler({
                context,
                pluginManager,
                rsbuildOptions
            })).compiler;
        return {
            bundler: 'rspack',
            createCompiler,
            async createDevServer (options) {
                let config = await initRsbuildConfig({
                    context,
                    pluginManager
                });
                return devServer_createDevServer({
                    context,
                    pluginManager,
                    rsbuildOptions
                }, createCompiler, config, options);
            },
            async startDevServer (options) {
                let config = await initRsbuildConfig({
                    context,
                    pluginManager
                });
                return (await devServer_createDevServer({
                    context,
                    pluginManager,
                    rsbuildOptions
                }, createCompiler, config, options)).listen();
            },
            build: async (options)=>build_build({
                    context,
                    pluginManager,
                    rsbuildOptions
                }, options),
            async initConfigs () {
                let { rspackConfigs } = await initConfigs({
                    context,
                    pluginManager,
                    rsbuildOptions
                });
                return rspackConfigs;
            },
            inspectConfig: async (inspectOptions)=>inspectConfig({
                    context,
                    pluginManager,
                    rsbuildOptions,
                    inspectOptions
                })
        };
    };
    function prodServer_define_property(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    class RsbuildProdServer {
        async onInit(app) {
            this.app = app, await this.applyDefaultMiddlewares();
        }
        async applyDefaultMiddlewares() {
            let { headers, proxy, historyApiFallback, compress, base, cors } = this.options.serverConfig;
            if ('verbose' === rslog_index_js_namespaceObject.logger.level && this.middlewares.use(await getRequestLoggerMiddleware()), compress && this.middlewares.use(gzipMiddleware({
                level: 6
            })), headers && this.middlewares.use((_req, res, next)=>{
                for (let [key, value] of Object.entries(headers))res.setHeader(key, value);
                next();
            }), cors) {
                let { default: corsMiddleware } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/cors/index.js"));
                this.middlewares.use(corsMiddleware('boolean' == typeof cors ? {} : cors));
            }
            if (proxy) {
                let { middlewares, upgrade } = await createProxyMiddleware(proxy);
                for (let middleware of middlewares)this.middlewares.use(middleware);
                this.app.on('upgrade', upgrade);
            }
            if (base && '/' !== base && this.middlewares.use(getBaseMiddleware({
                base
            })), await this.applyStaticAssetMiddleware(), historyApiFallback) {
                let { default: connectHistoryApiFallback } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/connect-history-api-fallback/index.js")), historyApiFallbackMiddleware = connectHistoryApiFallback(!0 === historyApiFallback ? {} : historyApiFallback);
                this.middlewares.use(historyApiFallbackMiddleware), await this.applyStaticAssetMiddleware();
            }
            this.middlewares.use(faviconFallbackMiddleware);
        }
        async applyStaticAssetMiddleware() {
            let { output: { path, assetPrefixes }, serverConfig: { htmlFallback } } = this.options, { default: sirv } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/sirv/index.js")), assetMiddleware = sirv(path, {
                etag: !0,
                dev: !0,
                ignores: [
                    'favicon.ico'
                ],
                single: 'index' === htmlFallback
            });
            this.middlewares.use((req, res, next)=>{
                let url = req.url, assetPrefix = url && assetPrefixes.find((prefix)=>url.startsWith(prefix));
                assetPrefix && (null == url ? void 0 : url.startsWith(assetPrefix)) ? (req.url = url.slice(assetPrefix.length), assetMiddleware(req, res, (...args)=>{
                    req.url = url, next(...args);
                })) : assetMiddleware(req, res, next);
            });
        }
        async close() {}
        constructor(options, middlewares){
            prodServer_define_property(this, "app", void 0), prodServer_define_property(this, "options", void 0), prodServer_define_property(this, "middlewares", void 0), this.options = options, this.middlewares = middlewares;
        }
    }
    async function startProdServer(context, config, { getPortSilently } = {}) {
        let { port, host, https, portTip } = await getServerConfig({
            config
        }), { default: connect } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/connect/index.js")), middlewares = connect(), serverConfig = config.server, server = new RsbuildProdServer({
            pwd: context.rootPath,
            output: {
                path: context.distPath,
                assetPrefixes: Object.values(context.environments).map((e)=>pathnameParse(e.config.output.assetPrefix))
            },
            serverConfig
        }, middlewares);
        await context.hooks.onBeforeStartProdServer.call();
        let httpServer = await createHttpServer({
            serverConfig,
            middlewares: server.middlewares
        }), serverTerminator = getServerTerminator(httpServer);
        return await server.onInit(httpServer), new Promise((resolve)=>{
            httpServer.listen({
                host,
                port
            }, async ()=>{
                let routes = getRoutes(context);
                await context.hooks.onAfterStartProdServer.call({
                    port,
                    routes,
                    environments: context.environments
                });
                let protocol = https ? 'https' : 'http', urls = getAddressUrls({
                    protocol,
                    port,
                    host
                }), cliShortcutsEnabled = isCliShortcutsEnabled(config.dev), closeServer = async ()=>{
                    await Promise.all([
                        server.close(),
                        serverTerminator()
                    ]);
                }, printUrls = ()=>printServerURLs({
                        urls,
                        port,
                        routes,
                        protocol,
                        printUrls: serverConfig.printUrls,
                        trailingLineBreak: !cliShortcutsEnabled
                    }), openPage = async ()=>open_open({
                        https,
                        port,
                        routes,
                        config,
                        clearCache: !0
                    });
                if (printUrls(), cliShortcutsEnabled) {
                    let shortcutsOptions = 'boolean' == typeof config.dev.cliShortcuts ? {} : config.dev.cliShortcuts;
                    setupCliShortcuts({
                        openPage,
                        closeServer,
                        printUrls,
                        help: shortcutsOptions.help,
                        customShortcuts: shortcutsOptions.custom
                    });
                }
                !getPortSilently && portTip && rslog_index_js_namespaceObject.logger.info(portTip), resolve({
                    port,
                    urls: urls.map((item)=>item.url),
                    server: {
                        close: closeServer
                    }
                });
            });
        });
    }
    async function applyDefaultPlugins(pluginManager, context) {
        pluginManager.addPlugins([
            pluginBasic(),
            pluginEntry(),
            pluginCache(),
            pluginTarget(),
            pluginOutput(),
            pluginResolve(),
            pluginFileSize(),
            pluginCleanOutput(),
            pluginAsset(),
            pluginHtml((environment)=>async (...args)=>(await context.hooks.modifyHTMLTags.callInEnvironment({
                        environment,
                        args
                    }))[0]),
            pluginAppIcon(),
            pluginWasm(),
            pluginMoment(),
            pluginNodeAddons(),
            pluginDefine(),
            pluginCss(),
            pluginMinimize(),
            pluginProgress(),
            pluginSwc(),
            {
                name: 'rsbuild:externals',
                setup (api) {
                    api.modifyBundlerChain((chain, { environment })=>{
                        let { externals } = environment.config.output;
                        externals && chain.externals(externals);
                    }), api.onBeforeCreateCompiler(({ bundlerConfigs })=>{
                        for (let config of bundlerConfigs)(Array.isArray(config.target) ? config.target.includes('webworker') : 'webworker' === config.target) && config.externals && delete config.externals;
                    });
                }
            },
            pluginSplitChunks(),
            pluginInlineChunk(),
            pluginRsdoctor(),
            pluginResourceHints(),
            pluginPerformance(),
            {
                name: 'rsbuild:bundle-analyzer',
                setup (api) {
                    api.modifyRsbuildConfig({
                        order: 'post',
                        handler: (config)=>{
                            if (!!(isUseAnalyzer(config) || Object.values(config.environments || []).some((config)=>isUseAnalyzer(config)))) return config.dev ||= {}, config.dev.writeToDisk = !0, config;
                        }
                    }), api.modifyBundlerChain(async (chain, { CHAIN_ID, environment })=>{
                        let { config } = environment;
                        if (!isUseAnalyzer(config)) return;
                        let { default: BundleAnalyzer } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "../../compiled/webpack-bundle-analyzer/index.js"));
                        chain.plugin(CHAIN_ID.PLUGIN.BUNDLE_ANALYZER).use(BundleAnalyzer.BundleAnalyzerPlugin, [
                            {
                                analyzerMode: 'static',
                                openAnalyzer: !1,
                                reportFilename: `report-${environment.name}.html`,
                                ...config.performance.bundleAnalyze || {}
                            }
                        ]);
                    });
                }
            },
            pluginServer(),
            pluginManifest(),
            {
                name: 'rsbuild:module-federation',
                setup (api) {
                    if ('webpack' !== api.context.bundlerType) api.modifyRsbuildConfig((config)=>{
                        let { moduleFederation } = config;
                        if (!!(null == moduleFederation ? void 0 : moduleFederation.options)) {
                            if (moduleFederation.options.exposes) {
                                var _config_server, _config_dev_client, _originalConfig_dev, _config_server1;
                                config.dev ||= {}, (null === (_config_server = config.server) || void 0 === _config_server ? void 0 : _config_server.port) && !(null === (_config_dev_client = config.dev.client) || void 0 === _config_dev_client ? void 0 : _config_dev_client.port) && (config.dev.client ||= {}, config.dev.client.port = config.server.port), (null === (_originalConfig_dev = api.getRsbuildConfig('original').dev) || void 0 === _originalConfig_dev ? void 0 : _originalConfig_dev.assetPrefix) === void 0 && config.dev.assetPrefix === (null === (_config_server1 = config.server) || void 0 === _config_server1 ? void 0 : _config_server1.base) && (config.dev.assetPrefix = !0);
                            }
                        }
                    }), api.modifyEnvironmentConfig((config)=>{
                        var _config_moduleFederation, _config_performance_chunkSplit, _config_performance;
                        if (!!(null === (_config_moduleFederation = config.moduleFederation) || void 0 === _config_moduleFederation ? void 0 : _config_moduleFederation.options)) (null === (_config_performance = config.performance) || void 0 === _config_performance ? void 0 : null === (_config_performance_chunkSplit = _config_performance.chunkSplit) || void 0 === _config_performance_chunkSplit ? void 0 : _config_performance_chunkSplit.strategy) === 'split-by-experience' && (config.performance.chunkSplit = {
                            ...config.performance.chunkSplit,
                            strategy: 'custom'
                        }), config.source.include = [
                            ...config.source.include || [],
                            /@module-federation[\\/]sdk/,
                            /@module-federation[\\/]runtime/
                        ];
                    }), api.modifyBundlerChain(async (chain, { CHAIN_ID, target, environment })=>{
                        var _config_moduleFederation;
                        let { config } = environment;
                        if (!(null === (_config_moduleFederation = config.moduleFederation) || void 0 === _config_moduleFederation ? void 0 : _config_moduleFederation.options) || 'web' !== target) return;
                        let { options } = config.moduleFederation;
                        chain.plugin(CHAIN_ID.PLUGIN.MODULE_FEDERATION).use(core_namespaceObject.rspack.container.ModuleFederationPlugin, [
                            options
                        ]), options.name && (options.exposes && chain.plugin('mf-patch-split-chunks').use(PatchSplitChunksPlugin, [
                            options.name
                        ]), !chain.output.get('uniqueName') && chain.output.set('uniqueName', options.name));
                    });
                }
            },
            pluginRspackProfile(),
            pluginLazyCompilation(),
            pluginSri(),
            pluginNonce()
        ]);
    }
    async function createRsbuild(options = {}) {
        let plugins, { rsbuildConfig = {} } = options, rsbuildOptions = {
            cwd: process.cwd(),
            rsbuildConfig,
            ...options
        };
        let pluginManager = (plugins = [], {
            getPlugins: (options = {
                environment: RSBUILD_ALL_ENVIRONMENT_SYMBOL
            })=>plugins.filter((p)=>isPluginMatchEnvironment(p.environment, options.environment)).map((p)=>p.instance),
            getAllPluginsWithMeta: ()=>plugins,
            addPlugins: (newPlugins, options)=>{
                let { before, environment = RSBUILD_ALL_ENVIRONMENT_SYMBOL } = options || {};
                for (let newPlugin of newPlugins){
                    if (!!newPlugin) if (!function(plugin) {
                        let type = typeof plugin;
                        if ('object' !== type || null === plugin) throw Error(`[rsbuild:plugin] Expect Rsbuild plugin instance to be an object, but got ${type}.`);
                        if (!isFunction(plugin.setup)) {
                            if (isFunction(plugin.apply)) {
                                let { name = 'SomeWebpackPlugin' } = plugin.constructor || {};
                                throw Error([
                                    `${index_js_default().yellow(name)} looks like a Webpack or Rspack plugin, please use ${index_js_default().yellow('`tools.rspack`')} to register it:`,
                                    index_js_default().green(`
  // rsbuild.config.ts
  export default {
    tools: {
      rspack: {
        plugins: [new ${name}()]
      }
    }
  };
`)
                                ].join('\n'));
                            }
                            throw Error(`[rsbuild:plugin] Expect the setup function of Rsbuild plugin to be a function, but got ${type}.`);
                        }
                    }(newPlugin), before) {
                        let index = plugins.findIndex((item)=>item.instance.name === before);
                        -1 === index ? (rslog_index_js_namespaceObject.logger.warn(`Plugin "${before}" does not exist.`), plugins.push({
                            environment,
                            instance: newPlugin
                        })) : plugins.splice(index, 0, {
                            environment,
                            instance: newPlugin
                        });
                    } else plugins.push({
                        environment,
                        instance: newPlugin
                    });
                }
            },
            removePlugins: (pluginNames, options = {})=>{
                plugins = plugins.filter((plugin)=>!(pluginNames.includes(plugin.instance.name) && (!options.environment || plugin.environment === options.environment)));
            },
            isPluginExists: (pluginName, options = {
                environment: RSBUILD_ALL_ENVIRONMENT_SYMBOL
            })=>!!plugins.find((plugin)=>plugin.instance.name === pluginName && isPluginMatchEnvironment(plugin.environment, options.environment))
        }), context = await createContext(rsbuildOptions, rsbuildOptions.rsbuildConfig, rsbuildConfig.provider ? 'webpack' : 'rspack'), getPluginAPI = function({ context, pluginManager }) {
            let { hooks } = context, publicContext = function(context) {
                let exposedKeys = [
                    'version',
                    'rootPath',
                    'distPath',
                    'devServer',
                    'cachePath',
                    'bundlerType'
                ];
                return new Proxy(context, {
                    get (target, prop) {
                        if (exposedKeys.includes(prop)) return target[prop];
                    },
                    set: (_, prop)=>(rslog_index_js_namespaceObject.logger.error(`Context is readonly, you can not assign to the "context.${prop}" prop.`), !0)
                });
            }(context);
            function getNormalizedConfig(options) {
                if (context.normalizedConfig) {
                    if (null == options ? void 0 : options.environment) {
                        let config = context.normalizedConfig.environments[options.environment];
                        if (!config) throw Error(`[rsbuild] Cannot find normalized config by environment: ${options.environment}.`);
                        return config;
                    }
                    return context.normalizedConfig;
                }
                throw Error('[rsbuild] Cannot access normalized config until modifyRsbuildConfig is called.');
            }
            let getRsbuildConfig = (type = 'current')=>{
                switch(type){
                    case 'original':
                        return context.originalConfig;
                    case 'current':
                        return context.config;
                    case 'normalized':
                        return getNormalizedConfig();
                }
                throw Error('[rsbuild] `getRsbuildConfig` get an invalid type param.');
            }, exposed = [], expose = (id, api)=>{
                exposed.push({
                    id,
                    api
                });
            }, useExposed = (id)=>{
                let matched = exposed.find((item)=>item.id === id);
                if (matched) return matched.api;
            }, transformId = 0, transformer = {}, processAssetsFns = [], resolveFns = [];
            hooks.modifyBundlerChain.tap((chain, { target, environment })=>{
                let pluginName = 'RsbuildCorePlugin';
                chain.plugin(pluginName).use(class RsbuildCorePlugin {
                    apply(compiler) {
                        for (let { handler, environment: pluginEnvironment } of (compiler.__rsbuildTransformer = transformer, resolveFns)){
                            if (pluginEnvironment && !isPluginMatchEnvironment(pluginEnvironment, environment.name)) return;
                            compiler.hooks.compilation.tap(pluginName, (compilation, { normalModuleFactory })=>{
                                normalModuleFactory.hooks.resolve.tapPromise(pluginName, async (resolveData)=>handler({
                                        compiler,
                                        compilation,
                                        environment,
                                        resolveData
                                    }));
                            });
                        }
                        compiler.hooks.thisCompilation.tap(pluginName, (compilation)=>{
                            compilation.hooks.childCompiler.tap(pluginName, (childCompiler)=>{
                                childCompiler.__rsbuildTransformer = transformer;
                            });
                            let { sources } = compiler.webpack;
                            for (let { descriptor, handler, environment: pluginEnvironment } of processAssetsFns){
                                if (descriptor.targets && !descriptor.targets.includes(target) || descriptor.environments && !descriptor.environments.includes(environment.name) || pluginEnvironment && !isPluginMatchEnvironment(pluginEnvironment, environment.name)) return;
                                compilation.hooks.processAssets.tapPromise({
                                    name: pluginName,
                                    stage: mapProcessAssetsStage(compiler, descriptor.stage)
                                }, async (assets)=>handler({
                                        assets,
                                        compiler,
                                        compilation,
                                        environment,
                                        sources
                                    }));
                            }
                        });
                    }
                });
            });
            let getTransformFn = (environment)=>(descriptor, handler)=>{
                    let id = `rsbuild-transform-${transformId++}`;
                    transformer[id] = handler, hooks.modifyBundlerChain.tapEnvironment({
                        environment,
                        handler: (chain, { target, environment })=>{
                            if (descriptor.targets && !descriptor.targets.includes(target) || descriptor.environments && !descriptor.environments.includes(environment.name)) return;
                            let rule = chain.module.rule(id);
                            descriptor.test && rule.test(descriptor.test), descriptor.resourceQuery && rule.resourceQuery(descriptor.resourceQuery), descriptor.layer && rule.layer(descriptor.layer), descriptor.issuerLayer && rule.issuerLayer(descriptor.issuerLayer);
                            let loaderName = descriptor.raw ? 'transformRawLoader.mjs' : 'transformLoader.mjs', loaderPath = (0, external_node_path_.join)(LOADER_PATH, loaderName);
                            rule.use(id).loader(loaderPath).options({
                                id,
                                getEnvironment: ()=>environment
                            });
                        }
                    });
                }, setProcessAssets = (environment)=>(descriptor, handler)=>{
                    processAssetsFns.push({
                        environment,
                        descriptor,
                        handler
                    });
                }, setResolve = (environment)=>(handler)=>{
                    resolveFns.push({
                        environment,
                        handler
                    });
                }, onExitListened = !1, onExit = (cb)=>{
                !onExitListened && (process.on('exit', ()=>{
                    hooks.onExit.call();
                }), onExitListened = !0), hooks.onExit.tap(cb);
            };
            return (environment)=>({
                    context: publicContext,
                    expose,
                    transform: getTransformFn(environment),
                    useExposed,
                    processAssets: setProcessAssets(environment),
                    resolve: setResolve(environment),
                    getRsbuildConfig,
                    getNormalizedConfig,
                    isPluginExists: pluginManager.isPluginExists,
                    onExit,
                    onAfterBuild: hooks.onAfterBuild.tap,
                    onCloseBuild: hooks.onCloseBuild.tap,
                    onBeforeBuild: hooks.onBeforeBuild.tap,
                    onCloseDevServer: hooks.onCloseDevServer.tap,
                    onDevCompileDone: hooks.onDevCompileDone.tap,
                    onAfterCreateCompiler: hooks.onAfterCreateCompiler.tap,
                    onAfterStartDevServer: hooks.onAfterStartDevServer.tap,
                    onBeforeCreateCompiler: hooks.onBeforeCreateCompiler.tap,
                    onBeforeStartDevServer: hooks.onBeforeStartDevServer.tap,
                    onAfterStartProdServer: hooks.onAfterStartProdServer.tap,
                    onBeforeStartProdServer: hooks.onBeforeStartProdServer.tap,
                    modifyRsbuildConfig: hooks.modifyRsbuildConfig.tap,
                    modifyHTMLTags: (handler)=>hooks.modifyHTMLTags.tapEnvironment({
                            environment,
                            handler
                        }),
                    modifyBundlerChain: (handler)=>hooks.modifyBundlerChain.tapEnvironment({
                            environment,
                            handler
                        }),
                    modifyRspackConfig: (handler)=>hooks.modifyRspackConfig.tapEnvironment({
                            environment,
                            handler
                        }),
                    modifyWebpackChain: (handler)=>hooks.modifyWebpackChain.tapEnvironment({
                            environment,
                            handler
                        }),
                    modifyWebpackConfig: (handler)=>hooks.modifyWebpackConfig.tapEnvironment({
                            environment,
                            handler
                        }),
                    modifyEnvironmentConfig: (handler)=>hooks.modifyEnvironmentConfig.tapEnvironment({
                            environment,
                            handler
                        }),
                    onAfterEnvironmentCompile: (handler)=>hooks.onAfterEnvironmentCompile.tapEnvironment({
                            environment,
                            handler
                        }),
                    onBeforeEnvironmentCompile: (handler)=>hooks.onBeforeEnvironmentCompile.tapEnvironment({
                            environment,
                            handler
                        })
                });
        }({
            context,
            pluginManager
        });
        context.getPluginAPI = getPluginAPI;
        let globalPluginAPI = getPluginAPI();
        rslog_index_js_namespaceObject.logger.debug('add default plugins'), await applyDefaultPlugins(pluginManager, context), rslog_index_js_namespaceObject.logger.debug('add default plugins done');
        let provider = rsbuildConfig.provider || rspackProvider, providerInstance = await provider({
            context,
            pluginManager,
            rsbuildOptions,
            helpers: provider_helpers_namespaceObject
        }), preview = async (options = {})=>{
            context.command = 'preview', !getNodeEnv() && setNodeEnv('production');
            let config = await initRsbuildConfig({
                context,
                pluginManager
            }), { distPath } = context, { checkDistDir = !0 } = options;
            if (checkDistDir) {
                if (!(0, external_node_fs_.existsSync)(distPath)) throw Error(`[rsbuild:preview] The output directory ${index_js_default().yellow(distPath)} does not exist, please build the project before previewing.`);
                if (function(path) {
                    let files = external_node_fs_default().readdirSync(path);
                    return 0 === files.length || 1 === files.length && '.git' === files[0];
                }(distPath)) throw Error(`[rsbuild:preview] The output directory ${index_js_default().yellow(distPath)} is empty, please build the project before previewing.`);
            }
            return startProdServer(context, config, options);
        }, build = async (...args)=>{
            context.command = 'build', !getNodeEnv() && setNodeEnv('production');
            let buildInstance = await providerInstance.build(...args);
            return {
                ...buildInstance,
                close: async ()=>{
                    await context.hooks.onCloseBuild.call(), await buildInstance.close();
                }
            };
        }, rsbuild = {
            build,
            preview,
            startDevServer: (...args)=>(context.command = 'dev', !getNodeEnv() && setNodeEnv('development'), providerInstance.startDevServer(...args)),
            createCompiler: (...args)=>(!context.command && (context.command = 'development' === getNodeEnv() ? 'dev' : 'build'), providerInstance.createCompiler(...args)),
            createDevServer: (...args)=>(context.command = 'dev', !getNodeEnv() && setNodeEnv('development'), providerInstance.createDevServer(...args)),
            ...pick(pluginManager, [
                'addPlugins',
                'getPlugins',
                'removePlugins',
                'isPluginExists'
            ]),
            ...pick(globalPluginAPI, [
                'context',
                'onCloseBuild',
                'onBeforeBuild',
                'onBeforeCreateCompiler',
                'onBeforeStartDevServer',
                'onBeforeStartProdServer',
                'onAfterBuild',
                'onAfterCreateCompiler',
                'onAfterStartDevServer',
                'onAfterStartProdServer',
                'onCloseDevServer',
                'onDevCompileDone',
                'onExit',
                'getRsbuildConfig',
                'getNormalizedConfig'
            ]),
            ...pick(providerInstance, [
                'initConfigs',
                'inspectConfig'
            ])
        }, getFlattenedPlugins = async (pluginOptions)=>{
            let plugins = pluginOptions;
            do plugins = (await Promise.all(plugins)).flat(Number.POSITIVE_INFINITY);
            while (plugins.some((v)=>(0, types_namespaceObject.isPromise)(v)));
            return plugins;
        };
        if (rsbuildConfig.plugins) {
            let plugins = await getFlattenedPlugins(rsbuildConfig.plugins);
            rsbuild.addPlugins(plugins);
        }
        return rsbuildConfig.environments && await Promise.all(Object.entries(rsbuildConfig.environments).map(async ([name, config])=>{
            let isEnvironmentEnabled = !rsbuildOptions.environment || rsbuildOptions.environment.includes(name);
            if (config.plugins && isEnvironmentEnabled) {
                let plugins = await getFlattenedPlugins(config.plugins);
                rsbuild.addPlugins(plugins, {
                    environment: name
                });
            }
        })), rsbuild;
    }
    let { program, createCommand, createArgument, createOption, CommanderError, InvalidArgumentError, InvalidOptionArgumentError, Command, Argument, Option, Help } = __webpack_require__("../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/index.js"), applyCommonOptions = (command)=>{
        command.option('-c --config <config>', 'specify the configuration file, can be a relative or absolute path').option('-r --root <root>', 'specify the project root directory, can be an absolute path or a path relative to cwd').option('-m --mode <mode>', 'specify the build mode, can be `development`, `production` or `none`').option('--env-mode <mode>', 'specify the env mode to load the `.env.[mode]` file').option('--environment <name>', 'specify the name of environment to build', (str, prev)=>prev ? prev.concat(str.split(',')) : str.split(',')).option('--env-dir <dir>', 'specify the directory to load `.env` files');
    }, applyServerOptions = (command)=>{
        command.option('-o --open [url]', 'open the page in browser on startup').option('--port <port>', 'specify a port number for server to listen').option('--host <host>', 'specify the host that the server listens to');
    };
    async function runCLI() {
        !function() {
            !function() {
                if (!process.env.NODE_ENV) {
                    let command = process.argv[2];
                    process.env.NODE_ENV = [
                        'build',
                        'preview'
                    ].includes(command) ? 'production' : 'development';
                }
            }(), process.title = 'rsbuild-node';
            let { npm_execpath } = process.env;
            (!npm_execpath || npm_execpath.includes('npx-cli.js') || npm_execpath.includes('.bun')) && console.log(), rslog_index_js_namespaceObject.logger.greet(`  Rsbuild v1.1.13\n`);
        }();
        try {
            !function() {
                program.name('rsbuild').usage('<command> [options]').version("1.1.13");
                let devCommand = program.command('dev'), buildCommand = program.command('build'), previewCommand = program.command('preview'), inspectCommand = program.command('inspect');
                [
                    devCommand,
                    buildCommand,
                    previewCommand,
                    inspectCommand
                ].forEach(applyCommonOptions), [
                    devCommand,
                    previewCommand
                ].forEach(applyServerOptions), devCommand.description('starting the dev server').action(async (options)=>{
                    try {
                        let rsbuild = await init({
                            cliOptions: options
                        });
                        await (null == rsbuild ? void 0 : rsbuild.startDevServer());
                    } catch (err) {
                        rslog_index_js_namespaceObject.logger.error('Failed to start dev server.'), rslog_index_js_namespaceObject.logger.error(err), process.exit(1);
                    }
                }), buildCommand.option('-w --watch', 'turn on watch mode, watch for changes and rebuild').description('build the app for production').action(async (options)=>{
                    try {
                        let rsbuild = await init({
                            cliOptions: options,
                            isBuildWatch: options.watch
                        }), buildInstance = await (null == rsbuild ? void 0 : rsbuild.build({
                            watch: options.watch
                        }));
                        buildInstance && (options.watch ? onBeforeRestartServer(buildInstance.close) : await buildInstance.close());
                    } catch (err) {
                        rslog_index_js_namespaceObject.logger.error('Failed to build.'), rslog_index_js_namespaceObject.logger.error(err), process.exit(1);
                    }
                }), previewCommand.description('preview the production build locally').action(async (options)=>{
                    try {
                        let rsbuild = await init({
                            cliOptions: options
                        });
                        await (null == rsbuild ? void 0 : rsbuild.preview());
                    } catch (err) {
                        rslog_index_js_namespaceObject.logger.error('Failed to start preview server.'), rslog_index_js_namespaceObject.logger.error(err), process.exit(1);
                    }
                }), inspectCommand.description('inspect the Rspack and Rsbuild configs').option('--output <output>', 'specify inspect content output path').option('--verbose', 'show full function definitions in output').action(async (options)=>{
                    try {
                        let rsbuild = await init({
                            cliOptions: options
                        });
                        await (null == rsbuild ? void 0 : rsbuild.inspectConfig({
                            verbose: options.verbose,
                            outputPath: options.output,
                            writeToDisk: !0
                        }));
                    } catch (err) {
                        rslog_index_js_namespaceObject.logger.error('Failed to inspect config.'), rslog_index_js_namespaceObject.logger.error(err), process.exit(1);
                    }
                }), program.parse();
            }();
        } catch (err) {
            rslog_index_js_namespaceObject.logger.error('Failed to start Rsbuild CLI.'), rslog_index_js_namespaceObject.logger.error(err);
        }
    }
    let src_rslib_entry_version = "1.1.13";
})();
var __webpack_export_target__ = exports;
for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
__webpack_exports__.__esModule && Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: !0
});

// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PLUGIN_CSS_NAME,
  PLUGIN_SWC_NAME,
  __internalHelper,
  createRsbuild,
  defineConfig,
  ensureAssetPrefix,
  loadConfig,
  loadEnv,
  logger,
  mergeRsbuildConfig,
  rspack,
  version
});
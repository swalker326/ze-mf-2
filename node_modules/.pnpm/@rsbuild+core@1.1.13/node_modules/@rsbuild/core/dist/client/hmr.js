const compilationId = RSBUILD_COMPILATION_NAME;
const config = RSBUILD_CLIENT_CONFIG;
function formatURL(param) {
    let { port, protocol, hostname, pathname } = param;
    if ('undefined' != typeof URL) {
        const url = new URL('http://localhost');
        url.port = String(port);
        url.hostname = hostname;
        url.protocol = protocol;
        url.pathname = pathname;
        url.searchParams.append('compilationId', compilationId);
        return url.toString();
    }
    const colon = -1 === protocol.indexOf(':') ? ':' : '';
    return `${protocol}${colon}//${hostname}:${port}${pathname}`;
}
let isFirstCompilation = true;
let lastCompilationHash = null;
let hasCompileErrors = false;
function clearOutdatedErrors() {
    if (console.clear && hasCompileErrors) console.clear();
}
let createOverlay;
let clearOverlay;
const registerOverlay = (createFn, clearFn)=>{
    createOverlay = createFn;
    clearOverlay = clearFn;
};
function handleSuccess() {
    clearOutdatedErrors();
    const isHotUpdate = !isFirstCompilation;
    isFirstCompilation = false;
    hasCompileErrors = false;
    if (isHotUpdate) tryApplyUpdates();
}
function handleWarnings(param) {
    let { text } = param;
    clearOutdatedErrors();
    const isHotUpdate = !isFirstCompilation;
    isFirstCompilation = false;
    hasCompileErrors = false;
    for(let i = 0; i < text.length; i++){
        if (5 === i) {
            console.warn('There were more warnings in other files, you can find a complete log in the terminal.');
            break;
        }
        console.warn(text[i]);
    }
    if (isHotUpdate) tryApplyUpdates();
}
function handleErrors(param) {
    let { text, html } = param;
    clearOutdatedErrors();
    isFirstCompilation = false;
    hasCompileErrors = true;
    for (const error of text)console.error(error);
    if (createOverlay) createOverlay(html);
}
const isUpdateAvailable = ()=>lastCompilationHash !== __webpack_hash__;
function tryApplyUpdates() {
    if (!isUpdateAvailable()) return;
    if (!import.meta.webpackHot) {
        reloadPage();
        return;
    }
    if ('idle' !== import.meta.webpackHot.status()) return;
    const handleApplyUpdates = (err, updatedModules)=>{
        const forcedReload = err || !updatedModules;
        if (forcedReload) {
            if (err) console.error('[HMR] Forced reload caused by: ', err);
            reloadPage();
            return;
        }
        if (isUpdateAvailable()) tryApplyUpdates();
    };
    import.meta.webpackHot.check(true).then((updatedModules)=>handleApplyUpdates(null, updatedModules), (err)=>handleApplyUpdates(err, null));
}
let connection = null;
let reconnectCount = 0;
function onOpen() {
    console.info('[HMR] connected.');
}
function onMessage(e) {
    const message = JSON.parse(e.data);
    if (message.compilationId && message.compilationId !== compilationId) return;
    switch(message.type){
        case 'hash':
            lastCompilationHash = message.data;
            if (clearOverlay && isUpdateAvailable()) clearOverlay();
            break;
        case 'still-ok':
        case 'ok':
            handleSuccess();
            break;
        case 'static-changed':
        case 'content-changed':
            reloadPage();
            break;
        case 'warnings':
            handleWarnings(message.data);
            break;
        case 'errors':
            handleErrors(message.data);
            break;
    }
}
function onClose() {
    if (reconnectCount >= config.reconnect) {
        if (config.reconnect > 0) console.info('[HMR] Connection failure after maximum reconnect limit exceeded.');
        return;
    }
    console.info('[HMR] disconnected. Attempting to reconnect.');
    removeListeners();
    connection = null;
    reconnectCount++;
    setTimeout(connect, 1000 * 1.5 ** reconnectCount);
}
function connect() {
    const { location } = self;
    const { host, port, path, protocol } = config;
    const socketUrl = formatURL({
        protocol: protocol || ('https:' === location.protocol ? 'wss' : 'ws'),
        hostname: host || location.hostname,
        port: port || location.port,
        pathname: path || '/rsbuild-hmr'
    });
    connection = new WebSocket(socketUrl);
    connection.addEventListener('open', onOpen);
    connection.addEventListener('close', onClose);
    connection.addEventListener('message', onMessage);
}
function removeListeners() {
    if (connection) {
        connection.removeEventListener('open', onOpen);
        connection.removeEventListener('close', onClose);
        connection.removeEventListener('message', onMessage);
    }
}
function reloadPage() {
    if (RSBUILD_DEV_LIVE_RELOAD) window.location.reload();
}
connect();
export { registerOverlay };
